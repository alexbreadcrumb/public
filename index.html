<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    
    <!-- PWA & Icon Metadata -->
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">
    <meta name="theme-color" content="#1DB954">
    
    <title>Puzzletunes</title>
    <style>
        :root {
            --background: #121212;
            --surface: #1e1e1e;
            --primary: #1DB954;
            --primary-hover: #1ED760;
            --on-background: #FFFFFF;
            --on-surface: #E0E0E0;
            --on-surface-secondary: #B3B3B3;
            --shadow-color: rgba(0, 0, 0, 0.5);
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            --gradient-color-1: #1DB954;
            --gradient-color-2: #1ED760;
            --gradient-color-3: #FFFFFF;
            --gradient-color-4: #1DB954;
            --gradient-color-5: #1ED760;
        }

        html {
            height: 100%;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--background);
            color: var(--on-background);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 1rem;
            padding-top: 5rem; /* Space for fixed top-bar */
            box-sizing: border-box;
            min-height: 100%;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: var(--bg-image, none);
            background-size: cover;
            background-position: center;
            filter: blur(30px) brightness(0.4);
            transform: scale(1.1);
            z-index: -2; /* Ensure it's behind the neon border */
            opacity: var(--bg-opacity, 0);
            transition: opacity 0.7s ease-in-out;
            will-change: opacity, background-image;
        }

        h1 {
            margin: auto 0 0.5rem;
            text-align: center;
            font-weight: 700;
            color: var(--primary);
            width: 100%;
        }

        .top-bar {
            position: fixed;
            top: 0; /* Position at the very top */
            left: 0;
            width: 100%;
            background-color: var(--surface);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            box-sizing: border-box;
            z-index: 100;
            box-shadow: 0 4px 12px var(--shadow-color);
        }
        
        .stats-group, .controls-group {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .main-container {
            width: 100%;
            max-width: 480px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            flex-grow: 1;
        }
        
        @media (max-height: 740px) {
            .main-container {
                gap: 0.5rem;
            }
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            color: var(--on-surface);
        }
        
        .stat-item svg {
            width: 20px;
            height: 20px;
            fill: var(--on-surface-secondary);
        }

        .control-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }
        .control-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background-color: transparent !important;
        }
        .control-button:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .control-button svg {
            width: 24px;
            height: 24px;
            fill: var(--on-surface);
        }

        .puzzle-container {
            width: 95%;
            margin: 0 auto;
            aspect-ratio: 1 / 1;
            position: relative;
            background-color: transparent;
            border-radius: 12px;
            box-shadow: 0 8px 24px var(--shadow-color);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            padding: 2px;
            box-sizing: border-box;
            z-index: 1; /* Establish stacking context */
        }
        
        .puzzle-container.intro-animation-active {
            perspective: 1000px;
        }

        .puzzle-container::after {
            content: '';
            position: absolute;
            inset: 0;
            background-color: var(--surface);
            border-radius: 12px;
            z-index: 0;
        }
        
        @keyframes gradient-flow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .puzzle-container.animated-gradient-border::before {
            content: '';
            position: absolute;
            inset: -5px; /* Increased spread for better visibility */
            z-index: -1; /* Position behind puzzle */
            background: linear-gradient(45deg,
                var(--gradient-color-1),
                var(--gradient-color-2),
                var(--gradient-color-3),
                var(--gradient-color-4),
                var(--gradient-color-5),
                var(--gradient-color-1)
            );
            background-size: 400% 400%;
            animation: gradient-flow 8s ease infinite;
            border-radius: 16px; 
            filter: blur(20px); /* Increased blur for a more prominent glow */
        }


        .puzzle-piece {
            width: 100%;
            height: 100%;
            background-size: 300% 300%;
            transition: transform 0.2s ease-in-out;
            cursor: pointer;
            visibility: visible;
            border-radius: 4px;
            position: relative; /* Ensure pieces are on top of the border background */
            z-index: 2;
        }
        .puzzle-piece.empty {
            visibility: hidden;
            cursor: default;
        }
        .puzzle-piece:not(.empty):hover {
            transform: scale(0.95);
            opacity: 0.9;
        }
        
        /* --- Intro & Swirl Animation Styles --- */
        .puzzle-piece-intro {
            transform-style: preserve-3d;
            transform: translateY(120%) translateZ(-300px) rotateX(-90deg);
            opacity: 0;
            transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.5s ease-out;
            will-change: transform, opacity;
        }
        .puzzle-piece-intro.visible {
            transform: translateY(0) translateZ(0) rotateX(0);
            opacity: 1;
        }
        #start-game-btn {
            background-color: var(--primary);
            color: var(--background);
            font-weight: 700;
            border-radius: 50px;
            padding: 1rem 2rem;
            font-size: 1.2rem;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            transform: scale(0);
            animation: pop-in 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        #start-game-btn:hover {
            background-color: var(--primary-hover);
            transform: scale(1.05);
        }
        @keyframes pop-in {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        @keyframes swirl-out {
            0% {
                transform: rotate(0deg) scale(1);
                opacity: 1;
            }
            100% {
                transform: rotate(720deg) scale(0);
                opacity: 0;
            }
        }
        .puzzle-container.swirl-animation {
            animation: swirl-out 0.8s cubic-bezier(0.6, -0.28, 0.735, 0.045) forwards;
        }
        /* --- End Animation Styles --- */


        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 1.2rem;
            font-weight: 600;
            z-index: 10;
            padding: 1rem;
        }
        
        .overlay h2 {
            font-size: 1.8rem;
            margin: 0 0 1rem 0;
        }

        .overlay p {
            margin: 0.5rem 0;
        }

        .suggestions-container {
            margin-top: 1rem;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .suggestion-btn {
            background-color: var(--primary);
            color: var(--background);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s ease;
        }
        .suggestion-btn:hover {
            background-color: var(--primary-hover);
        }

        .share-btn {
            background-color: var(--primary);
            color: var(--background);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background-color 0.2s ease;
            margin-top: 1.5rem; /* Add space above it */
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        .share-btn:hover {
            background-color: var(--primary-hover);
        }
        .share-btn svg {
            width: 20px;
            height: 20px;
            fill: var(--background);
        }

        .current-track-info {
            text-align: center;
            padding: 0 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        .current-track-info h2 {
            font-size: 1.1rem;
            margin: 0;
            color: var(--on-surface);
        }
        .current-track-info p {
            font-size: 0.9rem;
            margin: 0.25rem 0 0;
            color: var(--on-surface-secondary);
        }
        
        #track-links {
            display: flex;
            gap: 1rem;
            margin-top: 0.25rem;
        }

        .track-link-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease;
        }
        .track-link-btn:hover {
            transform: scale(1.1);
        }
        .track-link-btn svg {
            width: 28px;
            height: 28px;
            fill: var(--on-surface-secondary);
        }


        .new-game-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            width: 100%;
        }
        
        #artist-search {
            flex-grow: 1;
            background-color: var(--surface);
            border: 1px solid var(--on-surface-secondary);
            border-radius: 50px;
            padding: 0.75rem 1rem;
            font-size: 1rem;
            color: var(--on-background);
            min-width: 0; /* Fix for flexbox shrinking */
        }
        
        #new-game-btn {
            background-color: var(--primary);
            color: var(--background);
            font-weight: 700;
            border-radius: 50px;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
            white-space: nowrap;
        }
        #new-game-btn:hover {
            background-color: var(--primary-hover);
        }
        
        @media (max-width: 480px) {
            .new-game-controls {
                flex-direction: column;
                gap: 0.75rem;
            }
            #artist-search, #new-game-btn {
                width: 100%;
                box-sizing: border-box;
            }
        }
        
        @media (max-height: 740px) {
             #artist-search, #new-game-btn {
                padding-top: 0.5rem;
                padding-bottom: 0.5rem;
                font-size: 0.9rem;
            }
        }

        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: var(--surface);
            padding: 1.5rem;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-header h2 {
            margin: 0;
            color: var(--on-surface);
        }
        .modal-header .close-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
        }
        .modal-header .close-btn svg {
            width: 24px;
            height: 24px;
            fill: var(--on-surface-secondary);
        }

        .modal-tabs {
            display: flex;
            border-bottom: 1px solid var(--on-surface-secondary);
            margin-bottom: 1rem;
        }
        .tab-btn {
            background: none;
            border: none;
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-bottom: -1px;
            transition: border-color 0.2s ease, color 0.2s ease;
            font-size: 1.5rem; /* Control emoji size */
            line-height: 1; /* Adjust vertical alignment */
            color: var(--on-surface-secondary);
        }
        .tab-btn:hover {
            color: var(--on-surface);
        }
        .tab-btn.active {
            border-bottom-color: var(--primary);
            color: var(--primary);
        }
        
        .modal-panels {
            flex-grow: 1;
            overflow-y: auto;
        }
        .modal-panel {
            display: none;
        }
        .modal-panel.active {
            display: block;
        }
        
        .language-options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .lang-btn {
            display: flex;
            align-items: center;
            gap: 1rem;
            background-color: rgba(255, 255, 255, 0.05);
            border: 2px solid transparent;
            padding: 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            text-align: left;
            color: var(--on-surface);
            transition: all 0.2s ease;
        }
        .lang-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .lang-btn.active {
            border-color: var(--primary);
            background-color: rgba(29, 185, 84, 0.1);
        }
        
        #info-panel p, #options-panel p {
            line-height: 1.6;
            color: var(--on-surface);
        }

        #options-panel h3 {
            margin-top: 0;
            margin-bottom: 0.75rem;
            color: var(--on-surface);
        }
        
        .genre-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .genre-tag {
            display: block;
        }
        .genre-tag input {
            display: none;
        }
        .genre-tag span {
            display: block;
            padding: 0.5rem 1rem;
            background-color: #333;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
            user-select: none;
        }
        .genre-tag input:checked + span {
            background-color: var(--primary);
            color: var(--background);
            font-weight: 600;
        }
        .genre-tag:hover span {
             background-color: #444;
        }
        .genre-tag input:checked:hover + span {
             background-color: var(--primary-hover);
        }
        

        #total-playtime {
            text-align: center;
            margin-bottom: 1rem;
            font-size: 1.1rem;
            color: var(--on-surface);
        }

        #high-scores-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        #high-scores-list::-webkit-scrollbar { width: 5px; }
        #high-scores-list::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }
        #high-scores-list::-webkit-scrollbar-thumb { background: #555; border-radius: 5px; }

        .score-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            border-radius: 8px;
            background-color: rgba(0,0,0,0.2);
            margin-bottom: 0.5rem;
        }
        .score-rank {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--on-surface-secondary);
            width: 2rem;
            text-align: center;
            flex-shrink: 0;
        }
        .score-item:last-child { margin-bottom: 0; }
        .score-thumbnail {
            width: 60px;
            height: 60px;
            border-radius: 4px;
            object-fit: cover;
            flex-shrink: 0;
        }
        .score-info {
            flex-grow: 1;
            overflow: hidden; /* For marquee */
        }
        .score-track {
            font-weight: 600;
            color: var(--on-surface);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: clip; /* Changed from ellipsis */
        }
        .score-artist {
            color: var(--on-surface-secondary);
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }
        .score-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.8rem;
            color: var(--on-surface-secondary);
        }
        
        .marquee-wrapper {
            overflow: hidden;
        }
        .marquee-content {
            display: inline-block;
            animation: marquee 10s linear infinite;
            animation-play-state: paused;
            padding-right: 2rem; /* space at the end of scroll */
        }
        .marquee-wrapper:hover .marquee-content,
        .marquee-wrapper.animate .marquee-content {
            animation-play-state: running;
        }
        
        @media (hover: none) {
            .marquee-wrapper.animate .marquee-content {
                animation-play-state: running;
            }
        }
        
        @keyframes marquee {
            0% { transform: translateX(0%); }
            100% { transform: translateX(-100%); }
        }
        
        .score-delete-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
            flex-shrink: 0;
        }
        .score-delete-btn svg {
            width: 20px;
            height: 20px;
            fill: #ff4d4d;
        }
        
        /* --- Personal Best Notification Styles --- */
        .personal-best-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        .personal-best-overlay.visible {
            opacity: 1;
        }
        .personal-best-text {
            font-size: clamp(1.8rem, 5vw, 2.5rem);
            font-weight: 700;
            text-align: center;
            padding: 2rem;
            color: #fff;
            animation: pop-in 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            text-shadow:
                0 0 5px #fff,
                0 0 10px #fff,
                0 0 20px var(--gradient-color-1),
                0 0 30px var(--gradient-color-1),
                0 0 40px var(--gradient-color-2),
                0 0 50px var(--gradient-color-2);
        }


        footer {
            width: 100%;
            text-align: center;
            padding: 0.5rem;
            font-size: 0.8rem;
            color: var(--on-surface-secondary);
            flex-shrink: 0;
            margin-top: 0;
        }

    </style>
</head>
<body>
    <audio id="audio-player" crossorigin="anonymous" loop playsinline></audio>

    <div class="top-bar">
        <div class="stats-group">
            <div class="stat-item">
                <svg viewBox="0 0 24 24"><path d="M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10 10-4.486 10-10S17.514 2 12 2zm0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8z"></path><path d="M13 7h-2v5.414l3.293 3.293 1.414-1.414L13 11.586V7z"></path></svg>
                <span id="timer">00:00</span>
            </div>
            <div class="stat-item">
                <svg viewBox="0 0 24 24"><path d="M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6.9-4.9.9-1-2.8-2.8-.9 1c-.4-.3-1-.5-1.5-.5H14v2h.6c.2 0 .5.1.7.3l.9.9v.6h2v-1.5c0-.5-.2-1.1-.5-1.5zm-13 0c-.3.4-.5.9-.5 1.5v1.5h2V6.4l.9-.9c.2-.2.4-.3.7-.3H8V4H7.5c-.5 0-1.1.2-1.6.5l-.9-1-2.8 2.8.9 1zm12.6 9.4-.9 1c.4.3 1 .5 1.5.5H18v2h-.5c-.2 0-.5-.1-.7-.3l-.9-.9v-.6h-2v1.5c0 .5.2 1.1.5 1.5l.9 1 2.8 2.8.9-1c.3-.4.5-.9.5-1.5v-1.5h-2v.6zm-11.8 0h-2v1.5c0 .5.2 1.1.5 1.5l.9 1 2.8 2.8.9-1c.4-.3 1-.5 1.5-.5H10v-2h-.6c-.2 0-.5.1-.7-.3l-.9-.9v-.6h-2v.6z"></path></svg>
                <span id="moves">0</span>
            </div>
        </div>
        <div class="controls-group">
            <button id="pause-btn" class="control-button" data-translate-title="pauseResumeTitle">
                <svg id="pause-icon" viewBox="0 0 24 24"><path d="M8 7h3v10H8zm5 0h3v10h-3z"></path></svg>
                <svg id="play-icon" viewBox="0 0 24 24" style="display: none;"><path d="M7 6v12l10-6z"></path></svg>
            </button>
            <button id="audio-btn" class="control-button" data-translate-title="toggleSoundTitle" disabled>
                <svg id="unmute-icon" viewBox="0 0 24 24" style="display:none;"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"></path></svg>
                <svg id="mute-icon" viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"></path></svg>
            </button>
            <button id="menu-btn" class="control-button" data-translate-title="menuTitle">
                <svg viewBox="0 0 24 24"><path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"></path></svg>
            </button>
        </div>
    </div>

    <div class="main-container">
        <div class="puzzle-container" id="puzzle-container"></div>
        <div class="current-track-info" id="current-track-info">
            <div id="track-text"></div>
            <div id="track-links">
                <a id="apple-music-link" href="#" target="_blank" class="track-link-btn" style="display: none;" title="Listen on Apple Music">
                    <svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-8z"></path></svg>
                </a>
                <a id="spotify-link" href="#" target="_blank" class="track-link-btn" style="display: none;" title="Listen on Spotify">
                    <svg viewBox="0 0 24 24"><path d="M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10 10-4.486 10-10S17.514 2 12 2zm4.183 14.123c-.246.332-.703.43-1.035.183-2.76-1.683-6.22-1.95-10.387-1.02a.662.662 0 0 1-.728-.642c-.01-.36.26-.67.62-.73 4.58-1.02 8.35-.71 11.4 1.18.33.2.43.66.18 1.03zm.88-2.32c-.3.402-.84.522-1.24.222-3.09-1.89-7.73-2.43-11.45-1.32a.803.803 0 0 1-.92-.782c-.01-.44.32-.82.75-.88 4.18-1.21 9.24-.62 12.72 1.54.4.24.52.78.22 1.22zm.08-2.58c-3.53-2.08-9.43-2.28-13.3-1.25a.965.965 0 0 1-1.1-.943c-.02-.52.4-.98.92-1.04 4.3-.92 10.79-.72 14.8 1.58.48.28.64.88.35 1.36-.28.48-.88.64-1.36.35z"></path></svg>
                </a>
            </div>
        </div>

        <div class="new-game-controls">
            <input type="text" id="artist-search" data-translate-placeholder="artistSearchPlaceholder">
            <button id="new-game-btn" data-translate-key="newGame">Nuevo Juego</button>
        </div>
    </div>
    
    <div id="menu-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title" data-translate-key="highScoresTitle">Mejores Tiempos</h2>
                <button class="close-btn" id="close-menu-btn">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
                </button>
            </div>
            <div class="modal-tabs">
                <button class="tab-btn active" data-tab="records">üèÜ</button>
                <button class="tab-btn" data-tab="language">üè≥Ô∏è</button>
                <button class="tab-btn" data-tab="options">‚öôÔ∏è</button>
                <button class="tab-btn" data-tab="info">‚ÑπÔ∏è</button>
            </div>
            <div class="modal-panels">
                <div id="records-panel" class="modal-panel active">
                    <p id="total-playtime"></p>
                    <ol id="high-scores-list"></ol>
                </div>
                <div id="language-panel" class="modal-panel">
                    <div class="language-options">
                        <button class="lang-btn" data-lang="en"><span>üá∫üá∏</span> <span data-translate-key="langEnglish">English</span></button>
                        <button class="lang-btn" data-lang="es"><span>üá™üá∏</span> <span data-translate-key="langSpanish">Espa√±ol</span></button>
                        <button class="lang-btn" data-lang="pt"><span>üáßüá∑</span> <span data-translate-key="langPortuguese">Portugu√™s</span></button>
                        <button class="lang-btn" data-lang="fr"><span>üá´üá∑</span> <span data-translate-key="langFrench">Fran√ßais</span></button>
                    </div>
                </div>
                <div id="options-panel" class="modal-panel">
                    <h3 data-translate-key="favoriteGenresTitle">G√©neros favoritos</h3>
                    <div id="genre-selector" class="genre-selector"></div>
                </div>
                <div id="info-panel" class="modal-panel">
                    <p data-translate-key="aboutGameText"></p>
                </div>
            </div>
        </div>
    </div>
    
    <h1>Puzzletunes</h1>
    <footer><span data-translate-key="gameBy">Juego por:</span> Ale Fern√°ndez PY-2025 - v1.74</footer>

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.0/color-thief.umd.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const SIZE = 3;
            const elements = {
                puzzleContainer: document.getElementById('puzzle-container'),
                timer: document.getElementById('timer'),
                moves: document.getElementById('moves'),
                newGameBtn: document.getElementById('new-game-btn'),
                pauseBtn: document.getElementById('pause-btn'),
                audioBtn: document.getElementById('audio-btn'),
                menuBtn: document.getElementById('menu-btn'),
                artistSearch: document.getElementById('artist-search'),
                trackInfo: document.getElementById('current-track-info'),
                trackText: document.getElementById('track-text'),
                appleMusicLink: document.getElementById('apple-music-link'),
                spotifyLink: document.getElementById('spotify-link'),
                audioPlayer: document.getElementById('audio-player'),
                pauseIcon: document.getElementById('pause-icon'),
                playIcon: document.getElementById('play-icon'),
                muteIcon: document.getElementById('mute-icon'),
                unmuteIcon: document.getElementById('unmute-icon'),
                menuModal: document.getElementById('menu-modal'),
                closeMenuBtn: document.getElementById('close-menu-btn'),
                modalTitle: document.getElementById('modal-title'),
                highScoresList: document.getElementById('high-scores-list'),
            };

            let state = {
                pieces: [],
                moves: 0,
                time: 0,
                timerInterval: null,
                isPaused: true,
                isMuted: true,
                currentAlbum: null,
                gameInProgress: false,
            };

            const PROXIES = [
                'https://cors.eu.org/',
                'https://cors-anywhere.poldisoft.com/',
                'https://thingproxy.freeboard.io/fetch/'
            ];
            
            const colorThief = new ColorThief();

            // --- I18n & Translation ---
            const ALL_GENRES = ['rock', 'pop', 'jazz', 'classical', 'electronic', 'hiphop', 'reggae', 'metal', 'soul', 'funk', 'latin', 'country', 'blues', 'alternative'];
            const translations = {
                es: {
                    pageTitle: "Puzzletunes",
                    pauseResumeTitle: "Pausar/Reanudar",
                    toggleSoundTitle: "Activar/Desactivar Sonido",
                    menuTitle: "Men√∫",
                    highScoresTitle: "Mejores Tiempos",
                    languageTitle: "Idioma",
                    optionsTitle: "Opciones",
                    aboutTitle: "Acerca de",
                    artistSearchPlaceholder: "Buscar por artista (opcional)",
                    newGame: "Nuevo Juego",
                    gameBy: "Juego por:",
                    winMessage: "¬°Ganaste!",
                    winTime: "Tiempo: {time}",
                    winMoves: "Movimientos: {moves}",
                    paused: "Pausado",
                    startMessage: "Haz clic en 'Nuevo Juego' para empezar",
                    searchingMusic: "Buscando m√∫sica...",
                    searchingMusicFor: "Buscando m√∫sica de {searchTerm}...",
                    didYouMean: "Quisiste decir:",
                    imageError: "Error al cargar la imagen. Por favor, intenta de nuevo.",
                    noMusicFoundFor: "No se encontr√≥ m√∫sica para \"{searchTerm}\"",
                    noRandomMusic: "No se encontr√≥ m√∫sica aleatoria. Por favor, intenta de nuevo.",
                    loadSavedImageError: "Error al cargar la imagen guardada.",
                    newGameConfirm: "¬øSeguro que quieres empezar un nuevo juego? Tu progreso se perder√°.",
                    deleteRecordTitle: "Eliminar r√©cord",
                    movesSuffix: "mov.",
                    langEnglish: "Ingl√©s",
                    langSpanish: "Espa√±ol",
                    langPortuguese: "Portugu√™s",
                    langFrench: "Franc√©s",
                    aboutGameText: "¬øSab√≠as que un estudio publicado en Frontiers in Psychology (Montag & Hegelich, 2021) demostr√≥ que el uso excesivo de redes como Instagram y TikTok activa descargas r√°pidas de dopamina, lo que reduce la capacidad de concentraci√≥n y nos vuelve m√°s impacientes? La buena noticia es que pod√©s entrenar tu mente de una forma simple y entretenida: con Puzzletunes, un puzzle digital de 3√ó3 que exige mantener la atenci√≥n y ofrece la recompensa solo al completarlo. Jugar unos minutos al d√≠a se convierte en tu ‚Äúgimnasio mental‚Äù para fortalecer el foco, la paciencia y el autocontrol mientras te diviertes rearmando portadas musicales.",
                    totalPlaytimeText: "Llevas un total de <strong>{time}</strong> en partidas ganadas.",
                    hours_plural: "horas",
                    hour_singular: "hora",
                    minutes_plural: "minutos",
                    minute_singular: "minuto",
                    andConnector: "con",
                    startButton: "Empezar",
                    newTopRecord: "¬°Has logrado un nuevo r√©cord personal en la posici√≥n {rank}!",
                    shareResultTitle: "Compartir Resultado",
                    shareMessage: "¬°Resolv√≠ el puzzle de {artist} - {album} en {time} con {moves} movimientos en Puzzletunes!",
                    favoriteGenresTitle: "G√©neros favoritos",
                    genreAll: "Todos",
                    rock: "Rock", pop: "Pop", jazz: "Jazz", classical: "Cl√°sica", electronic: "Electr√≥nica", hiphop: "Hip-Hop", reggae: "Reggae", metal: "Metal", soul: "Soul", funk: "Funk", latin: "Latina", country: "Country", blues: "Blues", alternative: "Alternativa",
                },
                en: {
                    pageTitle: "Puzzletunes",
                    pauseResumeTitle: "Pause/Resume",
                    toggleSoundTitle: "Toggle Sound",
                    menuTitle: "Menu",
                    highScoresTitle: "High Scores",
                    languageTitle: "Language",
                    optionsTitle: "Options",
                    aboutTitle: "About",
                    artistSearchPlaceholder: "Search by artist (optional)",
                    newGame: "New Game",
                    gameBy: "Game by:",
                    winMessage: "You Win!",
                    winTime: "Time: {time}",
                    winMoves: "Moves: {moves}",
                    paused: "Paused",
                    startMessage: "Click 'New Game' to start",
                    searchingMusic: "Searching for music...",
                    searchingMusicFor: "Searching for music by {searchTerm}...",
                    didYouMean: "Did you mean:",
                    imageError: "Error loading image. Please try again.",
                    noMusicFoundFor: "No music found for \"{searchTerm}\"",
                    noRandomMusic: "No random music found. Please try again.",
                    loadSavedImageError: "Error loading saved image.",
                    newGameConfirm: "Are you sure you want to start a new game? Your progress will be lost.",
                    deleteRecordTitle: "Delete record",
                    movesSuffix: "moves",
                    langEnglish: "English",
                    langSpanish: "Spanish",
                    langPortuguese: "Portuguese",
                    langFrench: "French",
                    aboutGameText: "Did you know that a study published in Frontiers in Psychology (Montag & Hegelich, 2021) showed that excessive use of networks like Instagram and TikTok triggers rapid dopamine releases, reducing concentration and making us more impatient? The good news is you can train your mind in a simple and entertaining way: with Puzzletunes, a 3x3 digital puzzle that demands sustained attention and offers the reward only upon completion. Playing a few minutes a day becomes your 'mental gym' to strengthen focus, patience, and self-control while having fun reassembling music covers.",
                    totalPlaytimeText: "You have a total of <strong>{time}</strong> in won games.",
                    hours_plural: "hours",
                    hour_singular: "hour",
                    minutes_plural: "minutes",
                    minute_singular: "minute",
                    andConnector: "and",
                    startButton: "Start",
                    newTopRecord: "You've achieved a new personal best at rank {rank}!",
                    shareResultTitle: "Share Result",
                    shareMessage: "I solved the {artist} - {album} puzzle in {time} with {moves} moves on Puzzletunes!",
                    favoriteGenresTitle: "Favorite Genres",
                    genreAll: "All",
                    rock: "Rock", pop: "Pop", jazz: "Jazz", classical: "Classical", electronic: "Electronic", hiphop: "Hip-Hop", reggae: "Reggae", metal: "Metal", soul: "Soul", funk: "Funk", latin: "Latin", country: "Country", blues: "Blues", alternative: "Alternative",
                },
                pt: {
                    pageTitle: "Puzzletunes",
                    pauseResumeTitle: "Pausar/Retomar",
                    toggleSoundTitle: "Ativar/Desativar Som",
                    menuTitle: "Menu",
                    highScoresTitle: "Melhores Tempos",
                    languageTitle: "Idioma",
                    optionsTitle: "Op√ß√µes",
                    aboutTitle: "Sobre",
                    artistSearchPlaceholder: "Pesquisar por artista (opcional)",
                    newGame: "Novo Jogo",
                    gameBy: "Jogo por:",
                    winMessage: "Voc√™ Venceu!",
                    winTime: "Tempo: {time}",
                    winMoves: "Movimentos: {moves}",
                    paused: "Pausado",
                    startMessage: "Clique em 'Novo Jogo' para come√ßar",
                    searchingMusic: "Procurando m√∫sica...",
                    searchingMusicFor: "Procurando m√∫sica de {searchTerm}...",
                    didYouMean: "Voc√™ quis dizer:",
                    imageError: "Erro ao carregar a imagem. Por favor, tente novamente.",
                    noMusicFoundFor: "Nenhuma m√∫sica encontrada para \"{searchTerm}\"",
                    noRandomMusic: "Nenhuma m√∫sica aleat√≥ria encontrada. Por favor, tente novamente.",
                    loadSavedImageError: "Erro ao carregar a imagem salva.",
                    newGameConfirm: "Tem certeza que deseja iniciar um novo jogo? Seu progresso ser√° perdido.",
                    deleteRecordTitle: "Excluir recorde",
                    movesSuffix: "mov.",
                    langEnglish: "Ingl√™s",
                    langSpanish: "Espanhol",
                    langPortuguese: "Portugu√™s",
                    langFrench: "Franc√™s",
                    aboutGameText: "Voc√™ sabia que um estudo publicado na Frontiers in Psychology (Montag & Hegelich, 2021) demonstrou que o uso excessivo de redes como Instagram e TikTok ativa libera√ß√µes r√°pidas de dopamina, o que reduz a capacidade de concentra√ß√£o e nos torna mais impacientes? A boa not√≠cia √© que voc√™ pode treinar sua mente de uma forma simples e divertida: com o Puzzletunes, um quebra-cabe√ßa digital 3x3 que exige aten√ß√£o cont√≠nua e oferece a recompensa apenas ao ser completado. Jogar alguns minutos por dia se torna sua 'academia mental' para fortalecer o foco, a paci√™ncia e o autocontrole enquanto voc√™ se diverte remontando capas de √°lbuns.",
                    totalPlaytimeText: "Voc√™ tem um total de <strong>{time}</strong> em jogos ganhos.",
                    hours_plural: "horas",
                    hour_singular: "hora",
                    minutes_plural: "minutos",
                    minute_singular: "minuto",
                    andConnector: "e",
                    startButton: "Come√ßar",
                    newTopRecord: "Voc√™ alcan√ßou um novo recorde pessoal na posi√ß√£o {rank}!",
                    shareResultTitle: "Compartilhar Resultado",
                    shareMessage: "Resolvi o quebra-cabe√ßa de {artist} - {album} em {time} com {moves} movimentos no Puzzletunes!",
                    favoriteGenresTitle: "G√™neros favoritos",
                    genreAll: "Todos",
                    rock: "Rock", pop: "Pop", jazz: "Jazz", classical: "Cl√°ssica", electronic: "Eletr√¥nica", hiphop: "Hip-Hop", reggae: "Reggae", metal: "Metal", soul: "Soul", funk: "Funk", latin: "Latina", country: "Country", blues: "Blues", alternative: "Alternativa",
                },
                fr: {
                    pageTitle: "Puzzletunes",
                    pauseResumeTitle: "Pause/Reprendre",
                    toggleSoundTitle: "Activer/D√©sactiver le son",
                    menuTitle: "Menu",
                    highScoresTitle: "Meilleurs Scores",
                    languageTitle: "Langue",
                    optionsTitle: "Options",
                    aboutTitle: "√Ä propos",
                    artistSearchPlaceholder: "Rechercher par artiste (optionnel)",
                    newGame: "Nouveau Jeu",
                    gameBy: "Jeu par :",
                    winMessage: "Vous avez gagn√© !",
                    winTime: "Temps : {time}",
                    winMoves: "Mouvements : {moves}",
                    paused: "En pause",
                    startMessage: "Cliquez sur 'Nouveau Jeu' pour commencer",
                    searchingMusic: "Recherche de musique...",
                    searchingMusicFor: "Recherche de musique de {searchTerm}...",
                    didYouMean: "Vouliez-vous dire :",
                    imageError: "Erreur de chargement de l'image. Veuillez r√©essayer.",
                    noMusicFoundFor: "Aucune musique trouv√©e pour \"{searchTerm}\"",
                    noRandomMusic: "Aucune musique al√©atoire trouv√©e. Veuillez r√©essayer.",
                    loadSavedImageError: "Erreur de chargement de l'image sauvegard√©e.",
                    newGameConfirm: "√ätes-vous s√ªr de vouloir commencer une nouvelle partie ? Votre progression sera perdue.",
                    deleteRecordTitle: "Supprimer le record",
                    movesSuffix: "mouv.",
                    langEnglish: "Anglais",
                    langSpanish: "Espagnol",
                    langPortuguese: "Portugais",
                    langFrench: "Fran√ßais",
                    aboutGameText: "Saviez-vous qu'une √©tude publi√©e dans Frontiers in Psychology (Montag & Hegelich, 2021) a d√©montr√© que l'utilisation excessive de r√©seaux comme Instagram et TikTok d√©clenche des lib√©rations rapides de dopamine, ce qui r√©duit la capacit√© de concentration et nous rend plus impatients ? La bonne nouvelle est que vous pouvez entra√Æner votre esprit de mani√®re simple et divertissante : avec Puzzletunes, un puzzle num√©rique 3x3 qui exige une attention soutenue et n'offre la r√©compense qu'une fois termin√©. Jouer quelques minutes par jour devient votre 'salle de sport mentale' pour renforcer la concentration, la patience et la ma√Ætrise de soi tout en vous amusant √† reconstituer des pochettes d'albums.",
                    totalPlaytimeText: "Vous avez un total de <strong>{time}</strong> de parties gagn√©es.",
                    hours_plural: "heures",
                    hour_singular: "heure",
                    minutes_plural: "minutes",
                    minute_singular: "minute",
                    andConnector: "et",
                    startButton: "Commencer",
                    newTopRecord: "Vous avez r√©alis√© un nouveau record personnel √† la position {rank} !",
                    shareResultTitle: "Partager le R√©sultat",
                    shareMessage: "J'ai r√©solu le puzzle de {artist} - {album} en {time} avec {moves} mouvements sur Puzzletunes !",
                    favoriteGenresTitle: "Genres favoris",
                    genreAll: "Tous",
                    rock: "Rock", pop: "Pop", jazz: "Jazz", classical: "Classique", electronic: "√âlectronique", hiphop: "Hip-Hop", reggae: "Reggae", metal: "M√©tal", soul: "Soul", funk: "Funk", latin: "Latine", country: "Country", blues: "Blues", alternative: "Alternative",
                }
            };

            let currentStrings = { ...translations.es };

            function getTranslatedString(key, replacements = {}) {
                let str = currentStrings[key] || translations.es[key] || key;
                for (const placeholder in replacements) {
                    str = str.replace(`{${placeholder}}`, replacements[placeholder]);
                }
                return str;
            }

            function applyTranslations() {
                const lang = localStorage.getItem('puzzletunesLanguage') || 'es';
                currentStrings = translations[lang];

                document.documentElement.lang = lang;
                document.title = currentStrings.pageTitle;
                
                document.querySelectorAll('[data-translate-key]').forEach(el => {
                    const key = el.dataset.translateKey;
                    if (currentStrings[key]) {
                        el.innerHTML = currentStrings[key];
                    }
                });
                document.querySelectorAll('[data-translate-placeholder]').forEach(el => {
                    const key = el.dataset.translatePlaceholder;
                    if (currentStrings[key]) el.placeholder = currentStrings[key];
                });
                document.querySelectorAll('[data-translate-title]').forEach(el => {
                    const key = el.dataset.translateTitle;
                    if (currentStrings[key]) el.title = currentStrings[key];
                });
                const gameBySpan = document.querySelector('footer > span');
                if (gameBySpan) gameBySpan.textContent = currentStrings.gameBy;
            }
            
            function setLanguage(lang) {
                if (!translations[lang]) lang = 'en';
                localStorage.setItem('puzzletunesLanguage', lang);
                applyTranslations();
                updateActiveLanguageButton(lang);
                if (elements.menuModal.classList.contains('visible')) {
                    renderHighScores();
                    renderGenreSelector();
                }
            }
            
            function updateActiveLanguageButton(lang) {
                document.querySelectorAll('.lang-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.lang === lang);
                });
            }

            function initializeLocalization() {
                const savedLang = localStorage.getItem('puzzletunesLanguage');
                if (savedLang) {
                    setLanguage(savedLang);
                    return;
                }
                
                const browserLang = (navigator.language || navigator.userLanguage || 'en').slice(0, 2);
                const supportedLangs = ['es', 'en', 'pt', 'fr'];
                const initialLang = supportedLangs.includes(browserLang) ? browserLang : 'en';
                setLanguage(initialLang);
            }
            // --- End I18n ---
            
            // --- Genre Selector ---
            function getSavedGenres() {
                try {
                    const saved = localStorage.getItem('puzzletunesGenres');
                    if (!saved) return ['all'];
                    const parsed = JSON.parse(saved);
                    return Array.isArray(parsed) && parsed.length > 0 ? parsed : ['all'];
                } catch(e) {
                    return ['all'];
                }
            }

            function saveGenres(genres) {
                localStorage.setItem('puzzletunesGenres', JSON.stringify(genres));
            }

            function renderGenreSelector() {
                const selector = document.getElementById('genre-selector');
                if (!selector) return;
                
                const savedGenres = getSavedGenres();
                
                const genresToRender = ['all', ...ALL_GENRES];

                selector.innerHTML = genresToRender.map(genre => `
                    <label class="genre-tag">
                        <input type="checkbox" name="genre" value="${genre}" ${savedGenres.includes(genre) ? 'checked' : ''}>
                        <span>${getTranslatedString(`genre${genre.charAt(0).toUpperCase() + genre.slice(1)}`)}</span>
                    </label>
                `).join('');

                const checkboxes = selector.querySelectorAll('input[name="genre"]');
                checkboxes.forEach(checkbox => {
                    checkbox.addEventListener('change', () => {
                        handleGenreSelection(checkboxes);
                    });
                });
            }

            function handleGenreSelection(checkboxes) {
                const allCheckbox = document.querySelector('input[value="all"]');
                const selectedGenres = Array.from(checkboxes)
                    .filter(cb => cb.checked && cb.value !== 'all')
                    .map(cb => cb.value);

                if (event.target.value === 'all' && event.target.checked) {
                    checkboxes.forEach(cb => { if (cb.value !== 'all') cb.checked = false; });
                    saveGenres(['all']);
                } else {
                    allCheckbox.checked = selectedGenres.length === 0;
                    if (selectedGenres.length > 0) {
                        saveGenres(selectedGenres);
                    } else {
                        saveGenres(['all']);
                    }
                }
            }
            // --- End Genre Selector ---

            async function fetchWithProxyFallback(url) {
                let lastError = null;
                for (const proxy of PROXIES) {
                    try {
                        const response = await fetch(`${proxy}${url}`);
                        if (response.ok) return response;
                        lastError = new Error(`Proxy ${proxy} returned status ${response.status}`);
                    } catch (error) {
                        lastError = error;
                        console.warn(`Proxy ${proxy} failed:`, error);
                    }
                }
                throw lastError || new Error('All CORS proxies failed to fetch.');
            }
            
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
                const secs = (seconds % 60).toString().padStart(2, '0');
                return `${mins}:${secs}`;
            }

            function updateBackground(imageUrl) {
                document.body.style.setProperty('--bg-image', `url('${imageUrl}')`);
                document.body.style.setProperty('--bg-opacity', '1');
            }

            function clearBackground() {
                document.body.style.setProperty('--bg-opacity', '0');
                setTimeout(() => {
                    document.body.style.setProperty('--bg-image', 'none');
                }, 700);
            }

            function updateUI() {
                elements.timer.textContent = formatTime(state.time);
                elements.moves.textContent = state.moves;
                elements.pauseIcon.style.display = state.isPaused ? 'none' : 'block';
                elements.playIcon.style.display = state.isPaused ? 'block' : 'none';
                elements.muteIcon.style.display = state.isMuted ? 'block' : 'none';
                elements.unmuteIcon.style.display = state.isMuted ? 'none' : 'block';
                elements.pauseBtn.disabled = !state.gameInProgress;
            }
            
            function saveGameState() {
                if (!state.currentAlbum) return;
                const gameState = {
                    pieces: state.pieces.map(p => ({ originalIndex: p.originalIndex, currentIndex: p.currentIndex })),
                    moves: state.moves,
                    time: state.time,
                    isPaused: state.isPaused,
                    isMuted: state.isMuted,
                    album: state.currentAlbum,
                    gameInProgress: state.gameInProgress,
                };
                localStorage.setItem('puzzletunesGameState', JSON.stringify(gameState));
            }

            function loadGameState() {
                try {
                    const saved = localStorage.getItem('puzzletunesGameState');
                    if (saved) {
                        const savedState = JSON.parse(saved);
                        if (!savedState.album || !Array.isArray(savedState.pieces)) {
                            throw new Error("Invalid saved state structure.");
                        }
                        state.moves = savedState.moves;
                        state.time = savedState.time;
                        state.isMuted = savedState.isMuted;
                        state.currentAlbum = savedState.album;
                        state.gameInProgress = savedState.gameInProgress;
                        state.isPaused = true;
                        
                        const pieceMap = new Map(savedState.pieces.map(p => [p.currentIndex, p.originalIndex]));
                        state.pieces = Array.from({ length: SIZE * SIZE }, (_, i) => {
                            const originalIndex = pieceMap.get(i);
                            return {
                               el: null,
                               originalIndex: originalIndex,
                               currentIndex: i,
                               isEmpty: originalIndex === SIZE * SIZE - 1
                            };
                        });
                        return true;
                    }
                } catch(e) {
                    console.error("Failed to load game state, clearing.", e);
                    clearGameState();
                }
                return false;
            }
            
            function clearGameState() {
                localStorage.removeItem('puzzletunesGameState');
            }

            function renderBoard() {
                elements.puzzleContainer.innerHTML = '';
                if (!state.currentAlbum) return;
                const imageUrl = state.currentAlbum.artworkUrl.replace('100x100', '600x600');

                for (let i = 0; i < SIZE * SIZE; i++) {
                    const pieceData = state.pieces.find(p => p.currentIndex === i);
                    if(!pieceData) continue;

                    const pieceEl = document.createElement('div');
                    pieceEl.classList.add('puzzle-piece');
                    
                    if (pieceData.isEmpty) {
                        pieceEl.classList.add('empty');
                    } else {
                        const row = Math.floor(pieceData.originalIndex / SIZE);
                        const col = pieceData.originalIndex % SIZE;
                        pieceEl.style.backgroundImage = `url(${imageUrl})`;
                        pieceEl.style.backgroundPosition = `${(col * 100) / (SIZE - 1)}% ${(row * 100) / (SIZE - 1)}%`;
                    }
                    
                    pieceEl.dataset.index = i;
                    pieceEl.addEventListener('click', () => onPieceClick(i));
                    pieceData.el = pieceEl;
                    elements.puzzleContainer.appendChild(pieceEl);
                }
            }
            
            function onPieceClick(clickedIndex) {
                if (state.isPaused) return;

                const emptyPiece = state.pieces.find(p => p.isEmpty);
                const clickedPiece = state.pieces.find(p => p.currentIndex === clickedIndex);
                if (!clickedPiece || clickedPiece.isEmpty) return;

                const emptyIndex = emptyPiece.currentIndex;
                const { row: emptyRow, col: emptyCol } = getRowCol(emptyIndex);
                const { row: clickedRow, col: clickedCol } = getRowCol(clickedIndex);

                const isAdjacent = (Math.abs(emptyRow - clickedRow) === 1 && emptyCol === clickedCol) ||
                                   (Math.abs(emptyCol - clickedCol) === 1 && emptyRow === clickedRow);

                if (isAdjacent) {
                    if (state.moves === 0) {
                        state.isMuted = false;
                        elements.audioPlayer.muted = false;
                        if (elements.audioPlayer.paused) {
                            elements.audioPlayer.play().catch(e => {
                                console.error("Audio play failed on first move:", e);
                                state.isMuted = true;
                                elements.audioPlayer.muted = true;
                            });
                        }
                    }
                    
                    swapPieces(clickedPiece, emptyPiece);
                    state.moves++;
                    
                    updateUI();
                    if (checkWin()) {
                        handleWin();
                    }
                    saveGameState();
                }
            }

            function swapPieces(piece1, piece2) {
                const tempIndex = piece1.currentIndex;
                piece1.currentIndex = piece2.currentIndex;
                piece2.currentIndex = tempIndex;
                renderBoard();
            }

            function getRowCol(index) {
                return { row: Math.floor(index / SIZE), col: index % SIZE };
            }

            function getValidMoves(emptyIndex) {
                const moves = [];
                const { row, col } = getRowCol(emptyIndex);
                if (row > 0) moves.push(emptyIndex - SIZE);
                if (row < SIZE - 1) moves.push(emptyIndex + SIZE);
                if (col > 0) moves.push(emptyIndex - 1);
                if (col < SIZE - 1) moves.push(emptyIndex + 1);
                return moves;
            }

            function checkWin() {
                return state.pieces.every(p => p.currentIndex === p.originalIndex);
            }
            
            function triggerWinCelebration() {
                const rootStyles = getComputedStyle(document.documentElement);
                const paletteColors = [
                    rootStyles.getPropertyValue('--gradient-color-1').trim(),
                    rootStyles.getPropertyValue('--gradient-color-2').trim(),
                    rootStyles.getPropertyValue('--gradient-color-3').trim(),
                    rootStyles.getPropertyValue('--gradient-color-4').trim(),
                    rootStyles.getPropertyValue('--gradient-color-5').trim()
                ].filter(Boolean);

                const colors = paletteColors.length > 0 ? paletteColors : ['#1DB954', '#FFFFFF', '#1ED760'];

                const defaults = {
                    origin: { x: 0.5, y: 0.5 },
                    shapes: ['‚ô™', '‚ô´', '‚ô¨'],
                    colors: colors,
                    disableForReducedMotion: true,
                    gravity: 0.5,
                    scalar: 2.5,
                };

                const fire = (particleCount, options) => confetti({ ...defaults, ...options, particleCount: Math.floor(particleCount) });
                
                fire(200, { spread: 180, startVelocity: 55, decay: 0.9 });
                fire(150, { spread: 120, startVelocity: 45, decay: 0.91, scalar: 2 });
                fire(250, { spread: 360, startVelocity: 30, decay: 0.92, scalar: 1.5 });
            }

            function handleWin() {
                stopTimer();
                elements.puzzleContainer.classList.remove('animated-gradient-border');
                
                triggerWinCelebration();

                state.isPaused = true;
                state.gameInProgress = false;

                const newRank = saveScore();

                setTimeout(() => {
                    const overlay = document.createElement('div');
                    overlay.className = 'overlay';
                    
                    const messageContainer = document.createElement('div');
                    
                    const winTitle = document.createElement('h2');
                    winTitle.textContent = getTranslatedString('winMessage');
                    
                    const timeStat = document.createElement('p');
                    timeStat.textContent = getTranslatedString('winTime', { time: formatTime(state.time) });
                    
                    const movesStat = document.createElement('p');
                    movesStat.textContent = getTranslatedString('winMoves', { moves: state.moves });
                    
                    messageContainer.appendChild(winTitle);
                    messageContainer.appendChild(timeStat);
                    messageContainer.appendChild(movesStat);

                    overlay.appendChild(messageContainer);

                    if (navigator.share) {
                        const shareBtn = document.createElement('button');
                        shareBtn.className = 'share-btn';
                        shareBtn.title = getTranslatedString('shareResultTitle');
                        shareBtn.innerHTML = `
                            <svg viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z"></path></svg>
                            <span>${getTranslatedString('shareResultTitle')}</span>
                        `;
                        shareBtn.onclick = async () => {
                            const shareData = {
                                title: 'Puzzletunes',
                                text: getTranslatedString('shareMessage', {
                                    artist: state.currentAlbum.artistName,
                                    album: state.currentAlbum.collectionName,
                                    time: formatTime(state.time),
                                    moves: state.moves
                                }),
                                url: window.location.href
                            };
                            try {
                                await navigator.share(shareData);
                            } catch(err) {
                                console.error("Share failed:", err);
                            }
                        };
                        messageContainer.appendChild(shareBtn);
                    }
                    elements.puzzleContainer.appendChild(overlay);

                }, 500);

                if (newRank !== -1) {
                    setTimeout(() => showTopRecordNotification(newRank), 1200);
                }

                clearGameState();
                elements.audioPlayer.pause();
                updateUI();
            }
            
            function showTopRecordNotification(rank) {
                const overlay = document.createElement('div');
                overlay.className = 'personal-best-overlay';
                
                const text = document.createElement('div');
                text.className = 'personal-best-text';
                text.innerHTML = getTranslatedString('newTopRecord', { rank });
                
                overlay.appendChild(text);
                document.body.appendChild(overlay);
                
                requestAnimationFrame(() => overlay.classList.add('visible'));

                let confettiInterval = triggerTopRecordCelebration();

                overlay.addEventListener('click', () => {
                    overlay.classList.remove('visible');
                    clearInterval(confettiInterval);
                    confetti.reset();
                    overlay.addEventListener('transitionend', () => overlay.remove());
                }, { once: true });
            }

            function triggerTopRecordCelebration() {
                const end = Date.now() + (3 * 1000);
                const colors = ['#FFD700', '#FFDF00', '#F0E68C'];

                const frame = () => {
                    if (Date.now() > end) {
                        return;
                    }

                    confetti({ particleCount: 2, angle: 60, spread: 55, origin: { x: 0 }, colors: colors, shapes: ['star'] });
                    confetti({ particleCount: 2, angle: 120, spread: 55, origin: { x: 1 }, colors: colors, shapes: ['star'] });
                };
                
                const intervalId = setInterval(frame, 200);
                frame();
                return intervalId;
            }


            function getHighScores() {
                try {
                    const storedScores = localStorage.getItem('puzzletunesHighScores');
                    if (!storedScores) return [];
                    const parsedScores = JSON.parse(storedScores);
                    if (Array.isArray(parsedScores)) {
                        return parsedScores.filter(s => s && typeof s.time === 'number' && s.album);
                    }
                } catch (e) {
                    console.error("Could not parse high scores, returning empty list.", e);
                }
                return [];
            }
            
            function saveScore() {
                if (!state.currentAlbum) return -1;

                let totalPlaytime = parseInt(localStorage.getItem('puzzletunesTotalPlaytime'), 10) || 0;
                totalPlaytime += state.time;
                localStorage.setItem('puzzletunesTotalPlaytime', totalPlaytime);

                const newScore = {
                    time: state.time,
                    moves: state.moves,
                    album: { ...state.currentAlbum },
                    id: Date.now()
                };

                let highScores = getHighScores();
                highScores.push(newScore);

                highScores.sort((a, b) => {
                    if (a.time !== b.time) return a.time - b.time;
                    return a.moves - b.moves;
                });
                
                if (highScores.length > 10) {
                    highScores = highScores.slice(0, 10);
                }

                localStorage.setItem('puzzletunesHighScores', JSON.stringify(highScores));
                
                const newRank = highScores.findIndex(score => score.id === newScore.id) + 1;
                return (newRank > 0 && newRank <= 3) ? newRank : -1;
            }


            function renderHighScores() {
                const highScores = getHighScores();
                
                const totalPlaytimeEl = document.getElementById('total-playtime');
                const totalSeconds = parseInt(localStorage.getItem('puzzletunesTotalPlaytime'), 10) || 0;
                
                if (totalSeconds > 0) {
                    const hours = Math.floor(totalSeconds / 3600);
                    const minutes = Math.floor((totalSeconds % 3600) / 60);
                    const timeParts = [];
                    if (hours > 0) {
                        const hourKey = hours === 1 ? 'hour_singular' : 'hours_plural';
                        timeParts.push(`${hours} ${getTranslatedString(hourKey)}`);
                    }
                    if (minutes > 0 || hours === 0) {
                        const minuteKey = minutes === 1 ? 'minute_singular' : 'minutes_plural';
                        timeParts.push(`${minutes} ${getTranslatedString(minuteKey)}`);
                    }
                    const formattedTime = timeParts.join(` ${getTranslatedString('andConnector')} `);
                    totalPlaytimeEl.innerHTML = `‚è∞ ${getTranslatedString('totalPlaytimeText', { time: formattedTime })}`;
                } else {
                    totalPlaytimeEl.innerHTML = '';
                }

                elements.highScoresList.innerHTML = highScores.map((item, index) => {
                    const wrapperId = `marquee-wrapper-${item.id}`;
                    const year = item.album.releaseDate ? new Date(item.album.releaseDate).getFullYear() : '';
                    const artistText = year ? `${item.album.artistName} (${year})` : item.album.artistName;

                    const html = `
                        <li class="score-item">
                            <span class="score-rank">${index + 1}</span>
                            <img src="${item.album.artworkUrl}" class="score-thumbnail" alt="Artwork for ${item.album.collectionName}">
                            <div class="score-info">
                                <p class="score-artist">${artistText}</p>
                                <div class="marquee-wrapper" id="${wrapperId}">
                                    <p class="score-track marquee-content">${item.album.collectionName}</p>
                                </div>
                                <div class="score-stats">
                                    <span>${formatTime(item.time)}</span>
                                    <span>${item.moves} ${getTranslatedString('movesSuffix')}</span>
                                </div>
                            </div>
                            <button class="score-delete-btn" data-id="${item.id}" title="${getTranslatedString('deleteRecordTitle')}">
                                <svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></svg>
                            </button>
                        </li>`;
                    
                    setTimeout(() => {
                        const wrapper = document.getElementById(wrapperId);
                        const content = wrapper?.querySelector('.marquee-content');
                        if (wrapper && content && content.scrollWidth > wrapper.clientWidth) {
                            wrapper.classList.add('animate');
                        }
                    }, 0);
                    return html;
                }).join('');
            }
            
            function deleteScore(id) {
                let highScores = getHighScores().filter(score => score.id !== id);
                localStorage.setItem('puzzletunesHighScores', JSON.stringify(highScores));
                renderHighScores();
            }

            function showOverlay(htmlContent, suggestions = []) {
                hideOverlay();
                const overlay = document.createElement('div');
                overlay.className = 'overlay';
                overlay.innerHTML = `<div>${htmlContent}</div>`;
                
                if (suggestions.length > 0) {
                    const suggestionsContainer = document.createElement('div');
                    suggestionsContainer.className = 'suggestions-container';
                    suggestions.forEach(suggestion => {
                        const btn = document.createElement('button');
                        btn.className = 'suggestion-btn';
                        btn.textContent = suggestion;
                        btn.onclick = () => {
                            elements.artistSearch.value = suggestion;
                            prepareNewGame(true);
                        };
                        suggestionsContainer.appendChild(btn);
                    });
                    overlay.appendChild(suggestionsContainer);
                }
                elements.puzzleContainer.appendChild(overlay);
            }

            function hideOverlay() {
                const overlay = elements.puzzleContainer.querySelector('.overlay');
                if (overlay) overlay.remove();
            }
            
            async function findAlbumWithMusic(searchTerm, isArtistSearch = false) {
                const userGenres = getSavedGenres();
                const genresToSearch = (userGenres.includes('all') || userGenres.length === 0) ? ALL_GENRES : userGenres;
                const MAX_ATTEMPTS = 5;

                const searchAndProcess = async (url) => {
                    try {
                        const response = await fetchWithProxyFallback(url);
                        const data = await response.json();
                        const songsWithPreview = data.results.filter(song => song.previewUrl && song.artworkUrl100 && song.trackViewUrl && song.trackName && song.releaseDate);
                        if (songsWithPreview.length === 0) return null;

                        const albums = songsWithPreview.reduce((acc, song) => {
                            if (!acc[song.collectionId]) {
                                acc[song.collectionId] = {
                                    artistName: song.artistName,
                                    collectionName: song.collectionName,
                                    artworkUrl: song.artworkUrl100,
                                    previewUrl: song.previewUrl,
                                    trackViewUrl: song.trackViewUrl,
                                    trackName: song.trackName,
                                    releaseDate: song.releaseDate
                                };
                            }
                            return acc;
                        }, {});

                        let albumArray = Object.values(albums);

                        albumArray.sort((a, b) => new Date(b.releaseDate) - new Date(a.releaseDate));
                        
                        if (albumArray.length === 0) return null;

                        // More aggressive selection of recent music
                        const selectionSize = Math.min(25, Math.ceil(albumArray.length * 0.2));
                        const newestAlbums = albumArray.slice(0, selectionSize);

                        return newestAlbums[Math.floor(Math.random() * newestAlbums.length)];
                    } catch (error) {
                        console.error('Error in searchAndProcess:', error);
                        return null;
                    }
                };

                if (isArtistSearch) {
                    const searchUrl = `https://itunes.apple.com/search?term=${encodeURIComponent(searchTerm)}&entity=song&limit=200&attribute=artistTerm`;
                    return await searchAndProcess(searchUrl);
                }
                for (let i = 0; i < MAX_ATTEMPTS; i++) {
                    const genre = genresToSearch[Math.floor(Math.random() * genresToSearch.length)];
                    const searchUrl = `https://itunes.apple.com/search?term=${encodeURIComponent(genre)}&entity=song&limit=200`;
                    const result = await searchAndProcess(searchUrl);
                    if (result) return result;
                    console.warn(`Random search attempt ${i + 1} failed. Retrying...`);
                }
                return null;
            }
            
            const calculateLevenshteinDistance = (a, b) => {
                const matrix = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(null));
                for (let i = 0; i <= a.length; i++) { matrix[0][i] = i; }
                for (let j = 0; j <= b.length; j++) { matrix[j][0] = j; }
                for (let j = 1; j <= b.length; j++) {
                    for (let i = 1; i <= a.length; i++) {
                        const cost = a[i - 1] === b[j - 1] ? 0 : 1;
                        matrix[j][i] = Math.min(matrix[j][i - 1] + 1, matrix[j - 1][i] + 1, matrix[j - 1][i - 1] + cost);
                    }
                }
                return matrix[b.length][a.length];
            };
            
            async function findSuggestions(searchTerm) {
                try {
                    const response = await fetchWithProxyFallback(`https://itunes.apple.com/search?term=${encodeURIComponent(searchTerm)}&entity=song&limit=50`);
                    const data = await response.json();
                    return [...new Set(data.results.map(r => r.artistName))]
                        .map(name => ({ name, distance: calculateLevenshteinDistance(searchTerm.toLowerCase(), name.toLowerCase()) }))
                        .filter(item => item.distance < 4 && item.name.toLowerCase() !== searchTerm.toLowerCase())
                        .sort((a, b) => a.distance - b.distance)
                        .map(item => item.name)
                        .slice(0, 3);
                } catch (error) {
                    console.error('Error finding suggestions:', error);
                    return [];
                }
            }
            
            async function prepareNewGame(isFromSuggestion = false) {
                const searchTerm = elements.artistSearch.value.trim();
                const isArtistSearch = searchTerm.length > 0;
                
                const overlayMessage = isArtistSearch 
                    ? getTranslatedString('searchingMusicFor', { searchTerm }) 
                    : getTranslatedString('searchingMusic');
                showOverlay(overlayMessage);

                let album = await findAlbumWithMusic(searchTerm, isArtistSearch);
                
                if (!album && isArtistSearch && !isFromSuggestion) {
                    const suggestions = await findSuggestions(searchTerm);
                    if (suggestions.length > 0) {
                        showOverlay(getTranslatedString('didYouMean'), suggestions);
                        return;
                    }
                }

                if (album) {
                    state.currentAlbum = album;
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.src = state.currentAlbum.artworkUrl.replace('100x100', '600x600');
                    img.onload = () => {
                        try {
                            const palette = colorThief.getPalette(img, 5);
                            palette.forEach((c, i) => document.documentElement.style.setProperty(`--gradient-color-${i + 1}`, `rgb(${c[0]}, ${c[1]}, ${c[2]})`));
                        } catch(e) { console.error("ColorThief failed:", e); }
                        updateBackground(img.src);
                        hideOverlay();
                        playIntroAnimation();
                    };
                    img.onerror = () => showOverlay(getTranslatedString('imageError'));
                } else {
                    const message = isArtistSearch ? getTranslatedString('noMusicFoundFor', {searchTerm}) : getTranslatedString('noRandomMusic');
                    showOverlay(message);
                }
            }

            function cleanupPreviousGameResources() {
                stopTimer();
                clearGameState();
                elements.audioPlayer.pause();
                elements.audioPlayer.removeAttribute('src');
                elements.audioPlayer.load();
                clearBackground();
                elements.puzzleContainer.innerHTML = '';
                elements.trackText.innerHTML = '';
                hideTrackLinks();
                state.currentAlbum = null;
                state.gameInProgress = false;
                state.isPaused = true;
                state.time = 0;
                state.moves = 0;
                updateUI();
            }

            function updateTrackLinks(album) {
                if (!album || !album.trackViewUrl || !album.trackName) {
                    hideTrackLinks();
                    return;
                }

                elements.appleMusicLink.href = album.trackViewUrl;
                elements.appleMusicLink.style.display = 'flex';

                const spotifyQuery = `${album.artistName} ${album.trackName}`;
                const spotifyUrl = `https://open.spotify.com/search/${encodeURIComponent(spotifyQuery)}`;
                elements.spotifyLink.href = spotifyUrl;
                elements.spotifyLink.style.display = 'flex';
            }

            function hideTrackLinks() {
                elements.appleMusicLink.style.display = 'none';
                elements.appleMusicLink.href = '#';
                elements.spotifyLink.style.display = 'none';
                elements.spotifyLink.href = '#';
            }
            
            function updateTrackText() {
                if (!state.currentAlbum) {
                    elements.trackText.innerHTML = '';
                    return;
                }
                const year = state.currentAlbum.releaseDate ? new Date(state.currentAlbum.releaseDate).getFullYear() : '';
                const artistText = year ? `${state.currentAlbum.artistName} (${year})` : state.currentAlbum.artistName;
                elements.trackText.innerHTML = `<h2>${state.currentAlbum.collectionName}</h2><p>${artistText}</p>`;
            }

            function playIntroAnimation() {
                elements.puzzleContainer.innerHTML = '';
                elements.puzzleContainer.classList.remove('animated-gradient-border');
                elements.puzzleContainer.classList.add('intro-animation-active');
                updateTrackText();
                updateTrackLinks(state.currentAlbum);
                
                const imageUrl = state.currentAlbum.artworkUrl.replace('100x100', '600x600');
                const pieces = [];

                for (let i = 0; i < SIZE * SIZE; i++) {
                    const pieceEl = document.createElement('div');
                    pieceEl.classList.add('puzzle-piece', 'puzzle-piece-intro');
                    const row = Math.floor(i / SIZE);
                    const col = i % SIZE;
                    pieceEl.style.backgroundImage = `url(${imageUrl})`;
                    pieceEl.style.backgroundPosition = `${(col * 100) / (SIZE - 1)}% ${(row * 100) / (SIZE - 1)}%`;
                    elements.puzzleContainer.appendChild(pieceEl);
                    pieces.push(pieceEl);
                }

                const shuffledIndices = [...Array(pieces.length).keys()].sort(() => Math.random() - 0.5);
                shuffledIndices.forEach((index, i) => {
                    setTimeout(() => {
                        pieces[index].classList.add('visible');
                    }, i * 100);
                });
                
                setTimeout(() => {
                    const startOverlay = document.createElement('div');
                    startOverlay.className = 'overlay';
                    startOverlay.style.backgroundColor = 'rgba(0,0,0,0.5)';
                    const startButton = document.createElement('button');
                    startButton.id = 'start-game-btn';
                    startButton.textContent = getTranslatedString('startButton');
                    startOverlay.appendChild(startButton);
                    elements.puzzleContainer.appendChild(startOverlay);

                    startButton.onclick = () => {
                        startOverlay.remove();
                        elements.puzzleContainer.classList.add('swirl-animation');
                        setTimeout(() => {
                            elements.puzzleContainer.classList.remove('swirl-animation', 'intro-animation-active');
                            elements.puzzleContainer.style.opacity = '0';
                            startNewGame();
                            requestAnimationFrame(() => {
                                elements.puzzleContainer.style.transition = 'opacity 0.4s ease';
                                elements.puzzleContainer.style.opacity = '1';
                                setTimeout(() => { elements.puzzleContainer.style.transition = ''; elements.puzzleContainer.style.opacity = ''; }, 400);
                            });
                        }, 800);
                    };
                }, (shuffledIndices.length * 100) + 800);
            }

            function startNewGame() {
                state.time = 0;
                state.moves = 0;
                state.isPaused = false;
                state.isMuted = true;
                state.gameInProgress = true;
                
                let board = Array.from({ length: SIZE * SIZE }, (_, i) => i);
                let emptyPosition = SIZE * SIZE - 1;
                let lastMove = -1;

                const shuffleMoves = 150; 
                for (let i = 0; i < shuffleMoves; i++) {
                    const validMoves = getValidMoves(emptyPosition);
                    const possibleMoves = validMoves.filter(pos => pos !== lastMove);
                    const move = possibleMoves.length > 0 ? possibleMoves[Math.floor(Math.random() * possibleMoves.length)] : validMoves[0];
                    [board[emptyPosition], board[move]] = [board[move], board[emptyPosition]];
                    lastMove = emptyPosition;
                    emptyPosition = move;
                }
                
                state.pieces = Array.from({ length: SIZE * SIZE }, (_, i) => ({
                    el: null,
                    originalIndex: i,
                    currentIndex: board.indexOf(i),
                    isEmpty: i === SIZE * SIZE - 1
                }));

                renderBoard();
                startTimer();
                elements.puzzleContainer.classList.add('animated-gradient-border');
                updateTrackText();
                updateTrackLinks(state.currentAlbum);
                elements.audioPlayer.src = state.currentAlbum.previewUrl;
                elements.audioBtn.disabled = true;
                elements.audioPlayer.muted = true;
                updateUI();
                saveGameState();
            }

            function initGame() {
                if (loadGameState() && state.gameInProgress) {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.src = state.currentAlbum.artworkUrl.replace('100x100', '600x600');
                    img.onload = () => {
                        try {
                            const palette = colorThief.getPalette(img, 5);
                            palette.forEach((c, i) => document.documentElement.style.setProperty(`--gradient-color-${i + 1}`, `rgb(${c[0]}, ${c[1]}, ${c[2]})`));
                        } catch(e) { console.error("ColorThief failed on load:", e); }
                        updateBackground(img.src);
                        renderBoard();
                        startTimer();
                        elements.puzzleContainer.classList.add('animated-gradient-border');
                        updateUI();
                        showOverlay(getTranslatedString('paused'));
                        updateTrackText();
                        updateTrackLinks(state.currentAlbum);
                        if (state.currentAlbum.previewUrl) {
                            elements.audioPlayer.src = state.currentAlbum.previewUrl;
                        }
                    };
                     img.onerror = () => showOverlay(getTranslatedString('loadSavedImageError'));
                } else {
                    cleanupPreviousGameResources();
                    showOverlay(getTranslatedString('startMessage'));
                }
            }
            
            function startTimer() {
                if (state.timerInterval) clearInterval(state.timerInterval);
                state.timerInterval = setInterval(() => {
                    if (!state.isPaused) {
                        state.time++;
                        elements.timer.textContent = formatTime(state.time);
                    }
                }, 1000);
            }

            function stopTimer() {
                clearInterval(state.timerInterval);
                state.timerInterval = null;
            }

            function switchTab(tabName) {
                const modal = elements.menuModal;
                modal.querySelectorAll('.tab-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.tab === tabName));
                modal.querySelectorAll('.modal-panel').forEach(panel => panel.classList.toggle('active', panel.id === `${tabName}-panel`));
                
                let titleKey;
                if(tabName === 'records') titleKey = 'highScoresTitle';
                else if (tabName === 'language') titleKey = 'languageTitle';
                else if (tabName === 'options') titleKey = 'optionsTitle';
                else if (tabName === 'info') titleKey = 'aboutTitle';
                elements.modalTitle.textContent = getTranslatedString(titleKey);
                elements.modalTitle.dataset.translateKey = titleKey;
            }

            elements.menuModal.addEventListener('click', (e) => {
                const tabBtn = e.target.closest('.tab-btn');
                if (tabBtn) switchTab(tabBtn.dataset.tab);

                const langBtn = e.target.closest('.lang-btn');
                if(langBtn) setLanguage(langBtn.dataset.lang);
            });

            elements.newGameBtn.addEventListener('click', () => {
                if (state.gameInProgress && !confirm(getTranslatedString('newGameConfirm'))) return;
                cleanupPreviousGameResources();
                prepareNewGame();
            });

            elements.pauseBtn.addEventListener('click', () => {
                if (!state.gameInProgress) return;
                state.isPaused = !state.isPaused;
                if (state.isPaused) {
                    stopTimer();
                    elements.audioPlayer.pause();
                    showOverlay(getTranslatedString('paused'));
                    elements.puzzleContainer.classList.remove('animated-gradient-border');
                } else {
                    hideOverlay();
                    startTimer();
                    elements.puzzleContainer.classList.add('animated-gradient-border');
                    if (!state.isMuted && elements.audioPlayer.src) {
                        elements.audioPlayer.play().catch(e => console.error("Error on resume:", e));
                    }
                }
                updateUI();
                saveGameState();
            });

            elements.audioBtn.addEventListener('click', () => {
                state.isMuted = !state.isMuted;
                elements.audioPlayer.muted = state.isMuted;
                if (elements.audioPlayer.paused && !state.isMuted) {
                    elements.audioPlayer.play().catch(e => {
                        console.error("Error on unmute:", e);
                        state.isMuted = true;
                        elements.audioPlayer.muted = true;
                    });
                }
                updateUI();
                if (state.gameInProgress) saveGameState();
            });

            elements.audioPlayer.addEventListener('canplaythrough', () => elements.audioBtn.disabled = false);
            
            elements.menuBtn.addEventListener('click', () => {
                renderHighScores();
                renderGenreSelector();
                switchTab('records');
                elements.menuModal.classList.add('visible');
            });
            elements.closeMenuBtn.addEventListener('click', () => elements.menuModal.classList.remove('visible'));

            elements.highScoresList.addEventListener('click', (e) => {
                const deleteBtn = e.target.closest('.score-delete-btn');
                if (deleteBtn) deleteScore(parseInt(deleteBtn.dataset.id, 10));
            });
            window.addEventListener('beforeunload', () => state.gameInProgress && saveGameState());
            
            initializeLocalization();
            initGame();
        });
    </script>
</body>
</html>
