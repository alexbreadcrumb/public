<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    
    <!-- PWA & Icon Metadata -->
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">
    <meta name="theme-color" content="#1DB954">
    
    <title>Puzzletunes</title>
    <style>
        :root {
            --background: #121212;
            --surface: #1e1e1e;
            --primary: #1DB954;
            --primary-hover: #1ED760;
            --on-background: #FFFFFF;
            --on-surface: #E0E0E0;
            --on-surface-secondary: #B3B3B3;
            --shadow-color: rgba(0, 0, 0, 0.5);
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            --gradient-color-1: #1DB954;
            --gradient-color-2: #1ED760;
            --gradient-color-3: #FFFFFF;
            --gradient-color-4: #1DB954;
            --gradient-color-5: #1ED760;
        }

        html {
            height: 100%;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--background);
            color: var(--on-background);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 1rem;
            padding-top: 5rem; /* Space for fixed top-bar */
            box-sizing: border-box;
            min-height: 100%;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: var(--bg-image, none);
            background-size: cover;
            background-position: center;
            filter: blur(30px) brightness(0.4);
            transform: scale(1.1);
            z-index: -1;
            opacity: var(--bg-opacity, 0);
            transition: opacity 0.7s ease-in-out;
            will-change: opacity, background-image;
        }

        h1 {
            margin: auto 0 0.5rem;
            text-align: center;
            font-weight: 700;
            color: var(--primary);
            width: 100%;
        }

        .top-bar {
            position: fixed;
            top: 0; /* Position at the very top */
            left: 0;
            width: 100%;
            background-color: var(--surface);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            box-sizing: border-box;
            z-index: 100;
            box-shadow: 0 4px 12px var(--shadow-color);
        }
        
        .stats-group, .controls-group {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .main-container {
            width: 100%;
            max-width: 480px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            flex-grow: 1;
        }
        
        @media (max-height: 740px) {
            .main-container {
                gap: 0.5rem;
            }
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            color: var(--on-surface);
        }
        
        .stat-item svg {
            width: 20px;
            height: 20px;
            fill: var(--on-surface-secondary);
        }

        .control-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }
        .control-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background-color: transparent !important;
        }
        .control-button:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .control-button svg {
            width: 24px;
            height: 24px;
            fill: var(--on-surface);
        }

        .puzzle-container {
            width: 95%;
            margin: 0 auto;
            aspect-ratio: 1 / 1;
            position: relative;
            background-color: transparent;
            border-radius: 12px;
            box-shadow: 0 8px 24px var(--shadow-color);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            padding: 2px;
            box-sizing: border-box;
        }
        
        .puzzle-container::after {
            content: '';
            position: absolute;
            inset: 0;
            background-color: var(--surface);
            border-radius: 12px;
            z-index: -1;
        }
        
        @keyframes gradient-flow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .puzzle-container.animated-gradient-border::before {
            content: '';
            position: absolute;
            inset: -1px; /* Increased spread */
            z-index: -2;
            background: linear-gradient(45deg,
                var(--gradient-color-1),
                var(--gradient-color-2),
                var(--gradient-color-3),
                var(--gradient-color-4),
                var(--gradient-color-5),
                var(--gradient-color-1)
            );
            background-size: 400% 400%;
            animation: gradient-flow 8s ease infinite;
            border-radius: 16px; 
            filter: blur(15px); /* Increased blur for a softer glow */
        }


        .puzzle-piece {
            width: 100%;
            height: 100%;
            background-size: 300% 300%;
            transition: transform 0.2s ease-in-out;
            cursor: pointer;
            visibility: visible;
            border-radius: 4px;
        }
        .puzzle-piece.empty {
            visibility: hidden;
            cursor: default;
        }
        .puzzle-piece:not(.empty):hover {
            transform: scale(0.95);
            opacity: 0.9;
        }

        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 1.5rem;
            font-weight: 600;
            z-index: 10;
            padding: 1rem;
        }
        
        .suggestions-container {
            margin-top: 1rem;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .suggestion-btn {
            background-color: var(--primary);
            color: var(--background);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s ease;
        }
        .suggestion-btn:hover {
            background-color: var(--primary-hover);
        }

        .current-track-info {
            text-align: center;
            padding: 0 1rem;
        }
        .current-track-info h2 {
            font-size: 1.1rem;
            margin: 0;
            color: var(--on-surface);
        }
        .current-track-info p {
            font-size: 0.9rem;
            margin: 0.25rem 0 0;
            color: var(--on-surface-secondary);
        }

        .new-game-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            width: 100%;
        }
        
        #artist-search {
            flex-grow: 1;
            background-color: var(--surface);
            border: 1px solid var(--on-surface-secondary);
            border-radius: 50px;
            padding: 0.75rem 1rem;
            font-size: 1rem;
            color: var(--on-background);
            min-width: 0; /* Fix for flexbox shrinking */
        }
        
        #new-game-btn {
            background-color: var(--primary);
            color: var(--background);
            font-weight: 700;
            border-radius: 50px;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
            white-space: nowrap;
        }
        #new-game-btn:hover {
            background-color: var(--primary-hover);
        }
        
        @media (max-width: 480px) {
            .new-game-controls {
                flex-direction: column;
                gap: 0.75rem;
            }
            #artist-search, #new-game-btn {
                width: 100%;
                box-sizing: border-box;
            }
        }
        
        @media (max-height: 740px) {
             #artist-search, #new-game-btn {
                padding-top: 0.5rem;
                padding-bottom: 0.5rem;
                font-size: 0.9rem;
            }
        }

        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: var(--surface);
            padding: 1.5rem;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-header h2 {
            margin: 0;
            color: var(--on-surface);
        }
        .modal-header .close-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
        }
        .modal-header .close-btn svg {
            width: 24px;
            height: 24px;
            fill: var(--on-surface-secondary);
        }

        .modal-tabs {
            display: flex;
            border-bottom: 1px solid var(--on-surface-secondary);
            margin-bottom: 1rem;
        }
        .tab-btn {
            background: none;
            border: none;
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-bottom: -1px;
            transition: border-color 0.2s ease, color 0.2s ease;
            font-size: 1.5rem; /* Control emoji size */
            line-height: 1; /* Adjust vertical alignment */
            color: var(--on-surface-secondary);
        }
        .tab-btn:hover {
            color: var(--on-surface);
        }
        .tab-btn.active {
            border-bottom-color: var(--primary);
            color: var(--primary);
        }
        
        .modal-panels {
            flex-grow: 1;
            overflow-y: auto;
        }
        .modal-panel {
            display: none;
        }
        .modal-panel.active {
            display: block;
        }
        
        .language-options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .lang-btn {
            display: flex;
            align-items: center;
            gap: 1rem;
            background-color: rgba(255, 255, 255, 0.05);
            border: 2px solid transparent;
            padding: 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            text-align: left;
            color: var(--on-surface);
            transition: all 0.2s ease;
        }
        .lang-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .lang-btn.active {
            border-color: var(--primary);
            background-color: rgba(29, 185, 84, 0.1);
        }

        #info-panel p {
            line-height: 1.6;
            color: var(--on-surface);
        }

        #high-scores-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        #high-scores-list::-webkit-scrollbar { width: 5px; }
        #high-scores-list::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }
        #high-scores-list::-webkit-scrollbar-thumb { background: #555; border-radius: 5px; }

        .score-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            border-radius: 8px;
            background-color: rgba(0,0,0,0.2);
            margin-bottom: 0.5rem;
        }
        .score-rank {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--on-surface-secondary);
            width: 2rem;
            text-align: center;
            flex-shrink: 0;
        }
        .score-item:last-child { margin-bottom: 0; }
        .score-thumbnail {
            width: 60px;
            height: 60px;
            border-radius: 4px;
            object-fit: cover;
            flex-shrink: 0;
        }
        .score-info {
            flex-grow: 1;
            overflow: hidden; /* For marquee */
        }
        .score-track {
            font-weight: 600;
            color: var(--on-surface);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: clip; /* Changed from ellipsis */
        }
        .score-artist {
            color: var(--on-surface-secondary);
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }
        .score-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.8rem;
            color: var(--on-surface-secondary);
        }
        
        .marquee-wrapper {
            overflow: hidden;
        }
        .marquee-content {
            display: inline-block;
            animation: marquee 10s linear infinite;
            animation-play-state: paused;
            padding-right: 2rem; /* space at the end of scroll */
        }
        .marquee-wrapper:hover .marquee-content,
        .marquee-wrapper.animate .marquee-content {
            animation-play-state: running;
        }
        
        @media (hover: none) {
            .marquee-wrapper.animate .marquee-content {
                animation-play-state: running;
            }
        }
        
        @keyframes marquee {
            0% { transform: translateX(0%); }
            100% { transform: translateX(-100%); }
        }
        
        .score-delete-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
            flex-shrink: 0;
        }
        .score-delete-btn svg {
            width: 20px;
            height: 20px;
            fill: #ff4d4d;
        }

        footer {
            width: 100%;
            text-align: center;
            padding: 0.5rem;
            font-size: 0.8rem;
            color: var(--on-surface-secondary);
            flex-shrink: 0;
            margin-top: 0;
        }

    </style>
</head>
<body>
    <audio id="audio-player" crossorigin="anonymous" loop playsinline></audio>

    <div class="top-bar">
        <div class="stats-group">
            <div class="stat-item">
                <svg viewBox="0 0 24 24"><path d="M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10 10-4.486 10-10S17.514 2 12 2zm0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8z"></path><path d="M13 7h-2v5.414l3.293 3.293 1.414-1.414L13 11.586V7z"></path></svg>
                <span id="timer">00:00</span>
            </div>
            <div class="stat-item">
                <svg viewBox="0 0 24 24"><path d="M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6.9-4.9.9-1-2.8-2.8-.9 1c-.4-.3-1-.5-1.5-.5H14v2h.6c.2 0 .5.1.7.3l.9.9v.6h2v-1.5c0-.5-.2-1.1-.5-1.5zm-13 0c-.3.4-.5.9-.5 1.5v1.5h2V6.4l.9-.9c.2-.2.4-.3.7-.3H8V4H7.5c-.5 0-1.1.2-1.6.5l-.9-1-2.8 2.8.9 1zm12.6 9.4-.9 1c.4.3 1 .5 1.5.5H18v2h-.5c-.2 0-.5-.1-.7-.3l-.9-.9v-.6h-2v1.5c0 .5.2 1.1.5 1.5l.9 1 2.8 2.8.9-1c.3-.4.5-.9.5-1.5v-1.5h-2v.6zm-11.8 0h-2v1.5c0 .5.2 1.1.5 1.5l.9 1 2.8 2.8.9-1c.4-.3 1-.5 1.5-.5H10v-2h-.6c-.2 0-.5.1-.7-.3l-.9-.9v-.6h-2v.6z"></path></svg>
                <span id="moves">0</span>
            </div>
        </div>
        <div class="controls-group">
            <button id="pause-btn" class="control-button" data-translate-title="pauseResumeTitle">
                <svg id="pause-icon" viewBox="0 0 24 24"><path d="M8 7h3v10H8zm5 0h3v10h-3z"></path></svg>
                <svg id="play-icon" viewBox="0 0 24 24" style="display: none;"><path d="M7 6v12l10-6z"></path></svg>
            </button>
            <button id="audio-btn" class="control-button" data-translate-title="toggleSoundTitle" disabled>
                <svg id="unmute-icon" viewBox="0 0 24 24" style="display:none;"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"></path></svg>
                <svg id="mute-icon" viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"></path></svg>
            </button>
            <button id="menu-btn" class="control-button" data-translate-title="menuTitle">
                <svg viewBox="0 0 24 24"><path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"></path></svg>
            </button>
        </div>
    </div>

    <div class="main-container">
        <div class="puzzle-container" id="puzzle-container"></div>
        <div class="current-track-info" id="current-track-info"></div>

        <div class="new-game-controls">
            <input type="text" id="artist-search" data-translate-placeholder="artistSearchPlaceholder">
            <button id="new-game-btn" data-translate-key="newGame">Nuevo Juego</button>
        </div>
    </div>
    
    <div id="menu-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title" data-translate-key="highScoresTitle">Mejores Tiempos</h2>
                <button class="close-btn" id="close-menu-btn">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
                </button>
            </div>
            <div class="modal-tabs">
                <button class="tab-btn active" data-tab="records">🏆</button>
                <button class="tab-btn" data-tab="language">🏳️</button>
                <button class="tab-btn" data-tab="info">ℹ️</button>
            </div>
            <div class="modal-panels">
                <div id="records-panel" class="modal-panel active">
                    <ol id="high-scores-list"></ol>
                </div>
                <div id="language-panel" class="modal-panel">
                    <div class="language-options">
                        <button class="lang-btn" data-lang="en"><span>🇺🇸</span> <span data-translate-key="langEnglish">English</span></button>
                        <button class="lang-btn" data-lang="es"><span>🇪🇸</span> <span data-translate-key="langSpanish">Español</span></button>
                        <button class="lang-btn" data-lang="pt"><span>🇧🇷</span> <span data-translate-key="langPortuguese">Português</span></button>
                        <button class="lang-btn" data-lang="fr"><span>🇫🇷</span> <span data-translate-key="langFrench">Français</span></button>
                    </div>
                </div>
                <div id="info-panel" class="modal-panel">
                    <p data-translate-key="aboutGameText"></p>
                </div>
            </div>
        </div>
    </div>
    
    <h1>Puzzletunes</h1>
    <footer><span data-translate-key="gameBy">Juego por:</span> Ale Fernández PY-2025 - v1.54</footer>

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.0/color-thief.umd.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const SIZE = 3;
            const elements = {
                puzzleContainer: document.getElementById('puzzle-container'),
                timer: document.getElementById('timer'),
                moves: document.getElementById('moves'),
                newGameBtn: document.getElementById('new-game-btn'),
                pauseBtn: document.getElementById('pause-btn'),
                audioBtn: document.getElementById('audio-btn'),
                menuBtn: document.getElementById('menu-btn'),
                artistSearch: document.getElementById('artist-search'),
                trackInfo: document.getElementById('current-track-info'),
                audioPlayer: document.getElementById('audio-player'),
                pauseIcon: document.getElementById('pause-icon'),
                playIcon: document.getElementById('play-icon'),
                muteIcon: document.getElementById('mute-icon'),
                unmuteIcon: document.getElementById('unmute-icon'),
                menuModal: document.getElementById('menu-modal'),
                closeMenuBtn: document.getElementById('close-menu-btn'),
                modalTitle: document.getElementById('modal-title'),
                highScoresList: document.getElementById('high-scores-list'),
            };

            let state = {
                pieces: [],
                moves: 0,
                time: 0,
                timerInterval: null,
                isPaused: true,
                isMuted: true,
                currentAlbum: null,
                gameInProgress: false,
            };

            const PROXIES = [
                'https://cors.eu.org/',
                'https://cors-anywhere.poldisoft.com/',
                'https://thingproxy.freeboard.io/fetch/'
            ];
            
            // --- I18n & Translation ---
            const translations = {
                es: {
                    pageTitle: "Puzzletunes",
                    pauseResumeTitle: "Pausar/Reanudar",
                    toggleSoundTitle: "Activar/Desactivar Sonido",
                    menuTitle: "Menú",
                    highScoresTitle: "Mejores Tiempos",
                    languageTitle: "Idioma",
                    aboutTitle: "Acerca de",
                    artistSearchPlaceholder: "Buscar por artista (opcional)",
                    newGame: "Nuevo Juego",
                    gameBy: "Juego por:",
                    winMessage: "¡Ganaste!<br>{time}",
                    paused: "Pausado",
                    startMessage: "Haz clic en 'Nuevo Juego' para empezar",
                    searchingMusic: "Buscando música...",
                    searchingMusicFor: "Buscando música de {searchTerm}...",
                    didYouMean: "Quisiste decir:",
                    imageError: "Error al cargar la imagen. Por favor, intenta de nuevo.",
                    noMusicFoundFor: "No se encontró música para \"{searchTerm}\"",
                    noRandomMusic: "No se encontró música aleatoria. Por favor, intenta de nuevo.",
                    loadSavedImageError: "Error al cargar la imagen guardada.",
                    newGameConfirm: "¿Seguro que quieres empezar un nuevo juego? Tu progreso se perderá.",
                    deleteRecordTitle: "Eliminar récord",
                    movesSuffix: "mov.",
                    langEnglish: "Inglés",
                    langSpanish: "Español",
                    langPortuguese: "Portugués",
                    langFrench: "Francés",
                    aboutGameText: "En un mundo de gratificación instantánea, Puzzletunes ofrece un respiro. Resolver este puzzle no solo pone a prueba tu ingenio, sino que también entrena tu paciencia y concentración. Cada pieza que mueves es un paso para calmar tu mente y fortalecer tu enfoque. Disfruta de la música, del desafío y del momento de calma que este juego te regala. Tómate tu tiempo, el viaje es tan importante como la victoria final."
                },
                en: {
                    pageTitle: "Puzzletunes",
                    pauseResumeTitle: "Pause/Resume",
                    toggleSoundTitle: "Toggle Sound",
                    menuTitle: "Menu",
                    highScoresTitle: "High Scores",
                    languageTitle: "Language",
                    aboutTitle: "About",
                    artistSearchPlaceholder: "Search by artist (optional)",
                    newGame: "New Game",
                    gameBy: "Game by:",
                    winMessage: "You Win!<br>{time}",
                    paused: "Paused",
                    startMessage: "Click 'New Game' to start",
                    searchingMusic: "Searching for music...",
                    searchingMusicFor: "Searching for music by {searchTerm}...",
                    didYouMean: "Did you mean:",
                    imageError: "Error loading image. Please try again.",
                    noMusicFoundFor: "No music found for \"{searchTerm}\"",
                    noRandomMusic: "No random music found. Please try again.",
                    loadSavedImageError: "Error loading saved image.",
                    newGameConfirm: "Are you sure you want to start a new game? Your progress will be lost.",
                    deleteRecordTitle: "Delete record",
                    movesSuffix: "moves",
                    langEnglish: "English",
                    langSpanish: "Spanish",
                    langPortuguese: "Portuguese",
                    langFrench: "French",
                    aboutGameText: "In a world of instant gratification, Puzzletunes offers a respite. Solving this puzzle not only tests your wits but also trains your patience and concentration. Every piece you move is a step towards calming your mind and strengthening your focus. Enjoy the music, the challenge, and the moment of calm this game gives you. Take your time; the journey is as important as the final victory."
                },
                pt: {
                    pageTitle: "Puzzletunes",
                    pauseResumeTitle: "Pausar/Retomar",
                    toggleSoundTitle: "Ativar/Desativar Som",
                    menuTitle: "Menu",
                    highScoresTitle: "Melhores Tempos",
                    languageTitle: "Idioma",
                    aboutTitle: "Sobre",
                    artistSearchPlaceholder: "Pesquisar por artista (opcional)",
                    newGame: "Novo Jogo",
                    gameBy: "Jogo por:",
                    winMessage: "Você Venceu!<br>{time}",
                    paused: "Pausado",
                    startMessage: "Clique em 'Novo Jogo' para começar",
                    searchingMusic: "Procurando música...",
                    searchingMusicFor: "Procurando música de {searchTerm}...",
                    didYouMean: "Você quis dizer:",
                    imageError: "Erro ao carregar a imagem. Por favor, tente novamente.",
                    noMusicFoundFor: "Nenhuma música encontrada para \"{searchTerm}\"",
                    noRandomMusic: "Nenhuma música aleatória encontrada. Por favor, tente novamente.",
                    loadSavedImageError: "Erro ao carregar a imagem salva.",
                    newGameConfirm: "Tem certeza que deseja iniciar um novo jogo? Seu progresso será perdido.",
                    deleteRecordTitle: "Excluir recorde",
                    movesSuffix: "mov.",
                    langEnglish: "Inglês",
                    langSpanish: "Espanhol",
                    langPortuguese: "Português",
                    langFrench: "Francês",
                    aboutGameText: "Em um mundo de gratificação instantânea, Puzzletunes oferece um respiro. Resolver este quebra-cabeça não apenas testa sua inteligência, mas também treina sua paciência e concentração. Cada peça que você move é um passo para acalmar sua mente e fortalecer seu foco. Aproveite a música, o desafio e o momento de calma que este jogo lhe proporciona. Leve o seu tempo; a jornada é tão importante quanto a vitória final."
                },
                fr: {
                    pageTitle: "Puzzletunes",
                    pauseResumeTitle: "Pause/Reprendre",
                    toggleSoundTitle: "Activer/Désactiver le son",
                    menuTitle: "Menu",
                    highScoresTitle: "Meilleurs Scores",
                    languageTitle: "Langue",
                    aboutTitle: "À propos",
                    artistSearchPlaceholder: "Rechercher par artiste (optionnel)",
                    newGame: "Nouveau Jeu",
                    gameBy: "Jeu par :",
                    winMessage: "Vous avez gagné !<br>{time}",
                    paused: "En pause",
                    startMessage: "Cliquez sur 'Nouveau Jeu' pour commencer",
                    searchingMusic: "Recherche de musique...",
                    searchingMusicFor: "Recherche de musique de {searchTerm}...",
                    didYouMean: "Vouliez-vous dire :",
                    imageError: "Erreur de chargement de l'image. Veuillez réessayer.",
                    noMusicFoundFor: "Aucune musique trouvée pour \"{searchTerm}\"",
                    noRandomMusic: "Aucune musique aléatoire trouvée. Veuillez réessayer.",
                    loadSavedImageError: "Erreur de chargement de l'image sauvegardée.",
                    newGameConfirm: "Êtes-vous sûr de vouloir commencer une nouvelle partie ? Votre progression sera perdue.",
                    deleteRecordTitle: "Supprimer le record",
                    movesSuffix: "mouv.",
                    langEnglish: "Anglais",
                    langSpanish: "Espagnol",
                    langPortuguese: "Portugais",
                    langFrench: "Français",
                    aboutGameText: "Dans un monde de gratification instantanée, Puzzletunes offre un répit. Résoudre ce puzzle ne teste pas seulement votre intelligence, mais entraîne également votre patience et votre concentration. Chaque pièce que vous déplacez est un pas vers l'apaisement de votre esprit et le renforcement de votre concentration. Profitez de la musique, du défi et du moment de calme que ce jeu vous offre. Prenez votre temps ; le voyage est aussi important que la victoire finale."
                }
            };

            let currentStrings = { ...translations.es };

            function getTranslatedString(key, replacements = {}) {
                // Fallback chain: current language -> Spanish (base) -> key name
                let str = currentStrings[key] || translations.es[key] || key;
                for (const placeholder in replacements) {
                    str = str.replace(`{${placeholder}}`, replacements[placeholder]);
                }
                return str;
            }

            function applyTranslations() {
                const lang = localStorage.getItem('puzzletunesLanguage') || 'es';
                currentStrings = translations[lang];

                document.documentElement.lang = lang;
                document.title = currentStrings.pageTitle;
                
                document.querySelectorAll('[data-translate-key]').forEach(el => {
                    const key = el.dataset.translateKey;
                    if (currentStrings[key]) {
                        el.innerHTML = currentStrings[key];
                    }
                });
                document.querySelectorAll('[data-translate-placeholder]').forEach(el => {
                    const key = el.dataset.translatePlaceholder;
                    if (currentStrings[key]) el.placeholder = currentStrings[key];
                });
                document.querySelectorAll('[data-translate-title]').forEach(el => {
                    const key = el.dataset.translateTitle;
                    if (currentStrings[key]) el.title = currentStrings[key];
                });
                // Special case for footer to preserve structure
                const gameBySpan = document.querySelector('footer > span');
                if (gameBySpan) gameBySpan.textContent = currentStrings.gameBy;
            }
            
            function setLanguage(lang) {
                if (!translations[lang]) lang = 'en'; // Default to English if lang is invalid
                localStorage.setItem('puzzletunesLanguage', lang);
                applyTranslations();
                updateActiveLanguageButton(lang);
                // Also update high scores list if it's open
                if (elements.menuModal.classList.contains('visible')) {
                    renderHighScores();
                }
            }
            
            function updateActiveLanguageButton(lang) {
                document.querySelectorAll('.lang-btn').forEach(btn => {
                    if (btn.dataset.lang === lang) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
            }

            function initializeLocalization() {
                const savedLang = localStorage.getItem('puzzletunesLanguage');
                if (savedLang) {
                    setLanguage(savedLang);
                    return;
                }
                
                const browserLang = (navigator.language || navigator.userLanguage || 'en').slice(0, 2);
                const supportedLangs = ['es', 'en', 'pt', 'fr'];
                const initialLang = supportedLangs.includes(browserLang) ? browserLang : 'en';
                setLanguage(initialLang);
            }
            // --- End I18n ---

            async function fetchWithProxyFallback(url) {
                let lastError = null;
                for (const proxy of PROXIES) {
                    try {
                        const response = await fetch(`${proxy}${url}`);
                        if (response.ok) return response;
                        lastError = new Error(`Proxy ${proxy} returned status ${response.status}`);
                    } catch (error) {
                        lastError = error;
                        console.warn(`Proxy ${proxy} failed:`, error);
                    }
                }
                throw lastError || new Error('All CORS proxies failed to fetch.');
            }
            
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
                const secs = (seconds % 60).toString().padStart(2, '0');
                return `${mins}:${secs}`;
            }

            function updateBackground(imageUrl) {
                document.body.style.setProperty('--bg-image', `url('${imageUrl}')`);
                document.body.style.setProperty('--bg-opacity', '1');
            }

            function clearBackground() {
                document.body.style.setProperty('--bg-opacity', '0');
            }

            function updateUI() {
                elements.timer.textContent = formatTime(state.time);
                elements.moves.textContent = state.moves;
                elements.pauseIcon.style.display = state.isPaused ? 'none' : 'block';
                elements.playIcon.style.display = state.isPaused ? 'block' : 'none';
                elements.muteIcon.style.display = state.isMuted ? 'block' : 'none';
                elements.unmuteIcon.style.display = state.isMuted ? 'none' : 'block';
                elements.pauseBtn.disabled = !state.gameInProgress;
            }
            
            function saveGameState() {
                if (!state.currentAlbum) return;
                const gameState = {
                    pieces: state.pieces.map(p => ({ originalIndex: p.originalIndex, currentIndex: p.currentIndex })),
                    moves: state.moves,
                    time: state.time,
                    isPaused: state.isPaused,
                    isMuted: state.isMuted,
                    album: state.currentAlbum,
                    gameInProgress: state.gameInProgress,
                };
                localStorage.setItem('puzzletunesGameState', JSON.stringify(gameState));
            }

            function loadGameState() {
                const saved = localStorage.getItem('puzzletunesGameState');
                if (saved) {
                    const savedState = JSON.parse(saved);
                    state.moves = savedState.moves;
                    state.time = savedState.time;
                    state.isMuted = savedState.isMuted;
                    state.currentAlbum = savedState.album;
                    state.gameInProgress = savedState.gameInProgress;
                    state.isPaused = true;
                    
                    const pieceMap = new Map(savedState.pieces.map(p => [p.currentIndex, p.originalIndex]));
                    state.pieces = Array.from({ length: SIZE * SIZE }, (_, i) => {
                        const originalIndex = pieceMap.get(i);
                        return {
                           el: null,
                           originalIndex: originalIndex,
                           currentIndex: i,
                           isEmpty: originalIndex === SIZE * SIZE - 1
                        };
                    });
                    return true;
                }
                return false;
            }
            
            function clearGameState() {
                localStorage.removeItem('puzzletunesGameState');
            }

            function renderBoard() {
                elements.puzzleContainer.innerHTML = '';
                if (!state.currentAlbum) return;
                const imageUrl = state.currentAlbum.artworkUrl.replace('100x100', '600x600');

                for (let i = 0; i < SIZE * SIZE; i++) {
                    const pieceData = state.pieces.find(p => p.currentIndex === i);
                    if(!pieceData) continue;

                    const pieceEl = document.createElement('div');
                    pieceEl.classList.add('puzzle-piece');
                    
                    if (pieceData.isEmpty) {
                        pieceEl.classList.add('empty');
                    } else {
                        const row = Math.floor(pieceData.originalIndex / SIZE);
                        const col = pieceData.originalIndex % SIZE;
                        pieceEl.style.backgroundImage = `url(${imageUrl})`;
                        pieceEl.style.backgroundPosition = `${(col * 100) / (SIZE - 1)}% ${(row * 100) / (SIZE - 1)}%`;
                    }
                    
                    pieceEl.dataset.index = i;
                    pieceEl.addEventListener('click', () => onPieceClick(i));
                    pieceData.el = pieceEl;
                    elements.puzzleContainer.appendChild(pieceEl);
                }
            }
            
            function onPieceClick(clickedIndex) {
                if (state.isPaused) return;

                const emptyPiece = state.pieces.find(p => p.isEmpty);
                const clickedPiece = state.pieces.find(p => p.currentIndex === clickedIndex);
                if (!clickedPiece || clickedPiece.isEmpty) return;

                const emptyIndex = emptyPiece.currentIndex;
                const { row: emptyRow, col: emptyCol } = getRowCol(emptyIndex);
                const { row: clickedRow, col: clickedCol } = getRowCol(clickedIndex);

                const isAdjacent = (Math.abs(emptyRow - clickedRow) === 1 && emptyCol === clickedCol) ||
                                   (Math.abs(emptyCol - clickedCol) === 1 && emptyRow === clickedRow);

                if (isAdjacent) {
                    swapPieces(clickedPiece, emptyPiece);
                    state.moves++;

                    if (state.moves === 1 && state.isMuted) {
                        state.isMuted = false;
                        elements.audioPlayer.muted = false;

                        if (elements.audioPlayer.paused) {
                            elements.audioPlayer.play().catch(e => {
                                console.error("Error playing audio on first move:", e);
                                state.isMuted = true;
                                elements.audioPlayer.muted = true;
                            });
                        }
                    }

                    updateUI();
                    if (checkWin()) {
                        handleWin();
                    }
                    saveGameState();
                }
            }

            function swapPieces(piece1, piece2) {
                const tempIndex = piece1.currentIndex;
                piece1.currentIndex = piece2.currentIndex;
                piece2.currentIndex = tempIndex;
                renderBoard();
            }

            function getRowCol(index) {
                return { row: Math.floor(index / SIZE), col: index % SIZE };
            }

            function checkWin() {
                return state.pieces.every(p => p.currentIndex === p.originalIndex);
            }
            
            function triggerWinCelebration() {
                const rootStyles = getComputedStyle(document.documentElement);
                const paletteColors = [
                    rootStyles.getPropertyValue('--gradient-color-1').trim(),
                    rootStyles.getPropertyValue('--gradient-color-2').trim(),
                    rootStyles.getPropertyValue('--gradient-color-3').trim(),
                    rootStyles.getPropertyValue('--gradient-color-4').trim(),
                    rootStyles.getPropertyValue('--gradient-color-5').trim()
                ].filter(Boolean);

                const colors = paletteColors.length > 0 ? paletteColors : ['#1DB954', '#FFFFFF', '#1ED760'];

                const defaults = {
                    origin: { x: 0.5, y: 0.5 },
                    shapes: ['♪', '♫', '♬'],
                    colors: colors,
                    disableForReducedMotion: true,
                    gravity: 0.5,
                    scalar: 2.5,
                };

                const fire = (particleCount, options) => confetti({ ...defaults, ...options, particleCount: Math.floor(particleCount) });
                
                fire(200, { spread: 180, startVelocity: 55, decay: 0.9 });
                fire(150, { spread: 120, startVelocity: 45, decay: 0.91, scalar: 2 });
                fire(250, { spread: 360, startVelocity: 30, decay: 0.92, scalar: 1.5 });
            }

            function handleWin() {
                stopTimer();
                elements.puzzleContainer.classList.remove('animated-gradient-border');
                
                triggerWinCelebration();

                state.isPaused = true;
                state.gameInProgress = false;
                setTimeout(() => {
                    const winMsgDiv = document.createElement('div');
                    winMsgDiv.innerHTML = getTranslatedString('winMessage', {time: formatTime(state.time)});
                    showOverlay(winMsgDiv.innerHTML);
                }, 500);
                saveScore();
                clearGameState();
                elements.audioPlayer.pause();
                updateUI();
            }

            function getHighScores() {
                try {
                    const storedScores = localStorage.getItem('puzzletunesHighScores');
                    if (!storedScores) return [];
                    const parsedScores = JSON.parse(storedScores);
                    if (Array.isArray(parsedScores)) {
                        return parsedScores.filter(s => s && typeof s.time === 'number' && s.album);
                    }
                } catch (e) {
                    console.error("Could not parse high scores, returning empty list.", e);
                }
                return [];
            }

            function saveScore() {
                if (!state.currentAlbum) return;
                
                // 1. Get current scores and add the new one
                let highScores = getHighScores();
                const newScore = { 
                    time: state.time, 
                    moves: state.moves, 
                    album: { ...state.currentAlbum }, 
                    id: Date.now() 
                };
                highScores.push(newScore);

                // 2. Sort by best time, then by fewest moves
                highScores.sort((a, b) => {
                    if (a.time !== b.time) {
                        return a.time - b.time;
                    }
                    return a.moves - b.moves;
                });

                // 3. Keep only the top 10 scores
                const top10Scores = highScores.slice(0, 10);
                
                localStorage.setItem('puzzletunesHighScores', JSON.stringify(top10Scores));
            }

            function renderHighScores() {
                const highScores = getHighScores();
                elements.highScoresList.innerHTML = highScores.map((item, index) => {
                    const wrapperId = `marquee-wrapper-${item.id}`;
                    const html = `
                        <li class="score-item">
                            <span class="score-rank">${index + 1}</span>
                            <img src="${item.album.artworkUrl}" class="score-thumbnail" alt="Artwork for ${item.album.collectionName}">
                            <div class="score-info">
                                <p class="score-artist">${item.album.artistName}</p>
                                <div class="marquee-wrapper" id="${wrapperId}">
                                    <p class="score-track marquee-content">${item.album.collectionName}</p>
                                </div>
                                <div class="score-stats">
                                    <span>${formatTime(item.time)}</span>
                                    <span>${item.moves} ${getTranslatedString('movesSuffix')}</span>
                                </div>
                            </div>
                            <button class="score-delete-btn" data-id="${item.id}" title="${getTranslatedString('deleteRecordTitle')}">
                                <svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></svg>
                            </button>
                        </li>`;
                    
                    setTimeout(() => {
                        const wrapper = document.getElementById(wrapperId);
                        const content = wrapper?.querySelector('.marquee-content');
                        if (wrapper && content && content.scrollWidth > wrapper.clientWidth) {
                            wrapper.classList.add('animate');
                        }
                    }, 0);
                    return html;
                }).join('');
            }
            
            function deleteScore(id) {
                let highScores = getHighScores().filter(score => score.id !== id);
                localStorage.setItem('puzzletunesHighScores', JSON.stringify(highScores));
                renderHighScores();
            }

            function showOverlay(htmlContent, suggestions = []) {
                hideOverlay();
                const overlay = document.createElement('div');
                overlay.className = 'overlay';
                overlay.innerHTML = `<div>${htmlContent}</div>`;
                
                if (suggestions.length > 0) {
                    const suggestionsContainer = document.createElement('div');
                    suggestionsContainer.className = 'suggestions-container';
                    suggestions.forEach(suggestion => {
                        const btn = document.createElement('button');
                        btn.className = 'suggestion-btn';
                        btn.textContent = suggestion;
                        btn.onclick = () => {
                            elements.artistSearch.value = suggestion;
                            prepareNewGame(true);
                        };
                        suggestionsContainer.appendChild(btn);
                    });
                    overlay.appendChild(suggestionsContainer);
                }
                elements.puzzleContainer.appendChild(overlay);
            }

            function hideOverlay() {
                const overlay = elements.puzzleContainer.querySelector('.overlay');
                if (overlay) overlay.remove();
            }
            
            async function findAlbumWithMusic(searchTerm, isArtistSearch = false) {
                const genres = ['rock', 'pop', 'jazz', 'classical', 'electronic', 'hiphop', 'reggae', 'metal', 'soul', 'funk'];
                const MAX_ATTEMPTS = 5;

                const searchAndProcess = async (url) => {
                    try {
                        const response = await fetchWithProxyFallback(url);
                        const data = await response.json();
                        const songsWithPreview = data.results.filter(song => song.previewUrl && song.artworkUrl100);
                        if (songsWithPreview.length === 0) return null;

                        const albums = songsWithPreview.reduce((acc, song) => {
                            if (!acc[song.collectionId]) {
                                acc[song.collectionId] = {
                                    artistName: song.artistName,
                                    collectionName: song.collectionName,
                                    artworkUrl: song.artworkUrl100,
                                    previewUrl: song.previewUrl
                                };
                            }
                            return acc;
                        }, {});

                        const albumArray = Object.values(albums);
                        return albumArray.length > 0 ? albumArray[Math.floor(Math.random() * albumArray.length)] : null;
                    } catch (error) {
                        console.error('Error in searchAndProcess:', error);
                        return null;
                    }
                };

                if (isArtistSearch) {
                    const searchUrl = `https://itunes.apple.com/search?term=${encodeURIComponent(searchTerm)}&entity=song&limit=200&attribute=artistTerm`;
                    return await searchAndProcess(searchUrl);
                }
                for (let i = 0; i < MAX_ATTEMPTS; i++) {
                    const genre = genres[Math.floor(Math.random() * genres.length)];
                    const searchUrl = `https://itunes.apple.com/search?term=${encodeURIComponent(genre)}&entity=song&limit=200`;
                    const result = await searchAndProcess(searchUrl);
                    if (result) return result;
                    console.warn(`Random search attempt ${i + 1} failed. Retrying...`);
                }
                return null;
            }
            
            const calculateLevenshteinDistance = (a, b) => {
                const matrix = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(null));
                for (let i = 0; i <= a.length; i++) { matrix[0][i] = i; }
                for (let j = 0; j <= b.length; j++) { matrix[j][0] = j; }
                for (let j = 1; j <= b.length; j++) {
                    for (let i = 1; i <= a.length; i++) {
                        const cost = a[i - 1] === b[j - 1] ? 0 : 1;
                        matrix[j][i] = Math.min(matrix[j][i - 1] + 1, matrix[j - 1][i] + 1, matrix[j - 1][i - 1] + cost);
                    }
                }
                return matrix[b.length][a.length];
            };
            
            async function findSuggestions(searchTerm) {
                try {
                    const response = await fetchWithProxyFallback(`https://itunes.apple.com/search?term=${encodeURIComponent(searchTerm)}&entity=song&limit=50`);
                    const data = await response.json();
                    return [...new Set(data.results.map(r => r.artistName))]
                        .map(name => ({ name, distance: calculateLevenshteinDistance(searchTerm.toLowerCase(), name.toLowerCase()) }))
                        .filter(item => item.distance < 4)
                        .sort((a, b) => a.distance - b.distance)
                        .map(item => item.name)
                        .slice(0, 3);
                } catch (error) {
                    console.error('Error finding suggestions:', error);
                    return [];
                }
            }

            async function prepareNewGame(isFromSuggestion = false) {
                stopTimer();
                elements.puzzleContainer.classList.remove('animated-gradient-border');
                hideOverlay();
                
                const searchTerm = elements.artistSearch.value.trim();
                const isArtistSearch = searchTerm.length > 0;
                
                const overlayMessage = isArtistSearch 
                    ? getTranslatedString('searchingMusicFor', { searchTerm }) 
                    : getTranslatedString('searchingMusic');
                showOverlay(overlayMessage);

                let album = await findAlbumWithMusic(searchTerm, isArtistSearch);
                
                if (!album && isArtistSearch && !isFromSuggestion) {
                    const suggestions = await findSuggestions(searchTerm);
                    if (suggestions.length > 0) {
                        showOverlay(getTranslatedString('didYouMean'), suggestions);
                        return;
                    }
                }

                if (album) {
                    state.currentAlbum = album;
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.src = state.currentAlbum.artworkUrl.replace('100x100', '600x600');
                    img.onload = () => {
                        const palette = new ColorThief().getPalette(img, 5);
                        palette.forEach((c, i) => document.documentElement.style.setProperty(`--gradient-color-${i + 1}`, `rgb(${c[0]}, ${c[1]}, ${c[2]})`));
                        updateBackground(img.src);
                        hideOverlay();
                        resetGame();
                        startNewGame();
                    };
                    img.onerror = () => showOverlay(getTranslatedString('imageError'));
                } else {
                    const message = isArtistSearch ? getTranslatedString('noMusicFoundFor', {searchTerm}) : getTranslatedString('noRandomMusic');
                    showOverlay(message);
                }
            }

            function resetGame() {
                state.time = 0;
                state.moves = 0;
                state.isPaused = false;
                state.isMuted = true;
                state.gameInProgress = true;
                
                const indices = Array.from({ length: SIZE * SIZE }, (_, i) => i);
                let shuffled;
                let attempts = 0;
                const MAX_ATTEMPTS = 100;

                do {
                    shuffled = [...indices].sort(() => Math.random() - 0.5);
                    const hasPiecesInPlace = shuffled.some((value, index) => value === index && index < SIZE * SIZE - 1);
                    if (isSolvable(shuffled) && !hasPiecesInPlace) {
                        break; 
                    }
                    attempts++;
                } while (attempts < MAX_ATTEMPTS);
                
                if (attempts >= MAX_ATTEMPTS) {
                    console.warn("Could not generate a perfectly shuffled puzzle in time. Using a standard solvable shuffle.");
                    do {
                        shuffled = [...indices].sort(() => Math.random() - 0.5);
                    } while (!isSolvable(shuffled));
                }

                state.pieces = Array.from({ length: SIZE * SIZE }, (_, i) => ({
                    el: null,
                    originalIndex: i,
                    currentIndex: shuffled.indexOf(i),
                    isEmpty: i === SIZE * SIZE - 1
                }));
            }
            
            const isSolvable = (shuffled) => {
                let inversions = 0;
                const puzzle = shuffled.filter(i => i !== SIZE * SIZE - 1);
                for (let i = 0; i < puzzle.length - 1; i++) {
                    for (let j = i + 1; j < puzzle.length; j++) {
                        if (puzzle[i] > puzzle[j]) inversions++;
                    }
                }
                return inversions % 2 === 0;
            };

            function startNewGame() {
                renderBoard();
                startTimer();
                elements.puzzleContainer.classList.add('animated-gradient-border');
                elements.trackInfo.innerHTML = `<h2>${state.currentAlbum.collectionName}</h2><p>${state.currentAlbum.artistName}</p>`;
                elements.audioPlayer.src = state.currentAlbum.previewUrl;
                elements.audioBtn.disabled = true;
                state.isMuted = true;
                elements.audioPlayer.muted = true;
                updateUI();
                saveGameState();
            }

            function initGame() {
                if (loadGameState() && state.gameInProgress) {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.src = state.currentAlbum.artworkUrl.replace('100x100', '600x600');
                    img.onload = () => {
                        const palette = new ColorThief().getPalette(img, 5);
                        palette.forEach((c, i) => document.documentElement.style.setProperty(`--gradient-color-${i + 1}`, `rgb(${c[0]}, ${c[1]}, ${c[2]})`));
                        updateBackground(img.src);
                        
                        renderBoard();
                        startTimer();
                        updateUI();
                        showOverlay(getTranslatedString('paused'));
                        elements.trackInfo.innerHTML = `<h2>${state.currentAlbum.collectionName}</h2><p>${state.currentAlbum.artistName}</p>`;
                        if (state.currentAlbum.previewUrl) {
                            elements.audioPlayer.src = state.currentAlbum.previewUrl;
                        }
                    };
                     img.onerror = () => showOverlay(getTranslatedString('loadSavedImageError'));
                } else {
                    clearGameState();
                    clearBackground();
                    state.gameInProgress = false;
                    state.isPaused = true;
                    elements.puzzleContainer.innerHTML = '';
                    showOverlay(getTranslatedString('startMessage'));
                    elements.trackInfo.innerHTML = '';
                    updateUI();
                }
                renderHighScores();
            }
            
            function startTimer() {
                if (state.timerInterval) clearInterval(state.timerInterval);
                state.timerInterval = setInterval(() => {
                    if (!state.isPaused) {
                        state.time++;
                        elements.timer.textContent = formatTime(state.time);
                    }
                }, 1000);
            }

            function stopTimer() {
                clearInterval(state.timerInterval);
                state.timerInterval = null;
            }

            // --- Modal & Tabs Logic ---
            function switchTab(tabName) {
                const modal = elements.menuModal;
                modal.querySelectorAll('.tab-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.tab === tabName));
                modal.querySelectorAll('.modal-panel').forEach(panel => panel.classList.toggle('active', panel.id === `${tabName}-panel`));
                
                let titleKey;
                if(tabName === 'records') titleKey = 'highScoresTitle';
                else if (tabName === 'language') titleKey = 'languageTitle';
                else if (tabName === 'info') titleKey = 'aboutTitle';
                elements.modalTitle.textContent = getTranslatedString(titleKey);
                elements.modalTitle.dataset.translateKey = titleKey;
            }

            elements.menuModal.addEventListener('click', (e) => {
                const tabBtn = e.target.closest('.tab-btn');
                if (tabBtn) {
                    switchTab(tabBtn.dataset.tab);
                }
                const langBtn = e.target.closest('.lang-btn');
                if(langBtn) {
                    setLanguage(langBtn.dataset.lang);
                }
            });


            elements.newGameBtn.addEventListener('click', () => {
                if (state.gameInProgress && !confirm(getTranslatedString('newGameConfirm'))) {
                    return;
                }
                clearGameState();
                elements.audioPlayer.pause();
                elements.audioPlayer.src = '';
                state.currentAlbum = null;
                prepareNewGame();
            });

            elements.pauseBtn.addEventListener('click', () => {
                if (!state.gameInProgress) return;
                state.isPaused = !state.isPaused;
                if (state.isPaused) {
                    stopTimer();
                    showOverlay(getTranslatedString('paused'));
                    elements.puzzleContainer.classList.remove('animated-gradient-border');
                } else {
                    hideOverlay();
                    startTimer();
                    elements.puzzleContainer.classList.add('animated-gradient-border');
                    if (!state.isMuted && elements.audioPlayer.src) {
                        elements.audioPlayer.play().catch(e => console.error("Error on resume:", e));
                    }
                }
                updateUI();
                saveGameState();
            });

            elements.audioBtn.addEventListener('click', () => {
                state.isMuted = !state.isMuted;
                elements.audioPlayer.muted = state.isMuted;
                if (elements.audioPlayer.paused && !state.isMuted) {
                    elements.audioPlayer.play().catch(e => {
                        console.error("Error on unmute:", e);
                        state.isMuted = true;
                        elements.audioPlayer.muted = true;
                    });
                }
                updateUI();
                if (state.gameInProgress) saveGameState();
            });

            elements.audioPlayer.addEventListener('canplaythrough', () => elements.audioBtn.disabled = false);
            
            elements.menuBtn.addEventListener('click', () => {
                renderHighScores();
                switchTab('records'); // Default to records tab
                elements.menuModal.classList.add('visible');
            });
            elements.closeMenuBtn.addEventListener('click', () => elements.menuModal.classList.remove('visible'));

            elements.highScoresList.addEventListener('click', (e) => {
                const deleteBtn = e.target.closest('.score-delete-btn');
                if (deleteBtn) {
                    deleteScore(parseInt(deleteBtn.dataset.id, 10));
                }
            });
            window.addEventListener('beforeunload', () => state.gameInProgress && saveGameState());
            
            initializeLocalization();
            initGame();
        });
    </script>
</body>
</html>
