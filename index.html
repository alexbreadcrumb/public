
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle Deslizante Musical</title>
    <style>
        :root {
            --bg: #1a1a1a;
            --surface: #2a2a2a;
            --primary: #facc15;
            --text: #e5e7eb;
            --text-secondary: #9ca3af;
            --font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        body {
            font-family: var(--font-family);
            background-color: var(--bg);
            color: var(--text);
            display: flex;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px 10px 70px 10px; /* Increased bottom padding for footer */
            box-sizing: border-box;
        }
        #app-container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            align-items: center;
            width: 100%;
            max-width: 480px; /* Slightly wider for better spacing */
        }
        .panel {
            background-color: var(--surface);
            border-radius: 12px; /* Softer corners */
            padding: 1.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            width: 100%;
            box-sizing: border-box;
        }
        #game-board {
            display: grid;
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            background-color: #111;
            align-items: center;
            justify-content: center;
            margin-bottom: 1.5rem; /* More space */
            color: var(--text-secondary);
            text-align: center;
        }
        .piece {
            transition: transform 0.2s ease-in-out;
            cursor: pointer;
        }
        .piece.empty {
            background-image: none !important;
            cursor: default;
        }
        #controls, #stats {
            display: flex;
            gap: 1rem;
            width: 100%;
        }
        #stats { margin-bottom: 1rem; }
        #stats > div {
            flex-grow: 1;
            text-align: center;
        }
        #stats .label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            text-transform: uppercase; /* Added for style */
        }
        #stats .value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--primary);
        }
        button {
            flex-grow: 1;
            padding: 0.85rem 1rem; /* Slightly larger buttons */
            border: none;
            border-radius: 8px;
            background-color: var(--primary);
            color: var(--bg);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover { background-color: #eab308; }
        button#pause-btn.paused { background-color: #22c55e; }
        h2 { margin-top: 0; color: var(--primary); text-align: center; }
        #high-scores-list { list-style: none; padding: 0; margin: 0; }
        #high-scores-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0.25rem;
            border-bottom: 1px solid #3a3a3a;
        }
        #high-scores-list li:last-child { border: none; }
        #victory-modal {
            position: fixed;
            inset: 0;
            background-color: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
            padding: 20px;
        }
        #victory-modal.show { display: flex; }
        .modal-content {
            text-align: center;
            animation: fade-in 0.3s ease-out;
        }
        @keyframes fade-in {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        footer {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 1rem;
            background-color: #111;
            color: var(--text-secondary);
            text-align: center;
            font-size: 0.8rem;
            z-index: 50;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <main id="app-container">
        <section class="panel">
            <div id="game-board">Cargando...</div>
            <div id="stats">
                <div>
                    <div class="label">TIEMPO</div>
                    <div id="time" class="value">00:00</div>
                </div>
                <div>
                    <div class="label">MOVIMIENTOS</div>
                    <div id="moves" class="value">0</div>
                </div>
            </div>
            <div id="controls">
                <button id="new-game-3">Nuevo 3x3</button>
                <button id="new-game-4">Nuevo 4x4</button>
                <button id="pause-btn">Pausar</button>
            </div>
        </section>
        <section id="high-scores-container" class="panel">
            <h2>Mejores Tiempos</h2>
            <ol id="high-scores-list"></ol>
        </section>
    </main>

    <div id="victory-modal">
        <div class="modal-content panel">
            <h2 style="font-size: 2.5rem;">¡Victoria!</h2>
            <p>Completaste el puzzle en <strong id="final-time"></strong> con <strong id="final-moves"></strong> movimientos.</p>
            <button id="play-again-btn" style="width: 100%; margin-top: 1rem;">Jugar de Nuevo</button>
        </div>
    </div>

    <footer>Game By: Ale Fernández 2025 - PY</footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const boardEl = document.getElementById('game-board');
            const timeEl = document.getElementById('time');
            const movesEl = document.getElementById('moves');
            const pauseBtn = document.getElementById('pause-btn');
            const scoresListEl = document.getElementById('high-scores-list');
            const victoryModalEl = document.getElementById('victory-modal');

            let state = {
                gridSize: 3,
                pieces: [],
                imageUrl: '',
                moves: 0,
                time: 0,
                isPaused: false,
                isSolved: false
            };
            let timerInterval = null;

            const formatTime = (totalSeconds) => {
                const min = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
                const sec = (totalSeconds % 60).toString().padStart(2, '0');
                return `${min}:${sec}`;
            };

            const saveState = () => localStorage.setItem('puzzleGameState', JSON.stringify(state));
            const loadState = () => JSON.parse(localStorage.getItem('puzzleGameState'));
            const saveScores = (scores) => localStorage.setItem('puzzleHighScores', JSON.stringify(scores));
            const loadScores = () => JSON.parse(localStorage.getItem('puzzleHighScores')) || [];

            const renderBoard = () => {
                if (!state.imageUrl) {
                    boardEl.innerHTML = 'Error: No se encontró imagen.';
                    return;
                }
                boardEl.innerHTML = '';
                boardEl.style.gridTemplateColumns = `repeat(${state.gridSize}, 1fr)`;
                
                const boardSize = boardEl.clientWidth; // Use clientWidth for more reliable measurement
                const pieceSize = boardSize / state.gridSize;

                state.pieces.forEach((piece) => {
                    const pieceEl = document.createElement('div');
                    const currentIndex = state.pieces.indexOf(piece);
                    
                    pieceEl.classList.add('piece');
                    if (piece.isEmpty) pieceEl.classList.add('empty');
                    
                    const correctX = piece.correctPosition % state.gridSize;
                    const correctY = Math.floor(piece.correctPosition / state.gridSize);
                    
                    pieceEl.style.width = `${pieceSize}px`;
                    pieceEl.style.height = `${pieceSize}px`;
                    pieceEl.style.backgroundImage = `url(${state.imageUrl})`;
                    pieceEl.style.backgroundSize = `${boardSize}px ${boardSize}px`;
                    pieceEl.style.backgroundPosition = `-${correctX * pieceSize}px -${correctY * pieceSize}px`;
                    
                    // The position in the grid is determined by order, but we can set a data-attribute for click handling
                    pieceEl.dataset.index = currentIndex;
                    
                    boardEl.appendChild(pieceEl);
                });
                movesEl.textContent = state.moves;
                timeEl.textContent = formatTime(state.time);
            };
            window.addEventListener('resize', renderBoard);

            const startTimer = () => {
                if (timerInterval) clearInterval(timerInterval);
                timerInterval = setInterval(() => {
                    if (!state.isPaused && !state.isSolved) {
                        state.time++;
                        timeEl.textContent = formatTime(state.time);
                        saveState(); // Save time on every tick
                    }
                }, 1000);
            };

            const togglePause = () => {
                state.isPaused = !state.isPaused;
                pauseBtn.textContent = state.isPaused ? 'Reanudar' : 'Pausar';
                pauseBtn.classList.toggle('paused', state.isPaused);
                boardEl.style.opacity = state.isPaused ? '0.5' : '1';
                if (!state.isPaused) startTimer();
                saveState();
            };

            const fetchAndPrepareImage = async (size) => {
                boardEl.innerHTML = `<p>Buscando portadas de discos...</p>`;
                try {
                    const genres = ['rock', 'pop', 'jazz', 'electronic', 'hip-hop', 'classical', 'soundtrack', 'alternative', 'reggae', 'soul'];
                    const randomGenre = genres[Math.floor(Math.random() * genres.length)];
                    
                    const response = await fetch(`https://itunes.apple.com/search?term=${randomGenre}&entity=album&limit=50&media=music`);
                    if (!response.ok) throw new Error(`Error en API de iTunes: ${response.status}`);
                    
                    const data = await response.json();
                    if (data.resultCount === 0) return fetchAndPrepareImage(size);

                    const randomAlbum = data.results[Math.floor(Math.random() * data.resultCount)];
                    const artworkUrl = randomAlbum.artworkUrl100.replace('100x100', '600x600');
                    
                    state.imageUrl = artworkUrl;
                    initGameLogic(size);

                } catch (error) {
                    console.error("Error al preparar imagen:", error);
                    boardEl.innerHTML = `<p style="color: #ef4444;">No se pudo cargar una portada. Revisa tu conexión e intenta de nuevo.</p>`;
                }
            };
            
            const initGameLogic = (size) => {
                state.gridSize = size;
                state.moves = 0;
                state.time = 0;
                state.isPaused = false;
                state.isSolved = false;

                const totalPieces = size * size;
                const solvedPieces = Array.from({ length: totalPieces }, (_, i) => ({ correctPosition: i, isEmpty: i === totalPieces - 1 }));
                
                let shuffled = [...solvedPieces];
                let emptyIndex = totalPieces - 1;
                for (let i = 0; i < 500; i++) { // Shuffling logic
                    const validMoves = [];
                    const { row, col } = { row: Math.floor(emptyIndex / size), col: emptyIndex % size };
                    if (row > 0) validMoves.push(emptyIndex - size);
                    if (row < size - 1) validMoves.push(emptyIndex + size);
                    if (col > 0) validMoves.push(emptyIndex - 1);
                    if (col < size - 1) validMoves.push(emptyIndex + 1);
                    const swapIndex = validMoves[Math.floor(Math.random() * validMoves.length)];
                    [shuffled[emptyIndex], shuffled[swapIndex]] = [shuffled[swapIndex], shuffled[emptyIndex]];
                    emptyIndex = swapIndex;
                }
                state.pieces = shuffled;

                renderBoard();
                startTimer();
                saveState();
            };
            
            const startNewGame = (size) => {
                fetchAndPrepareImage(size);
            };
            
            const checkWin = () => {
                const isSolved = state.pieces.every((p, i) => p.correctPosition === i);
                if (isSolved) {
                    state.isSolved = true;
                    clearInterval(timerInterval);
                    updateHighScores();
                    renderHighScores();
                    document.getElementById('final-time').textContent = formatTime(state.time);
                    document.getElementById('final-moves').textContent = state.moves;
                    victoryModalEl.classList.add('show');
                    localStorage.removeItem('puzzleGameState');
                }
            };
            
            const updateHighScores = () => {
                const scores = loadScores();
                const newScore = { time: state.time, moves: state.moves, size: state.gridSize, date: new Date().toISOString() };
                scores.push(newScore);
                scores.sort((a, b) => a.time - b.time);
                saveScores(scores.slice(0, 5));
            };

            const renderHighScores = () => {
                const scores = loadScores();
                if (scores.length === 0) {
                    scoresListEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">No hay récords todavía.</p>';
                    return;
                }
                scoresListEl.innerHTML = scores.map(s => `
                    <li>
                        <span>${formatTime(s.time)}</span>
                        <span style="color: var(--text-secondary); font-size: 0.8rem;">${s.moves} movs (${s.size}x${s.size})</span>
                    </li>
                `).join('');
            };

            boardEl.addEventListener('click', (e) => {
                if (state.isPaused || state.isSolved || !e.target.classList.contains('piece') || e.target.classList.contains('empty')) return;

                const clickedIndex = parseInt(e.target.dataset.index, 10);
                const emptyIndex = state.pieces.findIndex(p => p.isEmpty);
                
                const { row: cRow, col: cCol } = { row: Math.floor(clickedIndex / state.gridSize), col: clickedIndex % state.gridSize };
                const { row: eRow, col: eCol } = { row: Math.floor(emptyIndex / state.gridSize), col: emptyIndex % state.gridSize };

                if (Math.abs(cRow - eRow) + Math.abs(cCol - eCol) === 1) {
                    [state.pieces[clickedIndex], state.pieces[emptyIndex]] = [state.pieces[emptyIndex], state.pieces[clickedIndex]];
                    state.moves++;
                    renderBoard();
                    checkWin();
                    saveState();
                }
            });
            
            document.getElementById('new-game-3').onclick = () => startNewGame(3);
            document.getElementById('new-game-4').onclick = () => startNewGame(4);
            pauseBtn.onclick = togglePause;
            document.getElementById('play-again-btn').onclick = () => {
                victoryModalEl.classList.remove('show');
                startNewGame(state.gridSize);
            };

            const savedGame = loadState();
            if (savedGame && !savedGame.isSolved && savedGame.imageUrl) {
                Object.assign(state, savedGame);
                renderBoard();
                if (state.isPaused) {
                    // Correctly reflect paused state without toggling logic
                    pauseBtn.textContent = 'Reanudar';
                    pauseBtn.classList.add('paused');
                    boardEl.style.opacity = '0.5';
                } else {
                    startTimer();
                }
            } else {
                startNewGame(3);
            }
            renderHighScores();
        });
    </script>
</body>
</html>
