<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    
    <!-- PWA & Icon Metadata -->
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">
    <meta name="theme-color" content="#1DB954">
    
    <title>Puzzletunes</title>
    <style>
        :root {
            --background: #121212;
            --surface: #1e1e1e;
            --primary: #1DB954;
            --primary-hover: #1ED760;
            --secondary: #8a2be2; /* Purple for "On this day" */
            --secondary-hover: #9932cc;
            --on-background: #FFFFFF;
            --on-surface: #E0E0E0;
            --on-surface-secondary: #B3B3B3;
            --danger-color: #ff4d4d;
            --danger-hover-color: #ff6666;
            --shadow-color: rgba(0, 0, 0, 0.5);
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            --gradient-color-1: #1DB954;
            --gradient-color-2: #1ED760;
            --gradient-color-3: #FFFFFF;
            --gradient-color-4: #1DB954;
            --gradient-color-5: #1ED760;
            --gold-bg: rgba(255, 215, 0, 0.15);
            --silver-bg: rgba(192, 192, 192, 0.15);
            --bronze-bg: rgba(205, 127, 50, 0.15);
        }

        html {
            height: 100%;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--background);
            color: var(--on-background);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 1rem;
            padding-top: 6rem; /* Adjusted for taller top-bar */
            box-sizing: border-box;
            min-height: 100vh;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: var(--bg-image, none);
            background-size: cover;
            background-position: center;
            filter: blur(30px) brightness(0.4);
            transform: scale(1.1);
            z-index: -2;
            opacity: var(--bg-opacity, 0);
            transition: opacity 0.7s ease-in-out;
            will-change: opacity, background-image;
        }

        #idle-background-collage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -3;
            opacity: 0;
            transition: opacity 0.7s ease-in-out;
            overflow: hidden;
        }
        #idle-background-collage.visible {
            opacity: 1;
        }
        .collage-layer {
            position: absolute;
            background-size: cover;
            background-position: center;
            filter: blur(5px) brightness(0.5);
            transform: scale(1.1);
        }
        #collage-1 { top: -10%; left: -10%; width: 60%; height: 60%; }
        #collage-2 { top: -5%; right: -15%; width: 70%; height: 50%; }
        #collage-3 { bottom: -15%; left: 20%; width: 40%; height: 60%; }
        #collage-4 { bottom: -10%; right: -10%; width: 65%; height: 65%; }
        #collage-5 { top: 30%; left: -20%; width: 55%; height: 55%; }
        #collage-6 { top: 50%; right: -20%; width: 50%; height: 50%; opacity: 0.8; }
        #collage-7 { bottom: -20%; left: -15%; width: 60%; height: 45%; opacity: 0.9; }
        #collage-8 { top: 65%; left: 45%; width: 40%; height: 40%; transform: translateX(-50%); opacity: 0.85; }
        #collage-9 { top: 10%; left: 50%; width: 35%; height: 35%;}
        #collage-10 { bottom: 5%; right: 50%; width: 30%; height: 30%; }

        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: var(--surface);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            box-sizing: border-box;
            z-index: 100;
            box-shadow: 0 4px 12px var(--shadow-color);
        }
        
        .stats-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 0.25rem;
        }
        
        .stats-group, .controls-group {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        #player-name-display {
            font-size: 0.8rem;
            color: var(--on-surface);
            background-color: rgba(255, 255, 255, 0.05);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-weight: 500;
        }

        .main-container {
            width: 100%;
            max-width: 480px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            flex-grow: 1;
        }
        
        @media (max-height: 740px) {
            .main-container {
                gap: 0.5rem;
            }
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            color: var(--on-surface);
        }
        
        .stat-item svg {
            width: 20px;
            height: 20px;
            fill: var(--on-surface-secondary);
        }

        .control-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }
        .control-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background-color: transparent !important;
        }
        .control-button:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .control-button svg {
            width: 24px;
            height: 24px;
            fill: var(--on-surface);
        }

        .puzzle-container {
            width: 95%;
            margin: 0 auto;
            aspect-ratio: 1 / 1;
            position: relative;
            background-color: transparent;
            border-radius: 12px;
            box-shadow: 0 8px 24px var(--shadow-color);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            padding: 2px;
            box-sizing: border-box;
            z-index: 1;
            transform-style: preserve-3d;
        }
        
        .puzzle-container.intro-animation-active {
            perspective: 1000px;
        }

        @keyframes gradient-flow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .puzzle-container.animated-gradient-border::before {
            content: '';
            position: absolute;
            inset: -5px;
            z-index: -1;
            background: linear-gradient(45deg,
                var(--gradient-color-1),
                var(--gradient-color-2),
                var(--gradient-color-3),
                var(--gradient-color-4),
                var(--gradient-color-5),
                var(--gradient-color-1)
            );
            background-size: 400% 400%;
            animation: gradient-flow 8s ease infinite;
            border-radius: 16px; 
            filter: blur(20px);
        }
        
        .puzzle-container.idle-mode::after {
            content: '';
            position: absolute;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.65);
            z-index: 3;
            border-radius: 12px;
            pointer-events: none;
        }

        .idle-call-to-action {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            font-weight: 600;
            text-align: center;
            padding: 1rem;
            z-index: 4;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            width: 80%;
        }


        .puzzle-piece {
            width: 100%;
            height: 100%;
            background-size: 300% 300%;
            transition: transform 0.2s ease-in-out, top 0.15s ease-in-out, left 0.15s ease-in-out;
            cursor: pointer;
            visibility: visible;
            border-radius: 4px;
            position: relative;
            z-index: 2;
        }
        .puzzle-piece.empty {
            visibility: hidden;
            cursor: default;
        }
        .puzzle-piece:not(.empty):hover {
            transform: scale(0.95);
            opacity: 0.9;
        }
        
        /* --- Intro & Swirl Animation Styles --- */
        .puzzle-piece-intro {
            transform-style: preserve-3d;
            transform: translateY(120%) translateZ(-300px) rotateX(-90deg);
            opacity: 0;
            transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.5s ease-out;
            will-change: transform, opacity;
        }
        .puzzle-piece-intro.visible {
            transform: translateY(0) translateZ(0) rotateX(0);
            opacity: 1;
        }
        #start-game-btn {
            background-color: var(--primary);
            color: var(--background);
            font-weight: 700;
            border-radius: 50px;
            padding: 1rem 2rem;
            font-size: 1.2rem;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            transform: scale(0);
            animation: pop-in 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        #start-game-btn:hover {
            background-color: var(--primary-hover);
            transform: scale(1.05);
        }
        @keyframes pop-in {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        @keyframes swirl-out {
            0% {
                transform: rotate(0deg) scale(1);
                opacity: 1;
            }
            100% {
                transform: rotate(720deg) scale(0);
                opacity: 0;
            }
        }
        .puzzle-container.swirl-animation {
            animation: swirl-out 0.8s cubic-bezier(0.6, -0.28, 0.735, 0.045) forwards;
        }
        /* --- End Animation Styles --- */


        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 1.2rem;
            font-weight: 600;
            z-index: 10;
            padding: 1rem;
            border-radius: 12px; /* Ensure overlay fits inside container */
        }
        
        .overlay h2 {
            font-size: 1.8rem;
            margin: 0 0 0.5rem 0;
        }

        .overlay p {
            margin: 0.25rem 0;
        }
        
        .win-stats {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            margin-bottom: 1.5rem;
        }

        .suggestions-container {
            margin-top: 1rem;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .suggestion-btn {
            background-color: var(--primary);
            color: var(--background);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s ease;
        }
        .suggestion-btn:hover {
            background-color: var(--primary-hover);
        }

        .share-btn {
            background-color: var(--primary);
            color: var(--background);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background-color 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        .share-btn:hover {
            background-color: var(--primary-hover);
        }
        .share-btn:disabled {
            background-color: #555;
            cursor: wait;
        }
        .share-btn svg {
            width: 20px;
            height: 20px;
            fill: var(--background);
        }

        .current-track-info {
            text-align: center;
            padding: 0 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        .current-track-info h2 {
            font-size: 1.1rem;
            margin: 0;
            color: var(--on-surface);
        }
        .current-track-info p {
            font-size: 0.9rem;
            margin: 0.25rem 0 0;
            color: var(--on-surface-secondary);
        }
        
        #track-links {
            display: flex;
            gap: 1rem;
            margin-top: 0.25rem;
        }

        .track-link-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease;
        }
        .track-link-btn:hover {
            transform: scale(1.1);
        }
        .track-link-btn svg {
            width: 28px;
            height: 28px;
            fill: var(--on-surface-secondary);
        }

        .new-game-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            width: 100%;
        }
        
        #artist-search-desktop, #artist-search-mobile {
            flex-grow: 1;
            background-color: var(--surface);
            border: 1px solid var(--on-surface-secondary);
            border-radius: 50px;
            padding: 0.75rem 1rem;
            font-size: 1rem;
            color: var(--on-background);
            min-width: 0;
        }
        
        .action-buttons {
            display: flex;
            gap: 0.5rem;
        }

        #new-game-btn-desktop, #new-game-btn-mobile, #restart-game-btn-desktop, #restart-game-btn-mobile, #on-this-day-btn-desktop, #on-this-day-btn-mobile {
            color: var(--background);
            font-weight: 700;
            border-radius: 50px;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.4s ease, color 0.2s ease;
            white-space: nowrap;
        }

        #new-game-btn-desktop, #new-game-btn-mobile {
             background-color: var(--primary);
        }
        #new-game-btn-desktop:hover, #new-game-btn-mobile:hover {
            background-color: var(--primary-hover);
        }
        
        #on-this-day-btn-desktop, #on-this-day-btn-mobile {
            background-color: var(--secondary);
            color: var(--on-background);
        }
        #on-this-day-btn-desktop:hover, #on-this-day-btn-mobile:hover {
            background-color: var(--secondary-hover);
        }

        #restart-game-btn-desktop, #restart-game-btn-mobile {
            background-color: transparent;
            border: 2px solid var(--primary);
            color: var(--primary);
        }
        #restart-game-btn-desktop:hover, #restart-game-btn-mobile:hover {
            background-color: var(--primary);
            color: var(--background);
        }

        @keyframes neon-pulse {
            0%, 100% {
                box-shadow: 0 0 5px var(--primary), 0 0 10px var(--primary), 0 0 15px var(--primary-hover);
            }
            50% {
                box-shadow: 0 0 10px var(--primary-hover), 0 0 20px var(--primary-hover), 0 0 30px var(--primary);
            }
        }
        @keyframes neon-pulse-secondary {
            0%, 100% {
                box-shadow: 0 0 5px var(--secondary), 0 0 10px var(--secondary), 0 0 15px var(--secondary-hover);
            }
            50% {
                box-shadow: 0 0 10px var(--secondary-hover), 0 0 20px var(--secondary-hover), 0 0 30px var(--secondary);
            }
        }

        .pulsating-neon {
            animation: neon-pulse 2s ease-in-out infinite;
        }
        .pulsating-neon-secondary {
            animation: neon-pulse-secondary 2s ease-in-out infinite;
        }
        
        /* --- Responsive Controls Logic --- */

        .top-bar .desktop-controls {
            display: none;
        }

        .mobile-controls {
            flex-direction: column;
            gap: 0.75rem;
        }
        .mobile-controls #artist-search-mobile, .mobile-controls .action-buttons {
            width: 100%;
            box-sizing: border-box;
        }
        .mobile-controls .action-buttons {
            justify-content: center;
        }

        @media (min-width: 768px) {
            .mobile-controls {
                display: none;
            }
            .top-bar .desktop-controls {
                display: flex;
                flex-grow: 1;
                justify-content: center;
                align-items: center;
                gap: 1rem;
                margin: 0 2rem;
            }
            .desktop-controls #artist-search-desktop {
                width: 100%;
                max-width: 350px;
            }
            .desktop-controls #artist-search-desktop, .desktop-controls #new-game-btn-desktop, .desktop-controls #restart-game-btn-desktop, .desktop-controls #on-this-day-btn-desktop {
                padding-top: 0.5rem;
                padding-bottom: 0.5rem;
                font-size: 0.9rem;
            }
        }
        
        @media (max-height: 740px) {
             #artist-search-mobile, #new-game-btn-mobile, #restart-game-btn-mobile, #on-this-day-btn-mobile,
             #artist-search-desktop, #new-game-btn-desktop, #restart-game-btn-desktop, #on-this-day-btn-desktop {
                padding-top: 0.5rem;
                padding-bottom: 0.5rem;
                font-size: 0.9rem;
            }
        }

        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: var(--surface);
            padding: 1.5rem;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-header h2 {
            margin: 0;
            color: var(--on-surface);
        }
        .modal-header .close-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
        }
        .modal-header .close-btn svg {
            width: 24px;
            height: 24px;
            fill: var(--on-surface-secondary);
        }

        .modal-tabs {
            display: flex;
            border-bottom: 1px solid var(--on-surface-secondary);
            margin-bottom: 1rem;
        }
        .tab-btn {
            background: none;
            border: none;
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-bottom: -1px;
            transition: border-color 0.2s ease, color 0.2s ease;
            font-size: 1.5rem;
            line-height: 1;
            color: var(--on-surface-secondary);
        }
        .tab-btn:hover {
            color: var(--on-surface);
        }
        .tab-btn.active {
            border-bottom-color: var(--primary);
            color: var(--primary);
        }
        
        .modal-panels {
            flex-grow: 1;
            overflow-y: auto;
        }
        .modal-panel {
            display: none;
        }
        .modal-panel.active {
            display: block;
        }
        
        .language-options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .lang-btn {
            display: flex;
            align-items: center;
            gap: 1rem;
            background-color: rgba(255, 255, 255, 0.05);
            border: 2px solid transparent;
            padding: 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            text-align: left;
            color: var(--on-surface);
            transition: all 0.2s ease;
        }
        .lang-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .lang-btn.active {
            border-color: var(--primary);
            background-color: rgba(29, 185, 84, 0.1);
        }
        
        #info-panel p {
            line-height: 1.6;
            color: var(--on-surface);
        }

        /* --- Options Panel Sub-tabs --- */
        .options-sub-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid #444;
        }
        .options-sub-tab-btn {
            background: none;
            border: none;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
            font-size: 1.2rem;
            color: var(--on-surface-secondary);
        }
        .options-sub-tab-btn.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .options-sub-panel {
            display: none;
        }
        .options-sub-panel.active {
            display: block;
        }
        #options-panel h3 {
            margin-top: 0;
            margin-bottom: 0.75rem;
            color: var(--on-surface);
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .form-group input {
            background-color: #333;
            border: 1px solid var(--on-surface-secondary);
            border-radius: 8px;
            padding: 0.75rem;
            font-size: 1rem;
            color: var(--on-background);
        }
        .form-group button {
             background-color: var(--primary);
            color: var(--background);
            font-weight: 600;
            border-radius: 8px;
            padding: 0.75rem;
            font-size: 1rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .form-group button:hover {
            background-color: var(--primary-hover);
        }
        
        .danger-zone {
            padding: 1rem;
            border: 2px dashed var(--danger-color);
            border-radius: 8px;
            background-color: rgba(255, 77, 77, 0.05);
        }
        .danger-zone h3 {
            margin-top: 0;
            color: var(--danger-color);
        }
        #reset-game-btn {
            background-color: var(--danger-color);
            width: 100%;
        }
        #reset-game-btn:hover {
            background-color: var(--danger-hover-color);
        }
        #reset-game-warning {
            font-size: 0.8rem;
            color: var(--on-surface-secondary);
            margin-top: 0.5rem;
            text-align: center;
        }

        .genre-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .genre-tag {
            display: block;
        }
        .genre-tag input {
            display: none;
        }
        .genre-tag span {
            display: block;
            padding: 0.5rem 1rem;
            background-color: #333;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
            user-select: none;
        }
        .genre-tag input:checked + span {
            background-color: var(--primary);
            color: var(--background);
            font-weight: 600;
        }
        .genre-tag:hover span {
             background-color: #444;
        }
        .genre-tag input:checked:hover + span {
             background-color: var(--primary-hover);
        }

        .setting-switch {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            font-size: 1rem;
        }
        .switch {
          position: relative;
          display: inline-block;
          width: 60px;
          height: 34px;
        }
        .switch input { 
          opacity: 0;
          width: 0;
          height: 0;
        }
        .slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #ccc;
          transition: .4s;
        }
        .slider:before {
          position: absolute;
          content: "";
          height: 26px;
          width: 26px;
          left: 4px;
          bottom: 4px;
          background-color: white;
          transition: .4s;
        }
        input:checked + .slider {
          background-color: var(--primary);
        }
        input:focus + .slider {
          box-shadow: 0 0 1px var(--primary);
        }
        input:checked + .slider:before {
          transform: translateX(26px);
        }
        .slider.round {
          border-radius: 34px;
        }
        .slider.round:before {
          border-radius: 50%;
        }
        

        #total-playtime {
            text-align: center;
            margin-bottom: 1rem;
            font-size: 1.1rem;
            color: var(--on-surface);
        }

        #high-scores-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        #high-scores-list::-webkit-scrollbar { width: 5px; }
        #high-scores-list::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }
        #high-scores-list::-webkit-scrollbar-thumb { background: #555; border-radius: 5px; }

        .score-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            border-radius: 8px;
            background-color: rgba(0,0,0,0.2);
            margin-bottom: 0.5rem;
            transition: background-color 0.3s ease;
        }
        .score-item.gold { background-color: var(--gold-bg); }
        .score-item.silver { background-color: var(--silver-bg); }
        .score-item.bronze { background-color: var(--bronze-bg); }

        .score-rank {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--on-surface-secondary);
            width: 2rem;
            text-align: center;
            flex-shrink: 0;
        }
        .score-item:last-child { margin-bottom: 0; }
        .score-thumbnail {
            width: 60px;
            height: 60px;
            border-radius: 4px;
            object-fit: cover;
            flex-shrink: 0;
        }
        .score-info {
            flex-grow: 1;
            overflow: hidden;
        }
        .score-track {
            font-weight: 600;
            color: var(--on-surface);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: clip;
        }
        .score-artist {
            color: var(--on-surface-secondary);
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }
        .score-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.8rem;
            color: var(--on-surface-secondary);
        }
        
        .marquee-wrapper {
            overflow: hidden;
        }
        .marquee-content {
            display: inline-block;
            animation: marquee 10s linear infinite;
            animation-play-state: paused;
            padding-right: 2rem;
        }
        .marquee-wrapper:hover .marquee-content,
        .marquee-wrapper.animate .marquee-content {
            animation-play-state: running;
        }
        
        @media (hover: none) {
            .marquee-wrapper.animate .marquee-content {
                animation-play-state: running;
            }
        }
        
        @keyframes marquee {
            0% { transform: translateX(0%); }
            100% { transform: translateX(-100%); }
        }
        
        .score-delete-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
            flex-shrink: 0;
        }
        .score-delete-btn svg {
            width: 20px;
            height: 20px;
            fill: #ff4d4d;
        }
        
        /* --- Personal Best Notification Styles --- */
        .personal-best-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        .personal-best-overlay.visible {
            opacity: 1;
        }
        .personal-best-text {
            font-size: clamp(1.8rem, 5vw, 2.5rem);
            font-weight: 700;
            text-align: center;
            padding: 2rem;
            color: #fff;
            animation: pop-in 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            text-shadow:
                0 0 5px #fff,
                0 0 10px #fff,
                0 0 20px var(--gradient-color-1),
                0 0 30px var(--gradient-color-1),
                0 0 40px var(--gradient-color-2),
                0 0 50px var(--gradient-color-2);
        }

        #player-name-prompt {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--background);
            z-index: 3000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 2rem;
            box-sizing: border-box;
        }
        #player-name-prompt h2 {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        #player-name-form {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 300px;
            gap: 1rem;
        }
        #player-name-input {
            background-color: var(--surface);
            border: 1px solid var(--on-surface-secondary);
            border-radius: 50px;
            padding: 0.75rem 1rem;
            font-size: 1rem;
            color: var(--on-background);
            text-align: center;
        }
        #save-player-name-btn {
            background-color: var(--primary);
            color: var(--background);
            font-weight: 700;
            border-radius: 50px;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }


        footer {
            width: 100%;
            text-align: center;
            padding: 0.5rem;
            font-size: 0.8rem;
            color: var(--on-surface-secondary);
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            position: relative; /* Changed from absolute to relative for flow */
        }
        #footer-title {
            font-weight: 700;
            color: var(--primary);
            font-size: 1.2rem;
            position: relative;
            display: flex;
            justify-content: center;
            flex-wrap: nowrap;
            height: 1.5em; /* Reserve space */
        }
        #footer-title span {
            position: relative;
            display: inline-block;
            will-change: transform, opacity, left, top;
        }

    </style>
</head>
<body>
    <audio id="audio-player" crossorigin="anonymous" loop playsinline></audio>
    <div id="idle-background-collage">
        <div id="collage-1" class="collage-layer"></div>
        <div id="collage-2" class="collage-layer"></div>
        <div id="collage-3" class="collage-layer"></div>
        <div id="collage-4" class="collage-layer"></div>
        <div id="collage-5" class="collage-layer"></div>
        <div id="collage-6" class="collage-layer"></div>
        <div id="collage-7" class="collage-layer"></div>
        <div id="collage-8" class="collage-layer"></div>
        <div id="collage-9" class="collage-layer"></div>
        <div id="collage-10" class="collage-layer"></div>
    </div>

    <div id="player-name-prompt" style="display: none;">
        <h2 data-translate-key="playerNamePromptTitle"></h2>
        <form id="player-name-form">
            <input type="text" id="player-name-input" required minlength="1">
            <button type="submit" id="save-player-name-btn" data-translate-key="saveNameButton"></button>
        </form>
    </div>

    <div class="top-bar">
        <div class="stats-container">
            <div class="stats-group">
                <div class="stat-item">
                    <svg viewBox="0 0 24 24"><path d="M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10 10-4.486 10-10S17.514 2 12 2zm0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8z"></path><path d="M13 7h-2v5.414l3.293 3.293 1.414-1.414L13 11.586V7z"></path></svg>
                    <span id="timer">00:00</span>
                </div>
                <div class="stat-item">
                    <svg viewBox="0 0 24 24"><path d="M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6.9-4.9.9-1-2.8-2.8-.9 1c-.4-.3-1-.5-1.5-.5H14v2h.6c.2 0 .5.1.7.3l.9.9v.6h2v-1.5c0-.5-.2-1.1-.5-1.5zm-13 0c-.3.4-.5.9-.5 1.5v1.5h2V6.4l.9-.9c.2-.2.4-.3.7-.3H8V4H7.5c-.5 0-1.1.2-1.6.5l-.9-1-2.8 2.8.9 1zm12.6 9.4-.9 1c.4.3 1 .5 1.5.5H18v2h-.5c-.2 0-.5-.1-.7-.3l-.9-.9v-.6h-2v1.5c0 .5.2 1.1.5 1.5l.9 1 2.8 2.8.9-1c.3-.4.5-.9.5-1.5v-1.5h-2v.6zm-11.8 0h-2v1.5c0 .5.2 1.1.5 1.5l.9 1 2.8 2.8.9-1c.4-.3 1-.5 1.5-.5H10v-2h-.6c-.2 0-.5.1-.7-.3l-.9-.9v-.6h-2v.6z"></path></svg>
                    <span id="moves">0</span>
                </div>
            </div>
            <div id="player-name-display"></div>
        </div>
        
        <div class="new-game-controls desktop-controls">
            <input type="text" id="artist-search-desktop" data-translate-placeholder="artistSearchPlaceholder">
            <div class="action-buttons">
                <button id="on-this-day-btn-desktop" data-translate-key="onThisDayButton" style="display: none;"></button>
                <button id="new-game-btn-desktop" data-translate-key="newGame"></button>
                <button id="restart-game-btn-desktop" data-translate-key="restartGame" style="display: none;"></button>
            </div>
        </div>

        <div class="controls-group">
            <button id="pause-btn" class="control-button" data-translate-title="pauseResumeTitle">
                <svg id="pause-icon" viewBox="0 0 24 24"><path d="M8 7h3v10H8zm5 0h3v10h-3z"></path></svg>
                <svg id="play-icon" viewBox="0 0 24 24" style="display: none;"><path d="M7 6v12l10-6z"></path></svg>
            </button>
            <button id="audio-btn" class="control-button" data-translate-title="toggleSoundTitle" disabled>
                <svg id="unmute-icon" viewBox="0 0 24 24" style="display:none;"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"></path></svg>
                <svg id="mute-icon" viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"></path></svg>
            </button>
            <button id="menu-btn" class="control-button" data-translate-title="menuTitle">
                <svg viewBox="0 0 24 24"><path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"></path></svg>
            </button>
        </div>
    </div>

    <div class="main-container">
        <div class="puzzle-container" id="puzzle-container"></div>
        <div class="current-track-info" id="current-track-info">
            <div id="track-text"></div>
            <div id="track-links">
                <a id="apple-music-link" href="#" target="_blank" class="track-link-btn" style="display: none;" title="Listen on Apple Music">
                    <svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-8z"></path></svg>
                </a>
                <a id="spotify-link" href="#" target="_blank" class="track-link-btn" style="display: none;" title="Listen on Spotify">
                    <svg viewBox="0 0 24 24"><path d="M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10 10-4.486 10-10S17.514 2 12 2zm4.183 14.123c-.246.332-.703.43-1.035.183-2.76-1.683-6.22-1.95-10.387-1.02a.662.662 0 0 1-.728-.642c-.01-.36.26-.67.62-.73 4.58-1.02 8.35-.71 11.4 1.18.33.2.43.66.18 1.03zm.88-2.32c-.3.402-.84.522-1.24.222-3.09-1.89-7.73-2.43-11.45-1.32a.803.803 0 0 1-.92-.782c-.01-.44.32-.82.75-.88 4.18-1.21 9.24-.62 12.72 1.54.4.24.52.78.22 1.22zm.08-2.58c-3.53-2.08-9.43-2.28-13.3-1.25a.965.965 0 0 1-1.1-.943c-.02-.52.4-.98.92-1.04 4.3-.92 10.79-.72 14.8 1.58.48.28.64.88.35 1.36-.28.48-.88.64-1.36.35z"></path></svg>
                </a>
            </div>
        </div>

        <div class="new-game-controls mobile-controls">
            <input type="text" id="artist-search-mobile" data-translate-placeholder="artistSearchPlaceholder">
            <div class="action-buttons">
                <button id="on-this-day-btn-mobile" data-translate-key="onThisDayButton" style="display: none;"></button>
                <button id="new-game-btn-mobile" data-translate-key="newGame"></button>
                <button id="restart-game-btn-mobile" data-translate-key="restartGame" style="display: none;"></button>
            </div>
        </div>
    </div>
    
    <div id="menu-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title" data-translate-key="highScoresTitle"></h2>
                <button class="close-btn" id="close-menu-btn">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
                </button>
            </div>
            <div class="modal-tabs">
                <button class="tab-btn active" data-tab="records">🏆</button>
                <button class="tab-btn" data-tab="language">🏳️</button>
                <button class="tab-btn" data-tab="options">⚙️</button>
                <button class="tab-btn" data-tab="info">ℹ️</button>
            </div>
            <div class="modal-panels">
                <div id="records-panel" class="modal-panel active">
                    <p id="total-playtime"></p>
                    <ol id="high-scores-list"></ol>
                </div>
                <div id="language-panel" class="modal-panel">
                    <div class="language-options">
                        <button class="lang-btn" data-lang="en"><span>🇺🇸</span> <span data-translate-key="langEnglish"></span></button>
                        <button class="lang-btn" data-lang="es"><span>🇪🇸</span> <span data-translate-key="langSpanish"></span></button>
                        <button class="lang-btn" data-lang="pt"><span>🇧🇷</span> <span data-translate-key="langPortuguese"></span></button>
                        <button class="lang-btn" data-lang="fr"><span>🇫🇷</span> <span data-translate-key="langFrench"></span></button>
                    </div>
                </div>
                <div id="options-panel" class="modal-panel">
                    <div class="options-sub-tabs">
                         <button class="options-sub-tab-btn active" data-sub-tab="player">🦸‍♂️</button>
                         <button class="options-sub-tab-btn" data-sub-tab="genres">🎵</button>
                         <button class="options-sub-tab-btn" data-sub-tab="on-this-day">🗓️</button>
                         <button class="options-sub-tab-btn" data-sub-tab="reset">🧩</button>
                    </div>
                    <div class="options-sub-panels">
                        <div id="player-sub-panel" class="options-sub-panel active">
                            <h3 data-translate-key="editPlayerNameTitle"></h3>
                            <div class="form-group">
                                <input type="text" id="edit-player-name-input">
                                <button id="save-edited-player-name-btn" data-translate-key="saveNameButton"></button>
                            </div>
                        </div>
                        <div id="genres-sub-panel" class="options-sub-panel">
                            <h3 data-translate-key="favoriteGenresTitle"></h3>
                            <div id="genre-selector" class="genre-selector"></div>
                        </div>
                        <div id="on-this-day-sub-panel" class="options-sub-panel">
                            <h3 data-translate-key="onThisDayTitle"></h3>
                            <div class="setting-switch">
                                <span data-translate-key="onThisDayEnable"></span>
                                <label class="switch">
                                    <input type="checkbox" id="on-this-day-toggle">
                                    <span class="slider round"></span>
                                </label>
                            </div>
                        </div>
                        <div id="reset-sub-panel" class="options-sub-panel">
                             <div class="danger-zone">
                                <h3 data-translate-key="resetGameTitle"></h3>
                                <button id="reset-game-btn" data-translate-key="resetGameButton"></button>
                                <p id="reset-game-warning" data-translate-key="resetGameWarning"></p>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="info-panel" class="modal-panel">
                    <p data-translate-key="aboutGameText"></p>
                </div>
            </div>
        </div>
    </div>
    
    <footer id="footer">
        <div id="footer-title"></div>
        <div id="credits"><span data-translate-key="gameBy"></span> Ale Fernández PY-2025 - v2.07</div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.0/color-thief.umd.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const SIZE = 3;
            const elements = {
                puzzleContainer: document.getElementById('puzzle-container'),
                timer: document.getElementById('timer'),
                moves: document.getElementById('moves'),
                pauseBtn: document.getElementById('pause-btn'),
                audioBtn: document.getElementById('audio-btn'),
                menuBtn: document.getElementById('menu-btn'),
                trackInfo: document.getElementById('current-track-info'),
                trackText: document.getElementById('track-text'),
                appleMusicLink: document.getElementById('apple-music-link'),
                spotifyLink: document.getElementById('spotify-link'),
                audioPlayer: document.getElementById('audio-player'),
                pauseIcon: document.getElementById('pause-icon'),
                playIcon: document.getElementById('play-icon'),
                muteIcon: document.getElementById('mute-icon'),
                unmuteIcon: document.getElementById('unmute-icon'),
                menuModal: document.getElementById('menu-modal'),
                closeMenuBtn: document.getElementById('close-menu-btn'),
                modalTitle: document.getElementById('modal-title'),
                highScoresList: document.getElementById('high-scores-list'),
                idleCollage: document.getElementById('idle-background-collage'),
                gameTitle: document.getElementById('footer-title'),
                playerNamePrompt: document.getElementById('player-name-prompt'),
                playerNameForm: document.getElementById('player-name-form'),
                playerNameInput: document.getElementById('player-name-input'),
                playerNameDisplay: document.getElementById('player-name-display'),
                editPlayerNameInput: document.getElementById('edit-player-name-input'),
                saveEditedPlayerNameBtn: document.getElementById('save-edited-player-name-btn'),
                resetGameBtn: document.getElementById('reset-game-btn'),
                optionsPanel: document.getElementById('options-panel'),
                footer: document.getElementById('footer'),
                credits: document.getElementById('credits'),

                // Responsive Controls
                artistSearchDesktop: document.getElementById('artist-search-desktop'),
                newGameBtnDesktop: document.getElementById('new-game-btn-desktop'),
                restartGameBtnDesktop: document.getElementById('restart-game-btn-desktop'),
                onThisDayBtnDesktop: document.getElementById('on-this-day-btn-desktop'),
                artistSearchMobile: document.getElementById('artist-search-mobile'),
                newGameBtnMobile: document.getElementById('new-game-btn-mobile'),
                restartGameBtnMobile: document.getElementById('restart-game-btn-mobile'),
                onThisDayBtnMobile: document.getElementById('on-this-day-btn-mobile'),
            };

            let state = {
                pieces: [],
                moves: 0,
                time: 0,
                timerInterval: null,
                isPaused: true,
                isMuted: true,
                currentAlbum: null,
                gameInProgress: false,
                isIdle: false, // For controlling the idle animation
            };

            const PROXIES = [
                'https://cors.eu.org/',
                'https://cors-anywhere.poldisoft.com/',
                'https://thingproxy.freeboard.io/fetch/'
            ];
            
            const colorThief = new ColorThief();

            // --- I18n & Translation ---
            const ALL_GENRES = ['rock', 'pop', 'jazz', 'classical', 'electronic', 'hiphop', 'reggae', 'metal', 'soul', 'funk', 'latin', 'country', 'blues', 'alternative', 'reggaeton', 'cumbia', 'numetal', 'kpop', 'jpop', 'folk', 'indie'];
            const translations = {
                es: {
                    pageTitle: "Puzzletunes",
                    pauseResumeTitle: "Pausar/Reanudar",
                    toggleSoundTitle: "Activar/Desactivar Sonido",
                    menuTitle: "Menú",
                    highScoresTitle: "Mejores Tiempos",
                    languageTitle: "Idioma",
                    optionsTitle: "Opciones",
                    aboutTitle: "Acerca de",
                    artistSearchPlaceholder: "Buscar por artista (opcional)",
                    newGame: "Nuevo Juego",
                    gameBy: "Juego por:",
                    winMessage: "¡Ganaste!",
                    winTime: "Tiempo: {time}",
                    winMoves: "Movimientos: {moves}",
                    paused: "Pausado",
                    startMessage: "Haz clic en 'Nuevo Juego' para empezar",
                    loadingNewGame: "Cargando partida nueva...",
                    randomArtist: "-artista aleatorio-",
                    searchingForArtist: "-buscando a: {searchTerm}-",
                    didYouMean: "Quisiste decir:",
                    imageError: "Error al cargar la imagen. Por favor, intenta de nuevo.",
                    noMusicFoundFor: "No se encontró música para \"{searchTerm}\"",
                    noRandomMusic: "No se encontró música aleatoria. Por favor, intenta de nuevo.",
                    loadSavedImageError: "Error al cargar la imagen guardada.",
                    newGameConfirm: "¿Seguro que quieres empezar un nuevo juego? Tu progreso se perderá.",
                    deleteRecordTitle: "Eliminar récord",
                    movesSuffix: "mov.",
                    langEnglish: "Inglés",
                    langSpanish: "Español",
                    langPortuguese: "Português",
                    langFrench: "Francés",
                    aboutGameText: "¿Sabías que un estudio publicado en Frontiers in Psychology (Montag & Hegelich, 2021) demostró que el uso excesivo de redes como Instagram y TikTok activa descargas rápidas de dopamina, lo que reduce la capacidad de concentración y nos vuelve más impacientes? La buena noticia es que podés entrenar tu mente de una forma simple y entretenida: con Puzzletunes, un puzzle digital de 3×3 que exige mantener la atención y ofrece la recompensa solo al completarlo. Jugar unos minutos al día se convierte en tu “gimnasio mental” para fortalecer el foco, la paciencia y el autocontrol mientras te diviertes rearmando portadas musicales.",
                    totalPlaytimeText: "Llevas un total de <strong>{time}</strong> en partidas ganadas.",
                    hours_plural: "horas", hour_singular: "hora",
                    minutes_plural: "minutos", minute_singular: "minuto",
                    seconds_plural: "segundos", second_singular: "segundo",
                    andConnector: "y",
                    startButton: "Empezar",
                    newTopRecord: "¡Has logrado un nuevo récord personal en la posición {rank}!",
                    shareResultTitle: "Compartir Resultado",
                    shareMessage: "¡{playerName} te desafía! a resolver el puzzle de {artist} - {album} en menos de {time} y {moves} movimientos en Puzzletunes.",
                    shareImageGenerating: "Generando imagen...",
                    favoriteGenresTitle: "Géneros favoritos",
                    genreAll: "Todos",
                    rock: "Rock", pop: "Pop", jazz: "Jazz", classical: "Clásica", electronic: "Electrónica", hiphop: "Hip-Hop", reggae: "Reggae", metal: "Metal", soul: "Soul", funk: "Funk", latin: "Latina", country: "Country", blues: "Blues", alternative: "Alternativa", reggaeton: "Reggaeton", cumbia: "Cumbia", numetal: "Nu Metal", kpop: "K-Pop", jpop: "J-Pop", folk: "Folk", indie: "Indie",
                    idleCallToAction: "Toca 'Nuevo Juego' para iniciar una partida...",
                    playerNamePromptTitle: "Elige tu nombre de jugador",
                    playerNamePlaceholder: "Tu nombre aquí...",
                    saveNameButton: "Guardar",
                    playerNameLabel: "Jugador:",
                    editPlayerNameTitle: "Cambiar nombre de jugador",
                    resetGameTitle: "Resetear Puzzletunes",
                    resetGameButton: "Resetear Juego",
                    resetGameWarning: "Esto eliminará todos tus récords, tiempo total y nombre de jugador. Esta acción no se puede deshacer.",
                    resetConfirm: "¿Estás seguro de que quieres resetear el juego?",
                    emptyNameError: "El nombre no puede estar vacío.",
                    restartGame: "Reiniciar",
                    restartConfirm: "¿Seguro que quieres reiniciar este puzzle?",
                    onThisDayTitle: "Un día como hoy",
                    onThisDayButton: "Un día como hoy...",
                    onThisDayEnable: "Activar función 'Un día como hoy'",
                    noOnThisDayMusic: "No se encontró música lanzada en un día como hoy. ¡Intenta mañana!",
                    randomButton: "Aleatorio",
                    randomModeButton: "Modo Aleatorio",
                    artistModeButton: "Modo Artista",
                    idleCallToActionWithOnThisDay: "Toca 'Un día como hoy' o 'Aleatorio' para iniciar una partida...",
                    idleCallToActionWithoutOnThisDay: "Toca 'Modo Aleatorio' para iniciar una partida..."
                },
                en: {
                    pageTitle: "Puzzletunes",
                    pauseResumeTitle: "Pause/Resume",
                    toggleSoundTitle: "Toggle Sound",
                    menuTitle: "Menu",
                    highScoresTitle: "High Scores",
                    languageTitle: "Language",
                    optionsTitle: "Options",
                    aboutTitle: "About",
                    artistSearchPlaceholder: "Search by artist (optional)",
                    newGame: "New Game",
                    gameBy: "Game by:",
                    winMessage: "You Win!",
                    winTime: "Time: {time}",
                    winMoves: "Moves: {moves}",
                    paused: "Paused",
                    startMessage: "Click 'New Game' to start",
                    loadingNewGame: "Loading new game...",
                    randomArtist: "-random artist-",
                    searchingForArtist: "-searching for: {searchTerm}-",
                    didYouMean: "Did you mean:",
                    imageError: "Error loading image. Please try again.",
                    noMusicFoundFor: "No music found for \"{searchTerm}\"",
                    noRandomMusic: "No random music found. Please try again.",
                    loadSavedImageError: "Error loading saved image.",
                    newGameConfirm: "Are you sure you want to start a new game? Your progress will be lost.",
                    deleteRecordTitle: "Delete record",
                    movesSuffix: "moves",
                    langEnglish: "English",
                    langSpanish: "Spanish",
                    langPortuguese: "Portuguese",
                    langFrench: "French",
                    aboutGameText: "Did you know that a study published in Frontiers in Psychology (Montag & Hegelich, 2021) showed that excessive use of networks like Instagram and TikTok triggers rapid dopamine releases, reducing concentration and making us more impatient? The good news is you can train your mind in a simple and entertaining way: with Puzzletunes, a 3x3 digital puzzle that demands sustained attention and offers the reward only upon completion. Playing a few minutes a day becomes your 'mental gym' to strengthen focus, patience, and self-control while having fun reassembling music covers.",
                    totalPlaytimeText: "You have a total of <strong>{time}</strong> in won games.",
                    hours_plural: "hours", hour_singular: "hour",
                    minutes_plural: "minutes", minute_singular: "minute",
                    seconds_plural: "seconds", second_singular: "second",
                    andConnector: "and",
                    startButton: "Start",
                    newTopRecord: "You've achieved a new personal best at rank {rank}!",
                    shareResultTitle: "Share Result",
                    shareMessage: "{playerName} challenges you! to solve the {artist} - {album} puzzle in less than {time} and {moves} moves on Puzzletunes.",
                    shareImageGenerating: "Generating image...",
                    favoriteGenresTitle: "Favorite Genres",
                    genreAll: "All",
                    rock: "Rock", pop: "Pop", jazz: "Jazz", classical: "Classical", electronic: "Electronic", hiphop: "Hip-Hop", reggae: "Reggae", metal: "Metal", soul: "Soul", funk: "Funk", latin: "Latin", country: "Country", blues: "Blues", alternative: "Alternative", reggaeton: "Reggaeton", cumbia: "Cumbia", numetal: "Nu Metal", kpop: "K-Pop", jpop: "J-Pop", folk: "Folk", indie: "Indie",
                    idleCallToAction: "Tap 'New Game' to start a match...",
                    playerNamePromptTitle: "Choose your player name",
                    playerNamePlaceholder: "Your name here...",
                    saveNameButton: "Save",
                    playerNameLabel: "Player:",
                    editPlayerNameTitle: "Change player name",
                    resetGameTitle: "Reset Puzzletunes",
                    resetGameButton: "Reset Game",
                    resetGameWarning: "This will delete all your records, total playtime, and player name. This action cannot be undone.",
                    resetConfirm: "Are you sure you want to reset the game?",
                    emptyNameError: "Name cannot be empty.",
                    restartGame: "Restart",
                    restartConfirm: "Are you sure you want to restart this puzzle?",
                    onThisDayTitle: "On This Day",
                    onThisDayButton: "On This Day...",
                    onThisDayEnable: "Enable 'On This Day' feature",
                    noOnThisDayMusic: "No music found released on this day. Try again tomorrow!",
                    randomButton: "Random",
                    randomModeButton: "Random Mode",
                    artistModeButton: "Artist Mode",
                    idleCallToActionWithOnThisDay: "Tap 'On This Day' or 'Random' to start a match...",
                    idleCallToActionWithoutOnThisDay: "Tap 'Random Mode' to start a match..."
                },
                pt: {
                    pageTitle: "Puzzletunes",
                    pauseResumeTitle: "Pausar/Retomar",
                    toggleSoundTitle: "Ativar/Desativar Som",
                    menuTitle: "Menu",
                    highScoresTitle: "Melhores Tempos",
                    languageTitle: "Idioma",
                    optionsTitle: "Opções",
                    aboutTitle: "Sobre",
                    artistSearchPlaceholder: "Pesquisar por artista (opcional)",
                    newGame: "Novo Jogo",
                    gameBy: "Jogo por:",
                    winMessage: "Você Venceu!",
                    winTime: "Tempo: {time}",
                    winMoves: "Movimentos: {moves}",
                    paused: "Pausado",
                    startMessage: "Clique em 'Novo Jogo' para começar",
                    loadingNewGame: "Carregando novo jogo...",
                    randomArtist: "-artista aleatório-",
                    searchingForArtist: "-procurando por: {searchTerm}-",
                    didYouMean: "Você quis dizer:",
                    imageError: "Erro ao carregar a imagem. Por favor, tente novamente.",
                    noMusicFoundFor: "Nenhuma música encontrada para \"{searchTerm}\"",
                    noRandomMusic: "Nenhuma música aleatória encontrada. Por favor, tente novamente.",
                    loadSavedImageError: "Erro ao carregar a imagem salva.",
                    newGameConfirm: "Tem certeza que deseja iniciar um novo jogo? Seu progresso será perdido.",
                    deleteRecordTitle: "Excluir recorde",
                    movesSuffix: "mov.",
                    langEnglish: "Inglês",
                    langSpanish: "Espanhol",
                    langPortuguese: "Português",
                    langFrench: "Francês",
                    aboutGameText: "Você sabia que um estudo publicado na Frontiers in Psychology (Montag & Hegelich, 2021) demonstrou que o uso excessivo de redes como Instagram e TikTok ativa liberações rápidas de dopamina, o que reduz a capacidade de concentração e nos torna mais impacientes? A boa notícia é que você pode treinar sua mente de uma forma simples e divertida: com o Puzzletunes, um quebra-cabeça digital 3x3 que exige atenção contínua e oferece a recompensa apenas ao ser completado. Jogar alguns minutos por dia se torna sua 'academia mental' para fortalecer o foco, a paciência e o autocontrole enquanto você se diverte remontando capas de álbuns.",
                    totalPlaytimeText: "Você tem um total de <strong>{time}</strong> em jogos ganhos.",
                    hours_plural: "horas", hour_singular: "hora",
                    minutes_plural: "minutos", minute_singular: "minuto",
                    seconds_plural: "segundos", second_singular: "segundo",
                    andConnector: "e",
                    startButton: "Começar",
                    newTopRecord: "Você alcançou um novo recorde pessoal na posição {rank}!",
                    shareResultTitle: "Compartilhar Resultado",
                    shareMessage: "{playerName} te desafia! a resolver o quebra-cabeça de {artist} - {album} em menos de {time} e {moves} movimentos no Puzzletunes.",
                    shareImageGenerating: "Gerando imagem...",
                    favoriteGenresTitle: "Gêneros favoritos",
                    genreAll: "Todos",
                    rock: "Rock", pop: "Pop", jazz: "Jazz", classical: "Clássica", electronic: "Eletrônica", hiphop: "Hip-Hop", reggae: "Reggae", metal: "Metal", soul: "Soul", funk: "Funk", latin: "Latina", country: "Country", blues: "Blues", alternative: "Alternativa", reggaeton: "Reggaeton", cumbia: "Cumbia", numetal: "Nu Metal", kpop: "K-Pop", jpop: "J-Pop", folk: "Folk", indie: "Indie",
                    idleCallToAction: "Toque em 'Novo Jogo' para iniciar uma partida...",
                    playerNamePromptTitle: "Escolha seu nome de jogador",
                    playerNamePlaceholder: "Seu nome aqui...",
                    saveNameButton: "Salvar",
                    playerNameLabel: "Jogador:",
                    editPlayerNameTitle: "Mudar nome de jogador",
                    resetGameTitle: "Resetar Puzzletunes",
                    resetGameButton: "Resetar Jogo",
                    resetGameWarning: "Isso excluirá todos os seus recordes, tempo total e nome de jogador. Esta ação não pode ser desfeita.",
                    resetConfirm: "Você tem certeza que quer resetar o jogo?",
                    emptyNameError: "O nome não pode ficar em branco.",
                    restartGame: "Reiniciar",
                    restartConfirm: "Tem certeza de que quer reiniciar este puzzle?",
                    onThisDayTitle: "Neste dia",
                    onThisDayButton: "Neste dia...",
                    onThisDayEnable: "Ativar recurso 'Neste dia'",
                    noOnThisDayMusic: "Nenhuma música encontrada lançada neste dia. Tente amanhã!",
                    randomButton: "Aleatório",
                    randomModeButton: "Modo Aleatório",
                    artistModeButton: "Modo Artista",
                    idleCallToActionWithOnThisDay: "Toque em 'Neste dia' ou 'Aleatório' para iniciar uma partida...",
                    idleCallToActionWithoutOnThisDay: "Toque em 'Modo Aleatório' para iniciar uma partida..."
                },
                fr: {
                    pageTitle: "Puzzletunes",
                    pauseResumeTitle: "Pause/Reprendre",
                    toggleSoundTitle: "Activer/Désactiver le son",
                    menuTitle: "Menu",
                    highScoresTitle: "Meilleurs Scores",
                    languageTitle: "Langue",
                    optionsTitle: "Options",
                    aboutTitle: "À propos",
                    artistSearchPlaceholder: "Rechercher par artiste (optionnel)",
                    newGame: "Nouveau Jeu",
                    gameBy: "Jeu par :",
                    winMessage: "Vous avez gagné !",
                    winTime: "Temps : {time}",
                    winMoves: "Mouvements : {moves}",
                    paused: "En pause",
                    startMessage: "Cliquez sur 'Nouveau Jeu' pour commencer",
                    loadingNewGame: "Chargement d'une nouvelle partie...",
                    randomArtist: "-artiste aléatoire-",
                    searchingForArtist: "-recherche de : {searchTerm}-",
                    didYouMean: "Vouliez-vous dire :",
                    imageError: "Erreur de chargement de l'image. Veuillez réessayer.",
                    noMusicFoundFor: "Aucune musique trouvée pour \"{searchTerm}\"",
                    noRandomMusic: "Aucune musique aléatoire trouvée. Veuillez réessayer.",
                    loadSavedImageError: "Erreur de chargement de l'image sauvegardée.",
                    newGameConfirm: "Êtes-vous sûr de vouloir commencer une nouvelle partie ? Votre progression sera perdue.",
                    deleteRecordTitle: "Supprimer le record",
                    movesSuffix: "mouv.",
                    langEnglish: "Anglais",
                    langSpanish: "Espagnol",
                    langPortuguese: "Portugais",
                    langFrench: "Français",
                    aboutGameText: "Saviez-vous qu'une étude publiée dans Frontiers in Psychology (Montag & Hegelich, 2021) a démontré que l'utilisation excessive de réseaux comme Instagram et TikTok déclenche des libérations rapides de dopamine, ce qui réduit la capacité de concentration et nous rend plus impatients ? La bonne nouvelle est que vous pouvez entraîner votre esprit de manière simple et divertissante : avec Puzzletunes, un puzzle numérique 3x3 qui exige une attention soutenue et n'offre la récompense qu'une fois terminé. Jouer quelques minutes par jour devient votre 'salle de sport mentale' pour renforcer la concentration, la patience et la maîtrise de soi tout en vous amusant à reconstituer des pochettes d'albums.",
                    totalPlaytimeText: "Vous avez un total de <strong>{time}</strong> de parties gagnées.",
                    hours_plural: "heures", hour_singular: "heure",
                    minutes_plural: "minutes", minute_singular: "minute",
                    seconds_plural: "secondes", second_singular: "seconde",
                    andConnector: "et",
                    startButton: "Commencer",
                    newTopRecord: "Vous avez réalisé un nouveau record personnel à la position {rank} !",
                    shareResultTitle: "Partager le Résultat",
                    shareMessage: "{playerName} vous défie ! de résoudre le puzzle de {artist} - {album} en moins de {time} et {moves} mouvements sur Puzzletunes.",
                    shareImageGenerating: "Génération de l'image...",
                    favoriteGenresTitle: "Genres favoris",
                    genreAll: "Tous",
                    rock: "Rock", pop: "Pop", jazz: "Jazz", classical: "Classique", electronic: "Électronique", hiphop: "Hip-Hop", reggae: "Reggae", metal: "Métal", soul: "Soul", funk: "Funk", latin: "Latine", country: "Country", blues: "Blues", alternative: "Alternative", reggaeton: "Reggaeton", cumbia: "Cumbia", numetal: "Nu Metal", kpop: "K-Pop", jpop: "J-Pop", folk: "Folk", indie: "Indie",
                    idleCallToAction: "Appuyez sur 'Nouveau Jeu' pour commencer une partie...",
                    playerNamePromptTitle: "Choisissez votre nom de joueur",
                    playerNamePlaceholder: "Votre nom ici...",
                    saveNameButton: "Enregistrer",
                    playerNameLabel: "Joueur :",
                    editPlayerNameTitle: "Changer le nom du joueur",
                    resetGameTitle: "Réinitialiser Puzzletunes",
                    resetGameButton: "Réinitialiser le jeu",
                    resetGameWarning: "Ceci supprimera tous vos records, votre temps de jeu total et votre nom de joueur. Cette action est irréversible.",
                    resetConfirm: "Êtes-vous sûr de vouloir réinitialiser le jeu ?",
                    emptyNameError: "Le nom ne peut pas être vide.",
                    restartGame: "Redémarrer",
                    restartConfirm: "Êtes-vous sûr de vouloir redémarrer ce puzzle ?",
                    onThisDayTitle: "Ce jour-là",
                    onThisDayButton: "Ce jour-là...",
                    onThisDayEnable: "Activer la fonction 'Ce jour-là'",
                    noOnThisDayMusic: "Aucune musique trouvée sortie ce jour-là. Réessayez demain !",
                    randomButton: "Aléatoire",
                    randomModeButton: "Mode Aléatoire",
                    artistModeButton: "Mode Artiste",
                    idleCallToActionWithOnThisDay: "Appuyez sur 'Ce jour-là' ou 'Aléatoire' pour commencer une partie...",
                    idleCallToActionWithoutOnThisDay: "Appuyez sur 'Mode Aléatoire' pour commencer une partie..."
                }
            };

            let currentStrings = { ...translations.es };

            function getPlayerName() {
                return localStorage.getItem('puzzletunesPlayerName');
            }
            
            function savePlayerName(name) {
                const trimmedName = name.trim();
                if (trimmedName) {
                    localStorage.setItem('puzzletunesPlayerName', trimmedName);
                    return true;
                }
                return false;
            }

            function updatePlayerNameDisplay() {
                const name = getPlayerName();
                if (name) {
                    elements.playerNameDisplay.textContent = `${getTranslatedString('playerNameLabel')} ${name}`;
                    elements.editPlayerNameInput.value = name;
                } else {
                     elements.playerNameDisplay.textContent = '';
                }
            }

            function getTranslatedString(key, replacements = {}) {
                let str = currentStrings[key] || translations.es[key] || key;
                for (const placeholder in replacements) {
                    str = str.replace(`{${placeholder}}`, replacements[placeholder]);
                }
                return str;
            }

            function applyTranslations() {
                const lang = localStorage.getItem('puzzletunesLanguage') || 'es';
                currentStrings = translations[lang];

                document.documentElement.lang = lang;
                document.title = currentStrings.pageTitle;
                
                document.querySelectorAll('[data-translate-key]').forEach(el => {
                    const key = el.dataset.translateKey;
                    if (currentStrings[key]) { 
                        el.innerHTML = currentStrings[key];
                    }
                });
                document.querySelectorAll('[data-translate-placeholder]').forEach(el => {
                    const key = el.dataset.translatePlaceholder;
                    if (currentStrings[key]) el.placeholder = currentStrings[key];
                });
                document.querySelectorAll('[data-translate-title]').forEach(el => {
                    const key = el.dataset.translateTitle;
                    if (currentStrings[key]) el.title = currentStrings[key];
                });

                updateButtonAndTextLogic();
                
                elements.playerNameInput.placeholder = getTranslatedString('playerNamePlaceholder');
                elements.editPlayerNameInput.placeholder = getTranslatedString('playerNamePlaceholder');
                updatePlayerNameDisplay();
            }

            function updateButtonAndTextLogic() {
                const isEnabled = getOnThisDaySetting();
                const artistSearchInput = isMobileDevice() ? elements.artistSearchMobile : elements.artistSearchDesktop;
                const searchTerm = artistSearchInput.value.trim();

                const newGameBtnDesktop = elements.newGameBtnDesktop;
                const newGameBtnMobile = elements.newGameBtnMobile;
                const onThisDayBtnDesktop = elements.onThisDayBtnDesktop;
                const onThisDayBtnMobile = elements.onThisDayBtnMobile;

                let newGameKey;
                if (searchTerm) {
                    newGameKey = 'artistModeButton';
                } else if (isEnabled) {
                    newGameKey = 'randomButton';
                } else {
                    newGameKey = 'randomModeButton';
                }
                
                newGameBtnDesktop.innerHTML = getTranslatedString(newGameKey);
                newGameBtnMobile.innerHTML = getTranslatedString(newGameKey);
                
                const cta = document.getElementById('idle-cta');
                if (cta) {
                    const ctaKey = isEnabled ? 'idleCallToActionWithOnThisDay' : 'idleCallToActionWithoutOnThisDay';
                    cta.textContent = getTranslatedString(ctaKey);
                }

                if (state.isIdle) {
                    newGameBtnDesktop.classList.add('pulsating-neon');
                    newGameBtnMobile.classList.add('pulsating-neon');
                    if (isEnabled) {
                        onThisDayBtnDesktop.classList.add('pulsating-neon-secondary');
                        onThisDayBtnMobile.classList.add('pulsating-neon-secondary');
                    }
                }
            }
            
            function setLanguage(lang) {
                if (!translations[lang]) lang = 'en';
                localStorage.setItem('puzzletunesLanguage', lang);
                applyTranslations();
                updateActiveLanguageButton(lang);
                if (elements.menuModal.classList.contains('visible')) {
                    renderHighScores();
                    renderGenreSelector();
                    renderOnThisDayOption();
                }
            }
            
            function updateActiveLanguageButton(lang) {
                document.querySelectorAll('.lang-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.lang === lang);
                });
            }

            function initializeLocalization() {
                const savedLang = localStorage.getItem('puzzletunesLanguage');
                if (savedLang) {
                    setLanguage(savedLang);
                    return;
                }
                
                const browserLang = (navigator.language || navigator.userLanguage || 'en').slice(0, 2);
                const supportedLangs = ['es', 'en', 'pt', 'fr'];
                const initialLang = supportedLangs.includes(browserLang) ? browserLang : 'en';
                setLanguage(initialLang);
            }
            
            function getSavedGenres() {
                try {
                    const saved = localStorage.getItem('puzzletunesGenres');
                    if (!saved) return ['all'];
                    const parsed = JSON.parse(saved);
                    return Array.isArray(parsed) && parsed.length > 0 ? parsed : ['all'];
                } catch(e) {
                    return ['all'];
                }
            }

            function saveGenres(genres) {
                localStorage.setItem('puzzletunesGenres', JSON.stringify(genres));
            }

            function renderGenreSelector() {
                const selector = document.getElementById('genre-selector');
                if (!selector) return;
                
                const savedGenres = getSavedGenres();
                
                const genresToRender = ['all', ...ALL_GENRES];

                selector.innerHTML = genresToRender.map(genre => {
                    const key = (genre === 'all') ? 'genreAll' : genre;
                    const label = getTranslatedString(key);
                    return `
                        <label class="genre-tag">
                            <input type="checkbox" name="genre" value="${genre}" ${savedGenres.includes(genre) ? 'checked' : ''}>
                            <span>${label}</span>
                        </label>
                    `;
                }).join('');

                const checkboxes = selector.querySelectorAll('input[name="genre"]');
                checkboxes.forEach(checkbox => {
                    checkbox.addEventListener('change', (event) => {
                        handleGenreSelection(checkboxes, event.target);
                    });
                });
            }

            function handleGenreSelection(checkboxes, target) {
                const allCheckbox = document.querySelector('input[value="all"]');
                const selectedGenres = Array.from(checkboxes)
                    .filter(cb => cb.checked && cb.value !== 'all')
                    .map(cb => cb.value);

                if (target.value === 'all' && target.checked) {
                    checkboxes.forEach(cb => { if (cb.value !== 'all') cb.checked = false; });
                    saveGenres(['all']);
                } else {
                    allCheckbox.checked = selectedGenres.length === 0;
                    if (selectedGenres.length > 0) {
                        saveGenres(selectedGenres);
                    } else {
                        saveGenres(['all']);
                    }
                }
            }

            // --- "On This Day" Feature ---
            function getOnThisDaySetting() {
                const setting = localStorage.getItem('puzzletunesOnThisDay');
                return setting === null ? true : setting === 'true'; // Enabled by default
            }

            function saveOnThisDaySetting(isEnabled) {
                localStorage.setItem('puzzletunesOnThisDay', isEnabled);
                updateOnThisDayButtonVisibility();
                updateButtonAndTextLogic();
            }
            
            function renderOnThisDayOption() {
                const toggle = document.getElementById('on-this-day-toggle');
                if (!toggle) return;
                toggle.checked = getOnThisDaySetting();
                toggle.onchange = (e) => saveOnThisDaySetting(e.target.checked);
            }

            function updateOnThisDayButtonVisibility() {
                const isEnabled = getOnThisDaySetting();
                elements.onThisDayBtnDesktop.style.display = isEnabled ? 'inline-block' : 'none';
                elements.onThisDayBtnMobile.style.display = isEnabled ? 'inline-block' : 'none';
            }
            
            function getAlbumHistory() {
                try {
                    const history = localStorage.getItem('puzzletunesAlbumHistory');
                    return history ? JSON.parse(history) : [];
                } catch (e) {
                    return [];
                }
            }

            function addAlbumToHistory(albumId) {
                let history = getAlbumHistory();
                history = [albumId, ...history.filter(id => id !== albumId)];
                if (history.length > 10) {
                    history = history.slice(0, 10);
                }
                localStorage.setItem('puzzletunesAlbumHistory', JSON.stringify(history));
            }
            
            async function fetchWithProxyFallback(url) {
                let lastError = null;
                for (const proxy of PROXIES) {
                    try {
                        const response = await fetch(`${proxy}${url}`);
                        if (response.ok) return response;
                        lastError = new Error(`Proxy ${proxy} returned status ${response.status}`);
                    } catch (error) {
                        lastError = error;
                        console.warn(`Proxy ${proxy} failed:`, error);
                    }
                }
                throw lastError || new Error('All CORS proxies failed to fetch.');
            }
            
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
                const secs = (seconds % 60).toString().padStart(2, '0');
                return `${mins}:${secs}`;
            }

            function updateBackground(imageUrl) {
                document.body.style.setProperty('--bg-image', `url('${imageUrl}')`);
                document.body.style.setProperty('--bg-opacity', '1');
            }

            function clearBackground() {
                document.body.style.setProperty('--bg-opacity', '0');
                setTimeout(() => {
                    document.body.style.setProperty('--bg-image', 'none');
                }, 700);
            }

            function updateUI() {
                elements.timer.textContent = formatTime(state.time);
                elements.moves.textContent = state.moves;
                elements.pauseIcon.style.display = state.isPaused ? 'none' : 'block';
                elements.playIcon.style.display = state.isPaused ? 'block' : 'none';
                elements.muteIcon.style.display = state.isMuted ? 'block' : 'none';
                elements.unmuteIcon.style.display = state.isMuted ? 'none' : 'block';
                elements.pauseBtn.disabled = !state.gameInProgress;
            }
            
            function saveGameState() {
                if (!state.currentAlbum || !state.gameInProgress) return;
                const gameState = {
                    pieces: state.pieces.map(p => ({ originalIndex: p.originalIndex, currentIndex: p.currentIndex })),
                    moves: state.moves,
                    time: state.time,
                    isPaused: state.isPaused,
                    isMuted: state.isMuted,
                    album: state.currentAlbum,
                    gameInProgress: state.gameInProgress,
                };
                localStorage.setItem('puzzletunesGameState', JSON.stringify(gameState));
            }

            function loadGameState() {
                try {
                    const saved = localStorage.getItem('puzzletunesGameState');
                    if (saved) {
                        const savedState = JSON.parse(saved);
                        if (!savedState.album || !Array.isArray(savedState.pieces)) {
                            throw new Error("Invalid saved state structure.");
                        }
                        state.moves = savedState.moves;
                        state.time = savedState.time;
                        state.isMuted = savedState.isMuted;
                        state.currentAlbum = savedState.album;
                        state.gameInProgress = savedState.gameInProgress;
                        state.isPaused = true;
                        
                        const pieceMap = new Map(savedState.pieces.map(p => [p.currentIndex, p.originalIndex]));
                        state.pieces = Array.from({ length: SIZE * SIZE }, (_, i) => {
                            const originalIndex = pieceMap.get(i);
                            return {
                               el: null,
                               originalIndex: originalIndex,
                               currentIndex: i,
                               isEmpty: originalIndex === SIZE * SIZE - 1
                            };
                        });
                        return true;
                    }
                } catch(e) {
                    console.error("Failed to load game state, clearing.", e);
                    clearGameState();
                }
                return false;
            }
            
            function clearGameState() {
                localStorage.removeItem('puzzletunesGameState');
            }

            function renderBoard(imageUrl, boardState, isIdle = false) {
                const container = elements.puzzleContainer;
                
                // Optimized clear
                const piecesToRemove = container.querySelectorAll('.puzzle-piece');
                piecesToRemove.forEach(p => p.remove());

                if (!imageUrl || !boardState) return;

                const url = imageUrl.replace('100x100', '600x600');
                const fragment = document.createDocumentFragment();

                for (let i = 0; i < SIZE * SIZE; i++) {
                    const pieceEl = document.createElement('div');
                    pieceEl.classList.add('puzzle-piece');
                    
                    const originalIndex = boardState[i];
                    if (originalIndex === SIZE * SIZE - 1) {
                        pieceEl.classList.add('empty');
                    } else {
                        const row = Math.floor(originalIndex / SIZE);
                        const col = originalIndex % SIZE;
                        pieceEl.style.backgroundImage = `url(${url})`;
                        pieceEl.style.backgroundPosition = `${(col * 100) / (SIZE - 1)}% ${(row * 100) / (SIZE - 1)}%`;
                    }
                    
                    pieceEl.dataset.index = i;
                    pieceEl.dataset.originalIndex = originalIndex;
                    fragment.appendChild(pieceEl);
                }
                container.appendChild(fragment);
                
                if (!isIdle) {
                    container.querySelectorAll('.puzzle-piece').forEach(el => {
                        el.addEventListener('click', () => onPieceClick(parseInt(el.dataset.index, 10)));
                    });
                }
            }

            function onPieceClick(clickedIndex) {
                if (state.isPaused) return;

                const emptyPiece = state.pieces.find(p => p.isEmpty);
                const clickedPiece = state.pieces.find(p => p.currentIndex === clickedIndex);
                if (!clickedPiece || clickedPiece.isEmpty) return;

                const emptyIndex = emptyPiece.currentIndex;
                const { row: emptyRow, col: emptyCol } = getRowCol(emptyIndex);
                const { row: clickedRow, col: clickedCol } = getRowCol(clickedIndex);

                const isAdjacent = (Math.abs(emptyRow - clickedRow) === 1 && emptyCol === clickedCol) ||
                                   (Math.abs(emptyCol - clickedCol) === 1 && emptyRow === clickedRow);

                if (isAdjacent) {
                    if (state.moves === 0) {
                        state.isMuted = false;
                        elements.audioPlayer.muted = false;
                        if (elements.audioPlayer.paused) {
                            elements.audioPlayer.play().catch(e => {
                                console.error("Audio play failed on first move:", e);
                                state.isMuted = true;
                                elements.audioPlayer.muted = true;
                            });
                        }
                    }
                    
                    swapPieces(clickedPiece, emptyPiece);
                    state.moves++;
                    
                    updateUI();
                    if (checkWin()) {
                        handleWin();
                    }
                    saveGameState();
                }
            }

            function swapPieces(piece1, piece2) {
                const tempIndex = piece1.currentIndex;
                piece1.currentIndex = piece2.currentIndex;
                piece2.currentIndex = tempIndex;

                const piece1El = elements.puzzleContainer.querySelector(`[data-index="${piece2.currentIndex}"]`);
                const piece2El = elements.puzzleContainer.querySelector(`[data-index="${tempIndex}"]`);

                if (piece1El && piece2El) {
                    const tempGridArea = piece1El.style.gridArea;
                    piece1El.style.gridArea = piece2El.style.gridArea;
                }
                
                // For live games, re-render is simpler and safer
                const imageUrl = state.currentAlbum.artworkUrl;
                const boardState = Array(SIZE*SIZE).fill(0);
                state.pieces.forEach(p => {
                    boardState[p.currentIndex] = p.originalIndex;
                });
                renderBoard(imageUrl, boardState);
            }

            function getRowCol(index) {
                return { row: Math.floor(index / SIZE), col: index % SIZE };
            }

            function getValidMoves(emptyIndex) {
                const moves = [];
                const { row, col } = getRowCol(emptyIndex);
                if (row > 0) moves.push(emptyIndex - SIZE);
                if (row < SIZE - 1) moves.push(emptyIndex + SIZE);
                if (col > 0) moves.push(emptyIndex - 1);
                if (col < SIZE - 1) moves.push(emptyIndex + 1);
                return moves;
            }

            function checkWin() {
                return state.pieces.every(p => p.currentIndex === p.originalIndex);
            }
            
            function triggerWinCelebration() {
                const rootStyles = getComputedStyle(document.documentElement);
                const paletteColors = [
                    rootStyles.getPropertyValue('--gradient-color-1').trim(),
                    rootStyles.getPropertyValue('--gradient-color-2').trim(),
                    rootStyles.getPropertyValue('--gradient-color-3').trim(),
                    rootStyles.getPropertyValue('--gradient-color-4').trim(),
                    rootStyles.getPropertyValue('--gradient-color-5').trim()
                ].filter(Boolean);

                const colors = paletteColors.length > 0 ? paletteColors : ['#1DB954', '#FFFFFF', '#1ED760'];

                const defaults = {
                    origin: { x: 0.5, y: 0.5 },
                    shapes: ['♪', '♫', '♬'],
                    colors: colors,
                    disableForReducedMotion: true,
                    gravity: 0.5,
                    scalar: 2.5,
                };

                const fire = (particleCount, options) => confetti({ ...defaults, ...options, particleCount: Math.floor(particleCount) });
                
                fire(200, { spread: 180, startVelocity: 55, decay: 0.9 });
                fire(150, { spread: 120, startVelocity: 45, decay: 0.91, scalar: 2 });
                fire(250, { spread: 360, startVelocity: 30, decay: 0.92, scalar: 1.5 });
            }
            
            async function generateShareImage() {
                if (!state.currentAlbum) return null;

                return new Promise(resolve => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    img.crossOrigin = "Anonymous";

                    const imageUrl = `${PROXIES[0]}${state.currentAlbum.artworkUrl.replace('100x100', '600x600')}`;

                    img.onload = () => {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);

                        // Overlay for text readability
                        const overlayHeight = canvas.height * 0.4;
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height); // Darken entire image for better text contrast

                        const baseFontSize = Math.max(24, Math.floor(img.width * 0.05));
                        ctx.font = `bold ${baseFontSize}px ${getComputedStyle(document.body).fontFamily}`;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.textBaseline = 'top';
                        
                        const padding = Math.floor(img.width * 0.05);
                        let currentY = padding;
                        
                        // Puzzletunes Title
                        ctx.font = `bold ${baseFontSize * 1.1}px ${getComputedStyle(document.body).fontFamily}`;
                        ctx.fillText("Puzzletunes", padding, currentY);
                        currentY += baseFontSize * 1.5;

                        // Player Name
                        const playerName = getPlayerName() || 'Anonymous';
                        const playerText = `${getTranslatedString('playerNameLabel')} ${playerName}`;
                        ctx.font = `500 ${baseFontSize * 0.9}px ${getComputedStyle(document.body).fontFamily}`;
                        ctx.fillText(playerText, padding, currentY);
                        currentY += baseFontSize * 1.2;
                        
                        // Time and Moves
                        const timeText = `${getTranslatedString('winTime', {time: ''})} ${formatTime(state.time)}`;
                         ctx.font = `500 ${baseFontSize * 0.8}px ${getComputedStyle(document.body).fontFamily}`;
                        ctx.fillText(timeText, padding, currentY);
                        currentY += baseFontSize;

                        const movesText = `${getTranslatedString('winMoves', {moves: ''})} ${state.moves}`;
                        ctx.fillText(movesText, padding, currentY);

                        canvas.toBlob(blob => {
                            if (blob) {
                                resolve(new File([blob], 'puzzletunes-challenge.png', { type: 'image/png' }));
                            } else {
                                resolve(null);
                            }
                        }, 'image/png');
                    };

                    img.onerror = () => resolve(null);
                    img.src = imageUrl;
                });
            }

            function isMobileDevice() {
                return /Mobi|Android/i.test(navigator.userAgent);
            }

            function handleWin() {
                stopTimer();
                elements.puzzleContainer.classList.remove('animated-gradient-border');
                
                // Responsive button handling
                elements.restartGameBtnDesktop.style.display = 'none';
                elements.restartGameBtnMobile.style.display = 'none';
                
                // Show final solved state
                const boardState = Array.from({length: SIZE*SIZE}, (_, i) => i);
                renderBoard(state.currentAlbum.artworkUrl, boardState);
                
                triggerWinCelebration();

                state.isPaused = true;
                state.gameInProgress = false;

                const newRank = saveScore();

                setTimeout(() => {
                    const overlay = document.createElement('div');
                    overlay.className = 'overlay';
                    
                    const messageContainer = document.createElement('div');
                    
                    const winTitle = document.createElement('h2');
                    winTitle.textContent = getTranslatedString('winMessage');
                    
                    const statsContainer = document.createElement('div');
                    statsContainer.className = 'win-stats';
                    const timeStat = document.createElement('p');
                    timeStat.textContent = getTranslatedString('winTime', { time: formatTime(state.time) });
                    const movesStat = document.createElement('p');
                    movesStat.textContent = getTranslatedString('winMoves', { moves: state.moves });
                    statsContainer.appendChild(timeStat);
                    statsContainer.appendChild(movesStat);

                    messageContainer.appendChild(winTitle);
                    messageContainer.appendChild(statsContainer);

                    overlay.appendChild(messageContainer);

                    const canShareFiles = isMobileDevice() && navigator.share && navigator.canShare && navigator.canShare({ files: [new File([], '')] });

                    if (canShareFiles) {
                        const shareBtn = document.createElement('button');
                        shareBtn.className = 'share-btn';
                        shareBtn.innerHTML = `
                            <svg viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z"></path></svg>
                            <span>${getTranslatedString('shareResultTitle')}</span>
                        `;
                        
                        shareBtn.onclick = async () => {
                            const originalText = shareBtn.querySelector('span').textContent;
                            shareBtn.disabled = true;
                            shareBtn.querySelector('span').textContent = getTranslatedString('shareImageGenerating');
                            
                            const imageFile = await generateShareImage();
                            
                            const baseUrl = window.location.origin + window.location.pathname;
                            const challengeUrl = `${baseUrl}?challenge=${state.currentAlbum.collectionId}`;

                            const shareData = {
                                title: 'Puzzletunes Challenge',
                                text: getTranslatedString('shareMessage', {
                                    playerName: getPlayerName() || 'A friend',
                                    artist: state.currentAlbum.artistName,
                                    album: state.currentAlbum.collectionName,
                                    time: formatTime(state.time),
                                    moves: state.moves
                                }),
                                url: challengeUrl,
                            };
                            
                            if (imageFile) {
                                shareData.files = [imageFile];
                            }
                            
                            try {
                                await navigator.share(shareData);
                            } catch(err) {
                                console.error("Share failed:", err);
                            } finally {
                                shareBtn.disabled = false;
                                shareBtn.querySelector('span').textContent = originalText;
                            }
                        };
                        messageContainer.appendChild(shareBtn);
                    }
                    elements.puzzleContainer.appendChild(overlay);

                }, 500);

                if (newRank !== -1) {
                    setTimeout(() => showTopRecordNotification(newRank), 1200);
                }

                clearGameState();
                elements.audioPlayer.pause();
                updateUI();
            }

            function showTopRecordNotification(rank) {
                const overlay = document.createElement('div');
                overlay.className = 'personal-best-overlay';
                
                const text = document.createElement('div');
                text.className = 'personal-best-text';
                text.innerHTML = getTranslatedString('newTopRecord', { rank });
                
                overlay.appendChild(text);
                document.body.appendChild(overlay);
                
                requestAnimationFrame(() => overlay.classList.add('visible'));

                let confettiInterval = triggerTopRecordCelebration();

                overlay.addEventListener('click', () => {
                    overlay.classList.remove('visible');
                    clearInterval(confettiInterval);
                    confetti.reset();
                    overlay.addEventListener('transitionend', () => overlay.remove());
                }, { once: true });
            }

            function triggerTopRecordCelebration() {
                const end = Date.now() + (3 * 1000);
                const colors = ['#FFD700', '#FFDF00', '#F0E68C'];

                const frame = () => {
                    if (Date.now() > end) {
                        return;
                    }

                    confetti({ particleCount: 2, angle: 60, spread: 55, origin: { x: 0 }, colors: colors, shapes: ['star'] });
                    confetti({ particleCount: 2, angle: 120, spread: 55, origin: { x: 1 }, colors: colors, shapes: ['star'] });
                };
                
                const intervalId = setInterval(frame, 200);
                frame();
                return intervalId;
            }


            function getHighScores() {
                try {
                    const storedScores = localStorage.getItem('puzzletunesHighScores');
                    if (!storedScores) return [];
                    const parsedScores = JSON.parse(storedScores);
                    if (Array.isArray(parsedScores)) {
                        return parsedScores.filter(s => s && typeof s.time === 'number' && s.album);
                    }
                } catch (e) {
                    console.error("Could not parse high scores, returning empty list.", e);
                }
                return [];
            }
            
            function saveScore() {
                if (!state.currentAlbum) return -1;

                let totalPlaytime = parseInt(localStorage.getItem('puzzletunesTotalPlaytime'), 10) || 0;
                totalPlaytime += state.time;
                localStorage.setItem('puzzletunesTotalPlaytime', totalPlaytime);

                const newScore = {
                    time: state.time,
                    moves: state.moves,
                    album: { ...state.currentAlbum },
                    id: Date.now()
                };

                let highScores = getHighScores();
                highScores.push(newScore);

                highScores.sort((a, b) => {
                    if (a.time !== b.time) return a.time - b.time;
                    return a.moves - b.moves;
                });
                
                if (highScores.length > 10) {
                    highScores = highScores.slice(0, 10);
                }

                localStorage.setItem('puzzletunesHighScores', JSON.stringify(highScores));
                
                const newRank = highScores.findIndex(score => score.id === newScore.id) + 1;
                return (newRank > 0 && newRank <= 3) ? newRank : -1;
            }


            function renderHighScores() {
                const highScores = getHighScores();
                const totalPlaytimeEl = document.getElementById('total-playtime');
                const totalSeconds = parseInt(localStorage.getItem('puzzletunesTotalPlaytime'), 10) || 0;
                
                if (totalSeconds > 0) {
                    const hours = Math.floor(totalSeconds / 3600);
                    const minutes = Math.floor((totalSeconds % 3600) / 60);
                    const seconds = totalSeconds % 60;
                    
                    const timeParts = [];
                    if (hours > 0) {
                        const hourKey = hours === 1 ? 'hour_singular' : 'hours_plural';
                        timeParts.push(`${hours} ${getTranslatedString(hourKey)}`);
                    }
                    if (minutes > 0) {
                        const minuteKey = minutes === 1 ? 'minute_singular' : 'minutes_plural';
                        timeParts.push(`${minutes} ${getTranslatedString(minuteKey)}`);
                    }
                    if (seconds > 0 || totalSeconds < 60) {
                        const secondKey = seconds === 1 ? 'second_singular' : 'seconds_plural';
                        timeParts.push(`${seconds} ${getTranslatedString(secondKey)}`);
                    }
                    
                    let formattedTime;
                    if (timeParts.length === 3) {
                         const connector = ` ${getTranslatedString('andConnector')} `;
                         formattedTime = `${timeParts[0]}, ${timeParts[1]}${connector}${timeParts[2]}`;
                    } else if (timeParts.length === 2) {
                         const connector = ` ${getTranslatedString('andConnector')} `;
                         formattedTime = timeParts.join(connector);
                    } else {
                         formattedTime = timeParts[0] || '';
                    }

                    totalPlaytimeEl.innerHTML = `⏰ ${getTranslatedString('totalPlaytimeText', { time: formattedTime })}`;
                } else {
                    totalPlaytimeEl.innerHTML = '';
                }

                elements.highScoresList.innerHTML = highScores.map((item, index) => {
                    const wrapperId = `marquee-wrapper-${item.id}`;
                    const year = item.album.releaseDate ? new Date(item.album.releaseDate).getFullYear() : '';
                    const artistText = year ? `${item.album.artistName} (${year})` : item.album.artistName;

                    const rankClass = index === 0 ? 'gold' : index === 1 ? 'silver' : index === 2 ? 'bronze' : '';
                    const rankContent = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : index + 1;


                    const html = `
                        <li class="score-item ${rankClass}">
                            <span class="score-rank">${rankContent}</span>
                            <img src="${item.album.artworkUrl}" class="score-thumbnail" alt="Artwork for ${item.album.collectionName}">
                            <div class="score-info">
                                <p class="score-artist">${artistText}</p>
                                <div class="marquee-wrapper" id="${wrapperId}">
                                    <p class="score-track marquee-content">${item.album.collectionName}</p>
                                </div>
                                <div class="score-stats">
                                    <span>${formatTime(item.time)}</span>
                                    <span>${item.moves} ${getTranslatedString('movesSuffix')}</span>
                                </div>
                            </div>
                            <button class="score-delete-btn" data-id="${item.id}" title="${getTranslatedString('deleteRecordTitle')}">
                                <svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></svg>
                            </button>
                        </li>`;
                    
                    setTimeout(() => {
                        const wrapper = document.getElementById(wrapperId);
                        const content = wrapper?.querySelector('.marquee-content');
                        if (wrapper && content && content.scrollWidth > wrapper.clientWidth) {
                            wrapper.classList.add('animate');
                        }
                    }, 0);
                    return html;
                }).join('');
            }
            
            function hideOverlay() {
                const existingOverlay = elements.puzzleContainer.querySelector('.overlay');
                if (existingOverlay) {
                    existingOverlay.remove();
                }
            }

            function showOverlay(htmlContent, suggestions = []) {
                hideOverlay();
                const overlay = document.createElement('div');
                overlay.className = 'overlay';
                overlay.innerHTML = `<div>${htmlContent}</div>`;
                
                if (suggestions.length > 0) {
                    const suggestionsContainer = document.createElement('div');
                    suggestionsContainer.className = 'suggestions-container';
                    suggestions.forEach(suggestion => {
                        const btn = document.createElement('button');
                        btn.className = 'suggestion-btn';
                        btn.textContent = suggestion;
                        btn.onclick = () => {
                            const artistSearchInput = isMobileDevice() ? elements.artistSearchMobile : elements.artistSearchDesktop;
                            artistSearchInput.value = suggestion;
                            prepareNewGame(true);
                        };
                        suggestionsContainer.appendChild(btn);
                    });
                    overlay.appendChild(suggestionsContainer);
                }
                elements.puzzleContainer.appendChild(overlay);
            }
            
            async function fetchRandomArtworks(count) {
                 try {
                    const genre = ALL_GENRES[Math.floor(Math.random() * ALL_GENRES.length)];
                    const url = `https://itunes.apple.com/search?term=${genre}&entity=album&limit=50`;
                    const response = await fetchWithProxyFallback(url);
                    const data = await response.json();
                    
                    const artworks = data.results.map(item => item.artworkUrl100.replace('100x100', '300x300'));
                    const uniqueArtworks = [...new Set(artworks)];
                    
                    for (let i = uniqueArtworks.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [uniqueArtworks[i], uniqueArtworks[j]] = [uniqueArtworks[j], uniqueArtworks[i]];
                    }
                    return uniqueArtworks.slice(0, count);
                } catch (error) {
                    console.error('Failed to fetch random artworks:', error);
                    return [];
                }
            }
            
            async function findAlbumWithMusic(searchTerm, isArtistSearch = false, onThisDay = false) {
                const userGenres = getSavedGenres();
                const genresToSearch = (userGenres.includes('all') || userGenres.length === 0) ? ALL_GENRES : userGenres;
                let MAX_ATTEMPTS = onThisDay ? 10 : 5;

                const searchAndProcess = async (url) => {
                    try {
                        const response = await fetchWithProxyFallback(url);
                        const data = await response.json();
                        const songsWithPreview = data.results.filter(song => song.previewUrl && song.artworkUrl100 && song.trackViewUrl && song.trackName && song.releaseDate);
                        if (songsWithPreview.length === 0) return { albums: [], suggestions: [] };

                        const suggestions = [...new Set(data.results.map(r => r.artistName))];
                        
                        const albums = songsWithPreview.reduce((acc, song) => {
                            if (!acc[song.collectionId]) {
                                acc[song.collectionId] = {
                                    artistName: song.artistName,
                                    collectionName: song.collectionName,
                                    artworkUrl: song.artworkUrl100,
                                    previewUrl: song.previewUrl,
                                    trackViewUrl: song.trackViewUrl,
                                    trackName: song.trackName,
                                    releaseDate: song.releaseDate,
                                    collectionId: song.collectionId,
                                };
                            }
                            return acc;
                        }, {});

                        let albumArray = Object.values(albums);
                        return { albums: albumArray, suggestions };
                    } catch (error) {
                        console.error('Error in searchAndProcess:', error);
                        return { albums: [], suggestions: [] };
                    }
                };
                
                let result = null;
                let finalSuggestions = [];
                let foundOnThisDay = false;

                if (onThisDay) {
                    const today = new Date();
                    const todayMonth = today.getMonth() + 1;
                    const todayDate = today.getDate();

                    for (let i = 0; i < MAX_ATTEMPTS; i++) {
                        const genre = genresToSearch[Math.floor(Math.random() * genresToSearch.length)];
                        const searchUrl = `https://itunes.apple.com/search?term=${encodeURIComponent(genre)}&entity=song&limit=200`;
                        const { albums } = await searchAndProcess(searchUrl);

                        if (albums && albums.length > 0) {
                            const matchingAlbums = albums.filter(album => {
                                const releaseDate = new Date(album.releaseDate);
                                return releaseDate.getMonth() + 1 === todayMonth && releaseDate.getDate() === todayDate;
                            });

                            if (matchingAlbums.length > 0) {
                                result = matchingAlbums;
                                foundOnThisDay = true;
                                break;
                            }
                        }
                    }
                } else if (isArtistSearch) {
                    const searchUrl = `https://itunes.apple.com/search?term=${encodeURIComponent(searchTerm)}&entity=song&limit=200&attribute=artistTerm`;
                    const { albums, suggestions } = await searchAndProcess(searchUrl);
                    result = albums;
                    finalSuggestions = suggestions;
                } else {
                     for (let i = 0; i < MAX_ATTEMPTS; i++) {
                        const genre = genresToSearch[Math.floor(Math.random() * genresToSearch.length)];
                        const searchUrl = `https://itunes.apple.com/search?term=${encodeURIComponent(genre)}&entity=song&limit=200`;
                        const { albums } = await searchAndProcess(searchUrl);
                        if (albums && albums.length > 0) {
                            result = albums;
                            break;
                        }
                        console.warn(`Random search attempt ${i + 1} for genre ${genre} failed. Retrying...`);
                    }
                }

                if (!result || result.length === 0) {
                    return { album: null, suggestions: finalSuggestions, notFound: onThisDay && !foundOnThisDay };
                }

                const history = getAlbumHistory();
                let uniqueAlbumArray = result.filter(album => !history.includes(album.collectionId));
                
                if (uniqueAlbumArray.length === 0) {
                     console.warn("All found albums are in recent history. Retrying search...");
                     return { album: null, suggestions: finalSuggestions, retry: true };
                }

                uniqueAlbumArray.sort((a, b) => new Date(b.releaseDate) - new Date(a.releaseDate));
                
                const selectionSize = Math.min(50, Math.ceil(uniqueAlbumArray.length * 0.6));
                const newestAlbums = uniqueAlbumArray.slice(0, selectionSize);
                
                return {
                    album: newestAlbums[Math.floor(Math.random() * newestAlbums.length)],
                    suggestions: finalSuggestions
                };
            }
            
             async function findAlbumById(id) {
                try {
                    const url = `https://itunes.apple.com/lookup?id=${id}&entity=song`;
                    const response = await fetchWithProxyFallback(url);
                    const data = await response.json();
                    if (data.resultCount > 0) {
                        const song = data.results.find(item => item.wrapperType === 'track');
                        if (song && song.previewUrl) {
                            return {
                                artistName: song.artistName,
                                collectionName: song.collectionName,
                                artworkUrl: song.artworkUrl100,
                                previewUrl: song.previewUrl,
                                trackViewUrl: song.trackViewUrl,
                                trackName: song.trackName,
                                releaseDate: song.releaseDate,
                                collectionId: song.collectionId,
                            };
                        }
                    }
                    return null;
                } catch (error) {
                    console.error('Error finding album by ID:', error);
                    return null;
                }
            }
            
            async function prepareNewGame(isFromSuggestion = false, challengeId = null, onThisDay = false) {
                const artistSearchInput = isMobileDevice() ? elements.artistSearchMobile : elements.artistSearchDesktop;
                let searchTerm = artistSearchInput.value.trim();
                let isArtistSearch = searchTerm.length > 0;
                let retryCount = 0;
                const MAX_RETRIES = 3;

                const attemptSearch = async () => {
                    const title = getTranslatedString('loadingNewGame');
                    let subtitle = isArtistSearch
                        ? getTranslatedString('searchingForArtist', { searchTerm })
                        : getTranslatedString('randomArtist');
                    if (challengeId) subtitle = ''; // No subtitle for challenges
                    if (onThisDay) subtitle = getTranslatedString('onThisDayButton');

                    const overlayHTML = `<h2>${title}</h2><p style="font-size: 1rem; color: var(--on-surface-secondary);">${subtitle}</p>`;
                    showOverlay(overlayHTML);
                    
                    if (challengeId) {
                        const album = await findAlbumById(challengeId);
                        return { finalAlbum: album };
                    }

                    const { album, suggestions, retry, notFound } = await findAlbumWithMusic(searchTerm, isArtistSearch, onThisDay);

                    if (album) {
                        return { finalAlbum: album };
                    }

                    if (retry && retryCount < MAX_RETRIES) {
                        retryCount++;
                        return attemptSearch(); // Recursive call
                    }

                    if (onThisDay && notFound) {
                        showOverlay(getTranslatedString('noOnThisDayMusic'));
                        return { error: true };
                    }

                    if (isArtistSearch && !isFromSuggestion) {
                        const filteredSuggestions = [...new Set(suggestions)]
                            .map(name => ({ name, distance: calculateLevenshteinDistance(searchTerm.toLowerCase(), name.toLowerCase()) }))
                            .filter(item => item.distance < 4 && item.name.toLowerCase() !== searchTerm.toLowerCase())
                            .sort((a, b) => a.distance - b.distance)
                            .map(item => item.name)
                            .slice(0, 3);

                        if (filteredSuggestions.length > 0) {
                            showOverlay(getTranslatedString('didYouMean'), filteredSuggestions);
                            return { error: true };
                        }
                    }

                    const message = isArtistSearch ? getTranslatedString('noMusicFoundFor', {searchTerm}) : getTranslatedString('noRandomMusic');
                    showOverlay(message);
                    return { error: true };
                };
                
                const { finalAlbum, error } = await attemptSearch();

                if (error || !finalAlbum) return;

                state.currentAlbum = finalAlbum;
                
                const img = new Image();
                img.crossOrigin = "Anonymous";
                // Load image through proxy for color thief
                const proxiedImageUrl = `${PROXIES[0]}${state.currentAlbum.artworkUrl.replace('100x100', '600x600')}`;
                img.src = proxiedImageUrl;
                
                img.onload = () => {
                    try {
                        const palette = colorThief.getPalette(img, 5);
                        palette.forEach((c, i) => document.documentElement.style.setProperty(`--gradient-color-${i + 1}`, `rgb(${c[0]}, ${c[1]}, ${c[2]})`));
                    } catch(e) { console.error("ColorThief failed:", e); }
                    
                    updateBackground(proxiedImageUrl);
                    hideOverlay();
                    playIntroAnimation();
                };
                img.onerror = () => showOverlay(getTranslatedString('imageError'));
            }

            function cleanupPreviousGameResources() {
                stopTimer();
                state.isIdle = false; // Stop idle animation
                elements.audioPlayer.pause();
                elements.audioPlayer.removeAttribute('src');
                elements.audioPlayer.load();
                clearBackground();
                elements.puzzleContainer.innerHTML = '';
                elements.trackText.innerHTML = '';
                hideTrackLinks();
                state.currentAlbum = null;
                state.gameInProgress = false;
                state.isPaused = true;
                state.time = 0;
                state.moves = 0;
                
                elements.idleCollage.classList.remove('visible');
                elements.puzzleContainer.classList.remove('animated-gradient-border', 'idle-mode');
                
                // Responsive button handling
                const newGameBtnDesktop = elements.newGameBtnDesktop;
                const newGameBtnMobile = elements.newGameBtnMobile;
                newGameBtnDesktop.classList.remove('pulsating-neon');
                newGameBtnMobile.classList.remove('pulsating-neon');
                elements.onThisDayBtnDesktop.classList.remove('pulsating-neon-secondary');
                elements.onThisDayBtnMobile.classList.remove('pulsating-neon-secondary');
                elements.restartGameBtnDesktop.style.display = 'none';
                elements.restartGameBtnMobile.style.display = 'none';
                
                const cta = document.getElementById('idle-cta');
                if (cta) cta.remove();
                
                updateUI();
            }

            function updateTrackLinks(album) {
                if (!album || !album.trackViewUrl || !album.trackName) {
                    hideTrackLinks();
                    return;
                }

                elements.appleMusicLink.href = album.trackViewUrl;
                elements.appleMusicLink.style.display = 'flex';

                const spotifyQuery = `${album.artistName} ${album.trackName}`;
                const spotifyUrl = `https://open.spotify.com/search/${encodeURIComponent(spotifyQuery)}`;
                elements.spotifyLink.href = spotifyUrl;
                elements.spotifyLink.style.display = 'flex';
            }

            function hideTrackLinks() {
                elements.appleMusicLink.style.display = 'none';
                elements.appleMusicLink.href = '#';
                elements.spotifyLink.style.display = 'none';
                elements.spotifyLink.href = '#';
            }
            
            function updateTrackText() {
                if (!state.currentAlbum) {
                    elements.trackText.innerHTML = '';
                    return;
                }
                const year = state.currentAlbum.releaseDate ? new Date(state.currentAlbum.releaseDate).getFullYear() : '';
                const artistText = year ? `${state.currentAlbum.artistName} (${year})` : state.currentAlbum.artistName;
                elements.trackText.innerHTML = `<h2>${state.currentAlbum.collectionName}</h2><p>${artistText}</p>`;
            }

            function playIntroAnimation() {
                elements.puzzleContainer.innerHTML = '';
                elements.puzzleContainer.classList.remove('animated-gradient-border');
                elements.puzzleContainer.classList.add('intro-animation-active');
                updateTrackText();
                updateTrackLinks(state.currentAlbum);
                
                const imageUrl = state.currentAlbum.artworkUrl.replace('100x100', '600x600');
                const pieces = [];

                for (let i = 0; i < SIZE * SIZE; i++) {
                    const pieceEl = document.createElement('div');
                    pieceEl.classList.add('puzzle-piece', 'puzzle-piece-intro');
                    const row = Math.floor(i / SIZE);
                    const col = i % SIZE;
                    pieceEl.style.backgroundImage = `url(${imageUrl})`;
                    pieceEl.style.backgroundPosition = `${(col * 100) / (SIZE - 1)}% ${(row * 100) / (SIZE - 1)}%`;
                    elements.puzzleContainer.appendChild(pieceEl);
                    pieces.push(pieceEl);
                }

                const shuffledIndices = [...Array(pieces.length).keys()].sort(() => Math.random() - 0.5);
                shuffledIndices.forEach((index, i) => {
                    setTimeout(() => {
                        pieces[index].classList.add('visible');
                    }, i * 100);
                });
                
                setTimeout(() => {
                    const startOverlay = document.createElement('div');
                    startOverlay.className = 'overlay';
                    startOverlay.style.backgroundColor = 'rgba(0,0,0,0.5)';
                    const startButton = document.createElement('button');
                    startButton.id = 'start-game-btn';
                    startButton.textContent = getTranslatedString('startButton');
                    startOverlay.appendChild(startButton);
                    elements.puzzleContainer.appendChild(startOverlay);

                    startButton.onclick = () => {
                        startOverlay.remove();
                        elements.puzzleContainer.classList.add('swirl-animation');
                        setTimeout(() => {
                            elements.puzzleContainer.classList.remove('swirl-animation', 'intro-animation-active');
                            elements.puzzleContainer.style.opacity = '0';
                            startNewGame();
                            requestAnimationFrame(() => {
                                elements.puzzleContainer.style.transition = 'opacity 0.4s ease';
                                elements.puzzleContainer.style.opacity = '1';
                                setTimeout(() => { elements.puzzleContainer.style.transition = ''; elements.puzzleContainer.style.opacity = ''; }, 400);
                            });
                        }, 800);
                    };
                }, (shuffledIndices.length * 100) + 800);
            }

            function startNewGame() {
                // clearGameState() is now called on button click, not here.
                state.time = 0;
                state.moves = 0;
                state.isPaused = false;
                state.isMuted = true;
                state.gameInProgress = true;
                
                addAlbumToHistory(state.currentAlbum.collectionId);

                let board = Array.from({ length: SIZE * SIZE }, (_, i) => i);
                let emptyPosition = SIZE * SIZE - 1;
                
                const shuffleMoves = 150; 
                for (let i = 0; i < shuffleMoves; i++) {
                    const validMoves = getValidMoves(emptyPosition);
                    const move = validMoves[Math.floor(Math.random() * validMoves.length)];
                    [board[emptyPosition], board[move]] = [board[move], board[emptyPosition]];
                    emptyPosition = move;
                }
                
                state.pieces = Array.from({ length: SIZE * SIZE }, (_, i) => ({
                    el: null,
                    originalIndex: i,
                    currentIndex: board.indexOf(i),
                    isEmpty: i === SIZE * SIZE - 1
                }));
                
                const imageUrl = state.currentAlbum.artworkUrl.replace('100x100', '600x600');
                const boardState = Array(SIZE*SIZE).fill(0);
                state.pieces.forEach(p => {
                    boardState[p.currentIndex] = p.originalIndex;
                });
                renderBoard(imageUrl, boardState);
                
                startTimer();
                elements.puzzleContainer.classList.add('animated-gradient-border');
                
                // Responsive button handling
                updateButtonAndTextLogic();

                elements.restartGameBtnDesktop.style.display = 'inline-block';
                elements.restartGameBtnMobile.style.display = 'inline-block';

                updateTrackText();
                updateTrackLinks(state.currentAlbum);
                elements.audioPlayer.src = state.currentAlbum.previewUrl;
                elements.audioBtn.disabled = true;
                elements.audioPlayer.muted = true;
                updateUI();
                saveGameState();
            }
            
            async function animateTitle() {
                const titleEl = elements.gameTitle;
                if (!titleEl || titleEl.dataset.animated === "true") return;
                
                if(elements.footer.contains(titleEl)){
                    titleEl.dataset.animated = "true";
                }

                const text = "Puzzletunes";
                titleEl.innerHTML = text.split('').map(letter => `<span>${letter === ' ' ? '&nbsp;' : letter}</span>`).join('');
                const spans = Array.from(titleEl.children);
                
                const finalPositions = spans.map(span => {
                    const rect = span.getBoundingClientRect();
                    return { x: rect.left, y: rect.top, width: rect.width, height: rect.height };
                });
                
                if (finalPositions.some(p => p.width === 0)) {
                    titleEl.textContent = text;
                    return;
                }

                titleEl.style.height = `${finalPositions[0].height}px`;

                const screenCenterX = window.innerWidth / 2;
                const screenCenterY = window.innerHeight / 2;
                
                spans.forEach((span, i) => {
                    span.style.position = 'fixed';
                    span.style.left = `${screenCenterX - finalPositions[i].width / 2}px`;
                    span.style.top = `${screenCenterY - finalPositions[i].height / 2}px`;
                    span.style.opacity = '0';
                    span.style.transform = 'scale(0.5)';
                    span.style.transition = `all 0.8s cubic-bezier(0.2, 0.8, 0.2, 1)`;
                });

                const shuffledIndices = [...Array(spans.length).keys()].sort(() => Math.random() - 0.5);
                
                await new Promise(resolve => requestAnimationFrame(() => setTimeout(resolve, 20)));

                spans.forEach((span, i) => {
                    const shuffledIndex = shuffledIndices[i];
                    const targetPos = finalPositions[shuffledIndex];
                    span.style.left = `${targetPos.x}px`;
                    span.style.top = `${targetPos.y}px`;
                    span.style.opacity = '1';
                    span.style.transform = 'scale(1)';
                    span.style.transitionDelay = `${i * 0.05}s`;
                });

                await new Promise(resolve => setTimeout(resolve, 800 + (text.length * 50)));

                spans.forEach((span, i) => {
                    const finalPos = finalPositions[i];
                    span.style.left = `${finalPos.x}px`;
                    span.style.transitionDelay = '0s';
                    span.style.transitionDuration = '0.6s';
                });

                await new Promise(resolve => setTimeout(resolve, 700));

                spans.forEach(span => {
                    span.style.position = 'relative';
                    span.style.left = '';
                    span.style.top = '';
                    span.style.transform = '';
                    span.style.transition = '';
                });
            }
            
            // --- GHOST SOLVER ANIMATION ---

            async function ghostSolverLoop(urls) {
                const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

                for (let i = 0; i < urls.length; i++) {
                    if (!state.isIdle) break;

                    let board = Array.from({ length: SIZE * SIZE }, (_, i) => i);
                    let shuffledBoard = [...board];
                    let emptyIndex = SIZE * SIZE - 1;
                    
                    // Simple shuffle, good enough for animation
                    for (let j = 0; j < 50; j++) {
                        const validMoves = getValidMoves(emptyIndex);
                        const move = validMoves[Math.floor(Math.random() * validMoves.length)];
                        [shuffledBoard[emptyIndex], shuffledBoard[move]] = [shuffledBoard[move], shuffledBoard[emptyIndex]];
                        emptyIndex = move;
                    }
                    
                    renderBoard(urls[i], shuffledBoard, true);

                    const solution = solvePuzzle(shuffledBoard);
                    if (!solution || !state.isIdle) continue;

                    for (const move of solution) {
                        if (!state.isIdle) break;
                        shuffledBoard = move;
                        renderBoard(urls[i], shuffledBoard, true);
                        await delay(150);
                    }
                    
                    if (state.isIdle) await delay(2000);
                }

                if (state.isIdle) {
                    ghostSolverLoop(urls); // Loop indefinitely
                }
            }

            function solvePuzzle(startBoard) {
                const goal = Array.from({ length: SIZE * SIZE }, (_, i) => i);
                const goalStr = goal.join(',');

                // Basic Breadth-First Search (BFS) is simpler and sufficient for 3x3
                const queue = [[startBoard, []]]; // [board, path]
                const visited = new Set([startBoard.join(',')]);

                while (queue.length > 0) {
                    const [currentBoard, path] = queue.shift();
                    
                    if (currentBoard.join(',') === goalStr) {
                        return path;
                    }

                    const emptyIndex = currentBoard.indexOf(SIZE * SIZE - 1);
                    const validMoves = getValidMoves(emptyIndex);

                    for (const move of validMoves) {
                        const newBoard = [...currentBoard];
                        [newBoard[emptyIndex], newBoard[move]] = [newBoard[move], newBoard[emptyIndex]];
                        const newBoardStr = newBoard.join(',');

                        if (!visited.has(newBoardStr)) {
                            visited.add(newBoardStr);
                            const newPath = [...path, newBoard];
                            queue.push([newBoard, newPath]);
                        }
                    }
                }
                return null; // Should not happen for solvable puzzles
            }
            
            function renderStaticTitle() {
                const titleEl = elements.gameTitle;
                if (titleEl) {
                     if(!elements.footer.contains(titleEl)) {
                        elements.footer.prepend(titleEl);
                     }
                     if(titleEl.innerHTML.trim() === '') {
                        titleEl.textContent = 'Puzzletunes';
                     }
                }
            }

            async function setupIdleAnimation() {
                state.isIdle = true;
                const allArtworks = await fetchRandomArtworks(10);
                if (!state.isIdle || !allArtworks || allArtworks.length < 10) {
                    // Fallback if fetch fails or user starts game during fetch
                    showOverlay(getTranslatedString('startMessage'));
                    renderStaticTitle();
                    return;
                }
                
                elements.puzzleContainer.classList.add('idle-mode');
                const callToAction = document.createElement('div');
                callToAction.className = 'idle-call-to-action';
                callToAction.id = 'idle-cta';
                elements.puzzleContainer.appendChild(callToAction);

                updateButtonAndTextLogic();
                
                const backgroundLayers = elements.idleCollage.children;
                allArtworks.forEach((url, i) => {
                    if (backgroundLayers[i]) {
                        backgroundLayers[i].style.backgroundImage = `url('${url.replace('300x300', '600x600')}')`;
                    }
                });
                elements.idleCollage.classList.add('visible');

                animateTitle();
                ghostSolverLoop(allArtworks);
            }
            
            async function initGame() {
                if (!getPlayerName()) {
                    elements.playerNamePrompt.style.display = 'flex';
                    return; 
                }
                
                updatePlayerNameDisplay();
                updateOnThisDayButtonVisibility();

                const urlParams = new URLSearchParams(window.location.search);
                const challengeId = urlParams.get('challenge');

                if (challengeId) {
                    // Clear the URL to avoid re-triggering the challenge on reload
                    window.history.replaceState({}, document.title, window.location.pathname);
                    cleanupPreviousGameResources();
                    renderStaticTitle();
                    await prepareNewGame(false, challengeId);
                    return;
                }
                
                if (loadGameState() && state.gameInProgress) {
                    const proxiedImageUrl = `${PROXIES[0]}${state.currentAlbum.artworkUrl.replace('100x100', '600x600')}`;
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.src = proxiedImageUrl;

                    img.onload = () => {
                        renderStaticTitle();
                        try {
                            const palette = colorThief.getPalette(img, 5);
                            palette.forEach((c, i) => document.documentElement.style.setProperty(`--gradient-color-${i + 1}`, `rgb(${c[0]}, ${c[1]}, ${c[2]})`));
                        } catch(e) { console.error("ColorThief failed on load:", e); }
                        updateBackground(proxiedImageUrl);
                        const boardState = Array(SIZE*SIZE).fill(0);
                        state.pieces.forEach(p => {
                           boardState[p.currentIndex] = p.originalIndex;
                        });
                        renderBoard(proxiedImageUrl, boardState);

                        startTimer();
                        elements.puzzleContainer.classList.add('animated-gradient-border');
                        
                        // Responsive button handling
                        updateButtonAndTextLogic();
                        elements.restartGameBtnDesktop.style.display = 'inline-block';
                        elements.restartGameBtnMobile.style.display = 'inline-block';

                        updateUI();
                        showOverlay(getTranslatedString('paused'));
                        updateTrackText();
                        updateTrackLinks(state.currentAlbum);
                        if (state.currentAlbum.previewUrl) {
                            elements.audioPlayer.src = state.currentAlbum.previewUrl;
                        }
                    };
                     img.onerror = () => {
                        renderStaticTitle();
                        showOverlay(getTranslatedString('loadSavedImageError'));
                     }
                } else {
                    elements.gameTitle.innerHTML = '';
                    setupIdleAnimation();
                }
            }
            
            function startTimer() {
                if (state.timerInterval) clearInterval(state.timerInterval);
                state.timerInterval = setInterval(() => {
                    if (!state.isPaused) {
                        state.time++;
                        elements.timer.textContent = formatTime(state.time);
                    }
                }, 1000);
            }

            function stopTimer() {
                clearInterval(state.timerInterval);
                state.timerInterval = null;
            }

            function switchTab(tabName) {
                const modal = elements.menuModal;
                modal.querySelectorAll('.tab-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.tab === tabName));
                modal.querySelectorAll('.modal-panel').forEach(panel => panel.classList.toggle('active', panel.id === `${tabName}-panel`));
                
                let titleKey;
                if(tabName === 'records') titleKey = 'highScoresTitle';
                else if (tabName === 'language') titleKey = 'languageTitle';
                else if (tabName === 'options') titleKey = 'optionsTitle';
                else if (tabName === 'info') titleKey = 'aboutTitle';
                elements.modalTitle.textContent = getTranslatedString(titleKey);
                elements.modalTitle.dataset.translateKey = titleKey;

                if (tabName === 'options') {
                    switchSubTab('player');
                }
            }

            function switchSubTab(subTabName) {
                const optionsPanel = elements.optionsPanel;
                optionsPanel.querySelectorAll('.options-sub-tab-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.subTab === subTabName));
                optionsPanel.querySelectorAll('.options-sub-panel').forEach(panel => panel.classList.toggle('active', panel.id === `${subTabName}-sub-panel`));
            }

            function resetGameFactory() {
                 if (confirm(getTranslatedString('resetConfirm'))) {
                    localStorage.removeItem('puzzletunesGameState');
                    localStorage.removeItem('puzzletunesHighScores');
                    localStorage.removeItem('puzzletunesTotalPlaytime');
                    localStorage.removeItem('puzzletunesPlayerName');
                    localStorage.removeItem('puzzletunesGenres');
                    localStorage.removeItem('puzzletunesLanguage');
                    localStorage.removeItem('puzzletunesAlbumHistory');
                    localStorage.removeItem('puzzletunesOnThisDay');
                    window.location.reload();
                }
            }

            function restartCurrentGame() {
                if (!state.gameInProgress || !state.currentAlbum) return;
                if (confirm(getTranslatedString('restartConfirm'))) {
                    stopTimer();
                    state.time = 0;
                    state.moves = 0;
                    state.isPaused = false;
                    
                    let board = Array.from({ length: SIZE * SIZE }, (_, i) => i);
                    let emptyPosition = SIZE * SIZE - 1;
                    
                    const shuffleMoves = 150; 
                    for (let i = 0; i < shuffleMoves; i++) {
                        const validMoves = getValidMoves(emptyPosition);
                        const move = validMoves[Math.floor(Math.random() * validMoves.length)];
                        [board[emptyPosition], board[move]] = [board[move], board[emptyPosition]];
                        emptyPosition = move;
                    }
                    
                    state.pieces = Array.from({ length: SIZE * SIZE }, (_, i) => ({
                        el: null,
                        originalIndex: i,
                        currentIndex: board.indexOf(i),
                        isEmpty: i === SIZE * SIZE - 1
                    }));
                    
                    const imageUrl = state.currentAlbum.artworkUrl.replace('100x100', '600x600');
                    const boardState = Array(SIZE*SIZE).fill(0);
                    state.pieces.forEach(p => {
                        boardState[p.currentIndex] = p.originalIndex;
                    });
                    renderBoard(imageUrl, boardState);
                    
                    startTimer();
                    hideOverlay();
                    updateUI();
                    saveGameState();
                }
            }
            
            function setupResponsiveControls() {
                const desktopSearch = elements.artistSearchDesktop;
                const mobileSearch = elements.artistSearchMobile;
                
                function handleNewGameClick(onThisDay = false) {
                    if (state.gameInProgress && !confirm(getTranslatedString('newGameConfirm'))) return;
                    
                    if (state.gameInProgress) {
                        clearGameState();
                    }
                    cleanupPreviousGameResources();
                    renderStaticTitle(); // Ensure title persists
                    prepareNewGame(false, null, onThisDay);
                }

                desktopSearch.addEventListener('dblclick', () => desktopSearch.value = '');
                mobileSearch.addEventListener('dblclick', () => mobileSearch.value = '');

                desktopSearch.addEventListener('input', updateButtonAndTextLogic);
                mobileSearch.addEventListener('input', updateButtonAndTextLogic);

                elements.newGameBtnDesktop.addEventListener('click', () => handleNewGameClick(false));
                elements.newGameBtnMobile.addEventListener('click', () => handleNewGameClick(false));
                elements.onThisDayBtnDesktop.addEventListener('click', () => handleNewGameClick(true));
                elements.onThisDayBtnMobile.addEventListener('click', () => handleNewGameClick(true));
                elements.restartGameBtnDesktop.addEventListener('click', restartCurrentGame);
                elements.restartGameBtnMobile.addEventListener('click', restartCurrentGame);

                // Sync search input values
                desktopSearch.addEventListener('input', () => mobileSearch.value = desktopSearch.value);
                mobileSearch.addEventListener('input', () => desktopSearch.value = mobileSearch.value);
            }
            

            elements.menuModal.addEventListener('click', (e) => {
                const tabBtn = e.target.closest('.tab-btn');
                if (tabBtn) switchTab(tabBtn.dataset.tab);

                const langBtn = e.target.closest('.lang-btn');
                if(langBtn) setLanguage(langBtn.dataset.lang);

                const subTabBtn = e.target.closest('.options-sub-tab-btn');
                if (subTabBtn) switchSubTab(subTabBtn.dataset.subTab);
            });
            
            elements.playerNameForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const name = elements.playerNameInput.value;
                if (savePlayerName(name)) {
                    elements.playerNamePrompt.style.display = 'none';
                    initGame();
                } else {
                    alert(getTranslatedString('emptyNameError'));
                }
            });
            
            elements.saveEditedPlayerNameBtn.addEventListener('click', () => {
                const name = elements.editPlayerNameInput.value;
                if (savePlayerName(name)) {
                    updatePlayerNameDisplay();
                    alert('OK!'); // Simple feedback
                } else {
                    alert(getTranslatedString('emptyNameError'));
                }
            });

            elements.resetGameBtn.addEventListener('click', resetGameFactory);

            elements.pauseBtn.addEventListener('click', () => {
                if (!state.gameInProgress) return;
                state.isPaused = !state.isPaused;
                if (state.isPaused) {
                    stopTimer();
                    elements.audioPlayer.pause();
                    showOverlay(getTranslatedString('paused'));
                    elements.puzzleContainer.classList.remove('animated-gradient-border');
                } else {
                    hideOverlay();
                    startTimer();
                    elements.puzzleContainer.classList.add('animated-gradient-border');
                    if (!state.isMuted && elements.audioPlayer.src) {
                        elements.audioPlayer.play().catch(e => console.error("Error on resume:", e));
                    }
                }
                updateUI();
                saveGameState();
            });

            elements.audioBtn.addEventListener('click', () => {
                state.isMuted = !state.isMuted;
                elements.audioPlayer.muted = state.isMuted;
                if (elements.audioPlayer.paused && !state.isMuted) {
                    elements.audioPlayer.play().catch(e => {
                        console.error("Error on unmute:", e);
                        state.isMuted = true;
                        elements.audioPlayer.muted = true;
                    });
                }
                updateUI();
                if (state.gameInProgress) saveGameState();
            });

            elements.audioPlayer.addEventListener('canplaythrough', () => elements.audioBtn.disabled = false);
            
            elements.menuBtn.addEventListener('click', () => {
                renderHighScores();
                renderGenreSelector();
                renderOnThisDayOption();
                updatePlayerNameDisplay(); // Ensure name is current in edit field
                switchTab('records');
                elements.menuModal.classList.add('visible');
            });
            elements.closeMenuBtn.addEventListener('click', () => elements.menuModal.classList.remove('visible'));

            elements.highScoresList.addEventListener('click', (e) => {
                const deleteBtn = e.target.closest('.score-delete-btn');
                if (deleteBtn) deleteScore(parseInt(deleteBtn.dataset.id, 10));
            });
            window.addEventListener('beforeunload', () => saveGameState());
            
             // Levenshtein distance function for suggestions
            function calculateLevenshteinDistance(a, b) {
                if (a.length === 0) return b.length;
                if (b.length === 0) return a.length;
                const matrix = [];
                for (let i = 0; i <= b.length; i++) {
                    matrix[i] = [i];
                }
                for (let j = 0; j <= a.length; j++) {
                    matrix[0][j] = j;
                }
                for (let i = 1; i <= b.length; i++) {
                    for (let j = 1; j <= a.length; j++) {
                        if (b.charAt(i - 1) === a.charAt(j - 1)) {
                            matrix[i][j] = matrix[i - 1][j - 1];
                        } else {
                            matrix[i][j] = Math.min(
                                matrix[i - 1][j - 1] + 1,
                                matrix[i][j - 1] + 1,
                                matrix[i - 1][j] + 1
                            );
                        }
                    }
                }
                return matrix[b.length][a.length];
            }
            
            initializeLocalization();
            setupResponsiveControls();
            initGame();
        });
    </script>
</body>
</html>
