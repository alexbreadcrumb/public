<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    
    <!-- PWA & Icon Metadata -->
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">
    <meta name="theme-color" content="#1DB954">
    
    <title>Puzzletunes</title>
    <style>
        :root {
            --background: #121212;
            --surface: #1e1e1e;
            --primary: #1DB954;
            --primary-hover: #1ED760;
            --secondary: #8a2be2; /* Purple for "On this day" */
            --secondary-hover: #9932cc;
            --on-background: #FFFFFF;
            --on-surface: #E0E0E0;
            --on-surface-secondary: #B3B3B3;
            --danger-color: #ff4d4d;
            --danger-hover-color: #ff6666;
            --shadow-color: rgba(0, 0, 0, 0.5);
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            --gradient-color-1: #1DB954;
            --gradient-color-2: #1ED760;
            --gradient-color-3: #FFFFFF;
            --gradient-color-4: #1DB954;
            --gradient-color-5: #1ED760;
            --gold-bg: rgba(255, 215, 0, 0.15);
            --silver-bg: rgba(192, 192, 192, 0.15);
            --bronze-bg: rgba(205, 127, 50, 0.15);
        }

        html {
            height: 100%;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--background);
            color: var(--on-background);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 1rem;
            padding-top: 6rem; /* Adjusted for taller top-bar */
            box-sizing: border-box;
            min-height: 100vh;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: var(--bg-image, none);
            background-size: cover;
            background-position: center;
            filter: blur(30px) brightness(0.4);
            transform: scale(1.1);
            z-index: -2;
            opacity: var(--bg-opacity, 0);
            transition: opacity 0.7s ease-in-out;
            will-change: opacity, background-image;
        }

        #idle-background-collage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -3;
            opacity: 0;
            transition: opacity 0.7s ease-in-out;
            overflow: hidden;
        }
        #idle-background-collage.visible {
            opacity: 1;
        }
        .collage-layer {
            position: absolute;
            background-size: cover;
            background-position: center;
            filter: blur(5px) brightness(0.5);
            transform: scale(1.1);
        }
        #collage-1 { top: -10%; left: -10%; width: 60%; height: 60%; }
        #collage-2 { top: -5%; right: -15%; width: 70%; height: 50%; }
        #collage-3 { bottom: -15%; left: 20%; width: 40%; height: 60%; }
        #collage-4 { bottom: -10%; right: -10%; width: 65%; height: 65%; }
        #collage-5 { top: 30%; left: -20%; width: 55%; height: 55%; }
        #collage-6 { top: 50%; right: -20%; width: 50%; height: 50%; opacity: 0.8; }
        #collage-7 { bottom: -20%; left: -15%; width: 60%; height: 45%; opacity: 0.9; }
        #collage-8 { top: 65%; left: 45%; width: 40%; height: 40%; transform: translateX(-50%); opacity: 0.85; }
        #collage-9 { top: 10%; left: 50%; width: 35%; height: 35%;}
        #collage-10 { bottom: 5%; right: 50%; width: 30%; height: 30%; }

        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: var(--surface);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            box-sizing: border-box;
            z-index: 100;
            box-shadow: 0 4px 12px var(--shadow-color);
        }
        
        .stats-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 0.25rem;
        }
        
        .stats-group, .controls-group {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        #player-name-display {
            font-size: 0.8rem;
            color: var(--on-surface);
            background-color: rgba(255, 255, 255, 0.05);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-weight: 500;
        }

        .main-container {
            width: 100%;
            max-width: 480px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            flex-grow: 1;
        }
        
        @media (max-height: 740px) {
            .main-container {
                gap: 0.5rem;
            }
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            color: var(--on-surface);
        }
        
        .stat-item svg {
            width: 20px;
            height: 20px;
            fill: var(--on-surface-secondary);
        }

        .control-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }
        .control-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background-color: transparent !important;
        }
        .control-button:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .control-button svg {
            width: 24px;
            height: 24px;
            fill: var(--on-surface);
        }

        .puzzle-container {
            width: 95%;
            margin: 0 auto;
            aspect-ratio: 1 / 1;
            position: relative;
            background-color: transparent;
            border-radius: 12px;
            box-shadow: 0 8px 24px var(--shadow-color);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            padding: 2px;
            box-sizing: border-box;
            z-index: 1;
            transform-style: preserve-3d;
        }
        
        .puzzle-container.intro-animation-active {
            perspective: 1000px;
        }

        @keyframes gradient-flow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .puzzle-container.animated-gradient-border::before {
            content: '';
            position: absolute;
            inset: -5px;
            z-index: -1;
            background: linear-gradient(45deg,
                var(--gradient-color-1),
                var(--gradient-color-2),
                var(--gradient-color-3),
                var(--gradient-color-4),
                var(--gradient-color-5),
                var(--gradient-color-1)
            );
            background-size: 400% 400%;
            animation: gradient-flow 8s ease infinite;
            border-radius: 16px; 
            filter: blur(20px);
        }
        
        .puzzle-container.idle-mode::after {
            content: '';
            position: absolute;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.65);
            z-index: 3;
            border-radius: 12px;
            pointer-events: none;
        }

        .idle-call-to-action {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            font-weight: 600;
            text-align: center;
            padding: 1rem;
            z-index: 4;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            width: 80%;
        }


        .puzzle-piece {
            width: 100%;
            height: 100%;
            background-size: 300% 300%;
            transition: transform 0.2s ease-in-out, top 0.15s ease-in-out, left 0.15s ease-in-out;
            cursor: pointer;
            visibility: visible;
            border-radius: 4px;
            position: relative;
            z-index: 2;
        }
        .puzzle-piece.empty {
            visibility: hidden;
            cursor: default;
        }
        .puzzle-piece:not(.empty):hover {
            transform: scale(0.95);
            opacity: 0.9;
        }
        
        /* --- Intro & Swirl Animation Styles --- */
        .puzzle-piece-intro {
            transform-style: preserve-3d;
            transform: translateY(120%) translateZ(-300px) rotateX(-90deg);
            opacity: 0;
            transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.5s ease-out;
            will-change: transform, opacity;
        }
        .puzzle-piece-intro.visible {
            transform: translateY(0) translateZ(0) rotateX(0);
            opacity: 1;
        }
        #start-game-btn {
            background-color: var(--primary);
            color: var(--background);
            font-weight: 700;
            border-radius: 50px;
            padding: 1rem 2rem;
            font-size: 1.2rem;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            transform: scale(0);
            animation: pop-in 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        #start-game-btn:hover {
            background-color: var(--primary-hover);
            transform: scale(1.05);
        }
        @keyframes pop-in {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        @keyframes swirl-out {
            0% {
                transform: rotate(0deg) scale(1);
                opacity: 1;
            }
            100% {
                transform: rotate(720deg) scale(0);
                opacity: 0;
            }
        }
        .puzzle-container.swirl-animation {
            animation: swirl-out 0.8s cubic-bezier(0.6, -0.28, 0.735, 0.045) forwards;
        }
        /* --- End Animation Styles --- */


        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 1.2rem;
            font-weight: 600;
            z-index: 10;
            padding: 1rem;
            border-radius: 12px; /* Ensure overlay fits inside container */
        }
        
        .overlay h2 {
            font-size: 1.8rem;
            margin: 0 0 0.5rem 0;
        }

        .overlay p {
            margin: 0.25rem 0;
        }
        
        .win-stats {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            margin-bottom: 1.5rem;
        }

        .suggestions-container {
            margin-top: 1rem;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .suggestion-btn {
            background-color: var(--primary);
            color: var(--background);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s ease;
        }
        .suggestion-btn:hover {
            background-color: var(--primary-hover);
        }

        .share-btn {
            background-color: var(--primary);
            color: var(--background);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background-color 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        .share-btn:hover {
            background-color: var(--primary-hover);
        }
        .share-btn:disabled {
            background-color: #555;
            cursor: wait;
        }
        .share-btn svg {
            width: 20px;
            height: 20px;
            fill: var(--background);
        }

        .current-track-info {
            text-align: center;
            padding: 0 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        .current-track-info h2 {
            font-size: 1.1rem;
            margin: 0;
            color: var(--on-surface);
        }
        .current-track-info p {
            font-size: 0.9rem;
            margin: 0.25rem 0 0;
            color: var(--on-surface-secondary);
        }
        
        #track-links {
            display: flex;
            gap: 1rem;
            margin-top: 0.25rem;
        }

        .track-link-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease;
        }
        .track-link-btn:hover {
            transform: scale(1.1);
        }
        .track-link-btn svg {
            width: 28px;
            height: 28px;
            fill: var(--on-surface-secondary);
        }

        .new-game-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            width: 100%;
        }
        
        #artist-search-desktop, #artist-search-mobile {
            flex-grow: 1;
            background-color: var(--surface);
            border: 1px solid var(--on-surface-secondary);
            border-radius: 50px;
            padding: 0.75rem 1rem;
            font-size: 1rem;
            color: var(--on-background);
            min-width: 0;
        }
        
        .action-buttons {
            display: flex;
            gap: 0.5rem;
        }

        #new-game-btn-desktop, #new-game-btn-mobile, #restart-game-btn-desktop, #restart-game-btn-mobile, #on-this-day-btn-desktop, #on-this-day-btn-mobile {
            color: var(--background);
            font-weight: 700;
            border-radius: 50px;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease, box-shadow 0.4s ease, color 0.2s ease;
            white-space: nowrap;
        }

        #new-game-btn-desktop, #new-game-btn-mobile {
             background-color: var(--primary);
        }
        #new-game-btn-desktop:hover, #new-game-btn-mobile:hover {
            background-color: var(--primary-hover);
        }
        
        #on-this-day-btn-desktop, #on-this-day-btn-mobile {
            background-color: var(--secondary);
            color: var(--on-background);
        }
        #on-this-day-btn-desktop:hover, #on-this-day-btn-mobile:hover {
            background-color: var(--secondary-hover);
        }

        #restart-game-btn-desktop, #restart-game-btn-mobile {
            background-color: transparent;
            border: 2px solid var(--primary);
            color: var(--primary);
        }
        #restart-game-btn-desktop:hover, #restart-game-btn-mobile:hover {
            background-color: var(--primary);
            color: var(--background);
        }

        @keyframes neon-pulse {
            0%, 100% {
                box-shadow: 0 0 5px var(--primary), 0 0 10px var(--primary), 0 0 15px var(--primary-hover);
            }
            50% {
                box-shadow: 0 0 10px var(--primary-hover), 0 0 20px var(--primary-hover), 0 0 30px var(--primary);
            }
        }
        @keyframes neon-pulse-secondary {
            0%, 100% {
                box-shadow: 0 0 5px var(--secondary), 0 0 10px var(--secondary), 0 0 15px var(--secondary-hover);
            }
            50% {
                box-shadow: 0 0 10px var(--secondary-hover), 0 0 20px var(--secondary-hover), 0 0 30px var(--secondary);
            }
        }

        .pulsating-neon {
            animation: neon-pulse 2s ease-in-out infinite;
        }
        .pulsating-neon-secondary {
            animation: neon-pulse-secondary 2s ease-in-out infinite;
        }
        
        /* --- Responsive Controls Logic --- */

        .top-bar .desktop-controls {
            display: none;
        }

        .mobile-controls {
            flex-direction: column;
            gap: 0.75rem;
        }
        .mobile-controls #artist-search-mobile, .mobile-controls .action-buttons {
            width: 100%;
            box-sizing: border-box;
        }
        .mobile-controls .action-buttons {
            justify-content: center;
        }

        @media (min-width: 768px) {
            .mobile-controls {
                display: none;
            }
            .top-bar .desktop-controls {
                display: flex;
                flex-grow: 1;
                justify-content: center;
                align-items: center;
                gap: 1rem;
                margin: 0 2rem;
            }
            .desktop-controls #artist-search-desktop {
                width: 100%;
                max-width: 350px;
            }
            .desktop-controls #artist-search-desktop, .desktop-controls #new-game-btn-desktop, .desktop-controls #restart-game-btn-desktop, .desktop-controls #on-this-day-btn-desktop {
                padding-top: 0.5rem;
                padding-bottom: 0.5rem;
                font-size: 0.9rem;
            }
        }
        
        @media (max-height: 740px) {
             #artist-search-mobile, #new-game-btn-mobile, #restart-game-btn-mobile, #on-this-day-btn-mobile,
             #artist-search-desktop, #new-game-btn-desktop, #restart-game-btn-desktop, #on-this-day-btn-desktop {
                padding-top: 0.5rem;
                padding-bottom: 0.5rem;
                font-size: 0.9rem;
            }
        }

        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: var(--surface);
            padding: 1.5rem;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-header h2 {
            margin: 0;
            color: var(--on-surface);
        }
        .modal-header .close-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
        }
        .modal-header .close-btn svg {
            width: 24px;
            height: 24px;
            fill: var(--on-surface-secondary);
        }

        .modal-tabs {
            display: flex;
            border-bottom: 1px solid var(--on-surface-secondary);
            margin-bottom: 1rem;
        }
        .tab-btn {
            background: none;
            border: none;
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-bottom: -1px;
            transition: border-color 0.2s ease, color 0.2s ease;
            font-size: 1.5rem;
            line-height: 1;
            color: var(--on-surface-secondary);
        }
        .tab-btn:hover {
            color: var(--on-surface);
        }
        .tab-btn.active {
            border-bottom-color: var(--primary);
            color: var(--primary);
        }
        
        .modal-panels {
            flex-grow: 1;
            overflow-y: auto;
        }
        .modal-panel {
            display: none;
        }
        .modal-panel.active {
            display: block;
        }
        
        .language-options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .lang-btn {
            display: flex;
            align-items: center;
            gap: 1rem;
            background-color: rgba(255, 255, 255, 0.05);
            border: 2px solid transparent;
            padding: 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            text-align: left;
            color: var(--on-surface);
            transition: all 0.2s ease;
        }
        .lang-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .lang-btn.active {
            border-color: var(--primary);
            background-color: rgba(29, 185, 84, 0.1);
        }
        
        #info-panel p {
            line-height: 1.6;
            color: var(--on-surface);
        }

        /* --- Options Panel Sub-tabs --- */
        .options-sub-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid #444;
        }
        .options-sub-tab-btn {
            background: none;
            border: none;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
            font-size: 1.2rem;
            color: var(--on-surface-secondary);
        }
        .options-sub-tab-btn.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .options-sub-panel {
            display: none;
        }
        .options-sub-panel.active {
            display: block;
        }
        #options-panel h3 {
            margin-top: 0;
            margin-bottom: 0.75rem;
            color: var(--on-surface);
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .form-group input {
            background-color: #333;
            border: 1px solid var(--on-surface-secondary);
            border-radius: 8px;
            padding: 0.75rem;
            font-size: 1rem;
            color: var(--on-background);
        }
        .form-group button {
             background-color: var(--primary);
            color: var(--background);
            font-weight: 600;
            border-radius: 8px;
            padding: 0.75rem;
            font-size: 1rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .form-group button:hover {
            background-color: var(--primary-hover);
        }
        
        .danger-zone {
            padding: 1rem;
            border: 2px dashed var(--danger-color);
            border-radius: 8px;
            background-color: rgba(255, 77, 77, 0.05);
        }
        .danger-zone h3 {
            margin-top: 0;
            color: var(--danger-color);
        }
        #reset-game-btn {
            background-color: var(--danger-color);
            width: 100%;
        }
        #reset-game-btn:hover {
            background-color: var(--danger-hover-color);
        }
        #reset-game-warning {
            font-size: 0.8rem;
            color: var(--on-surface-secondary);
            margin-top: 0.5rem;
            text-align: center;
        }

        .genre-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .genre-tag {
            display: block;
        }
        .genre-tag input {
            display: none;
        }
        .genre-tag span {
            display: block;
            padding: 0.5rem 1rem;
            background-color: #333;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
            user-select: none;
        }
        .genre-tag input:checked + span {
            background-color: var(--primary);
            color: var(--background);
            font-weight: 600;
        }
        .genre-tag:hover span {
             background-color: #444;
        }
        .genre-tag input:checked:hover + span {
             background-color: var(--primary-hover);
        }

        .setting-switch {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            font-size: 1rem;
        }
        .switch {
          position: relative;
          display: inline-block;
          width: 60px;
          height: 34px;
        }
        .switch input { 
          opacity: 0;
          width: 0;
          height: 0;
        }
        .slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #ccc;
          transition: .4s;
        }
        .slider:before {
          position: absolute;
          content: "";
          height: 26px;
          width: 26px;
          left: 4px;
          bottom: 4px;
          background-color: white;
          transition: .4s;
        }
        input:checked + .slider {
          background-color: var(--primary);
        }
        input:focus + .slider {
          box-shadow: 0 0 1px var(--primary);
        }
        input:checked + .slider:before {
          transform: translateX(26px);
        }
        .slider.round {
          border-radius: 34px;
        }
        .slider.round:before {
          border-radius: 50%;
        }
        

        #total-playtime {
            text-align: center;
            margin-bottom: 1rem;
            font-size: 1.1rem;
            color: var(--on-surface);
        }

        #high-scores-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        #high-scores-list::-webkit-scrollbar { width: 5px; }
        #high-scores-list::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }
        #high-scores-list::-webkit-scrollbar-thumb { background: #555; border-radius: 5px; }

        .score-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            border-radius: 8px;
            background-color: rgba(0,0,0,0.2);
            margin-bottom: 0.5rem;
            transition: background-color 0.3s ease;
        }
        .score-item.gold { background-color: var(--gold-bg); }
        .score-item.silver { background-color: var(--silver-bg); }
        .score-item.bronze { background-color: var(--bronze-bg); }

        .score-rank {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--on-surface-secondary);
            width: 2rem;
            text-align: center;
            flex-shrink: 0;
        }
        .score-item:last-child { margin-bottom: 0; }
        .score-thumbnail {
            width: 60px;
            height: 60px;
            border-radius: 4px;
            object-fit: cover;
            flex-shrink: 0;
        }
        .score-info {
            flex-grow: 1;
            overflow: hidden;
        }
        .score-track {
            font-weight: 600;
            color: var(--on-surface);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: clip;
        }
        .score-artist {
            color: var(--on-surface-secondary);
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }
        .score-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.8rem;
            color: var(--on-surface-secondary);
        }
        
        .marquee-wrapper {
            overflow: hidden;
        }
        .marquee-content {
            display: inline-block;
            animation: marquee 10s linear infinite;
            animation-play-state: paused;
            padding-right: 2rem;
        }
        .marquee-wrapper:hover .marquee-content,
        .marquee-wrapper.animate .marquee-content {
            animation-play-state: running;
        }
        
        @media (hover: none) {
            .marquee-wrapper.animate .marquee-content {
                animation-play-state: running;
            }
        }
        
        @keyframes marquee {
            0% { transform: translateX(0%); }
            100% { transform: translateX(-100%); }
        }
        
        .score-delete-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
            flex-shrink: 0;
        }
        .score-delete-btn svg {
            width: 20px;
            height: 20px;
            fill: #ff4d4d;
        }
        
        /* --- Personal Best Notification Styles --- */
        .personal-best-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        .personal-best-overlay.visible {
            opacity: 1;
        }
        .personal-best-text {
            font-size: clamp(1.8rem, 5vw, 2.5rem);
            font-weight: 700;
            text-align: center;
            padding: 2rem;
            color: #fff;
            animation: pop-in 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            text-shadow:
                0 0 5px #fff,
                0 0 10px #fff,
                0 0 20px var(--gradient-color-1),
                0 0 30px var(--gradient-color-1),
                0 0 40px var(--gradient-color-2),
                0 0 50px var(--gradient-color-2);
        }

        #player-name-prompt {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--background);
            z-index: 3000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 2rem;
            box-sizing: border-box;
        }
        #player-name-prompt h2 {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        #player-name-form {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 300px;
            gap: 1rem;
        }
        #player-name-input {
            background-color: var(--surface);
            border: 1px solid var(--on-surface-secondary);
            border-radius: 50px;
            padding: 0.75rem 1rem;
            font-size: 1rem;
            color: var(--on-background);
            text-align: center;
        }
        #save-player-name-btn {
            background-color: var(--primary);
            color: var(--background);
            font-weight: 700;
            border-radius: 50px;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }


        footer {
            width: 100%;
            text-align: center;
            padding: 0.5rem;
            font-size: 0.8rem;
            color: var(--on-surface-secondary);
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            position: relative; /* Changed from absolute to relative for flow */
        }
        #footer-title {
            font-weight: 700;
            color: var(--primary);
            font-size: 1.2rem;
            position: relative;
            display: flex;
            justify-content: center;
            flex-wrap: nowrap;
            height: 1.5em; /* Reserve space */
        }
        #footer-title span {
            position: relative;
            display: inline-block;
            will-change: transform, opacity, left, top;
        }

    </style>
</head>
<body>
    <audio id="audio-player" crossorigin="anonymous" loop playsinline></audio>
    <div id="idle-background-collage">
        <div id="collage-1" class="collage-layer"></div>
        <div id="collage-2" class="collage-layer"></div>
        <div id="collage-3" class="collage-layer"></div>
        <div id="collage-4" class="collage-layer"></div>
        <div id="collage-5" class="collage-layer"></div>
        <div id="collage-6" class="collage-layer"></div>
        <div id="collage-7" class="collage-layer"></div>
        <div id="collage-8" class="collage-layer"></div>
        <div id="collage-9" class="collage-layer"></div>
        <div id="collage-10" class="collage-layer"></div>
    </div>

    <div id="player-name-prompt" style="display: none;">
        <h2 data-translate-key="playerNamePromptTitle"></h2>
        <form id="player-name-form">
            <input type="text" id="player-name-input" required minlength="1">
            <button type="submit" id="save-player-name-btn" data-translate-key="saveNameButton"></button>
        </form>
    </div>

    <div class="top-bar">
        <div class="stats-container">
            <div class="stats-group">
                <div class="stat-item">
                    <svg viewBox="0 0 24 24"><path d="M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10 10-4.486 10-10S17.514 2 12 2zm0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8z"></path><path d="M13 7h-2v5.414l3.293 3.293 1.414-1.414L13 11.586V7z"></path></svg>
                    <span id="timer">00:00</span>
                </div>
                <div class="stat-item">
                    <svg viewBox="0 0 24 24"><path d="M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6.9-4.9.9-1-2.8-2.8-.9 1c-.4-.3-1-.5-1.5-.5H14v2h.6c.2 0 .5.1.7.3l.9.9v.6h2v-1.5c0-.5-.2-1.1-.5-1.5zm-13 0c-.3.4-.5.9-.5 1.5v1.5h2V6.4l.9-.9c.2-.2.4-.3.7-.3H8V4H7.5c-.5 0-1.1.2-1.6.5l-.9-1-2.8 2.8.9 1zm12.6 9.4-.9 1c.4.3 1 .5 1.5.5H18v2h-.5c-.2 0-.5-.1-.7-.3l-.9-.9v-.6h-2v1.5c0 .5.2 1.1.5 1.5l.9 1 2.8 2.8.9-1c.3-.4.5-.9.5-1.5v-1.5h-2v.6zm-11.8 0h-2v1.5c0 .5.2 1.1.5 1.5l.9 1 2.8 2.8.9-1c.4-.3 1-.5 1.5-.5H10v-2h-.6c-.2 0-.5.1-.7-.3l-.9-.9v-.6h-2v.6z"></path></svg>
                    <span id="moves">0</span>
                </div>
            </div>
            <div id="player-name-display"></div>
        </div>
        
        <div class="new-game-controls desktop-controls">
            <input type="text" id="artist-search-desktop" data-translate-placeholder="artistSearchPlaceholder">
            <div class="action-buttons">
                <button id="on-this-day-btn-desktop" data-translate-key="onThisDayButton" style="display: none;"></button>
                <button id="new-game-btn-desktop" data-translate-key="newGame"></button>
                <button id="restart-game-btn-desktop" data-translate-key="restartGame" style="display: none;"></button>
            </div>
        </div>

        <div class="controls-group">
            <button id="pause-btn" class="control-button" data-translate-title="pauseResumeTitle">
                <svg id="pause-icon" viewBox="0 0 24 24"><path d="M8 7h3v10H8zm5 0h3v10h-3z"></path></svg>
                <svg id="play-icon" viewBox="0 0 24 24" style="display: none;"><path d="M7 6v12l10-6z"></path></svg>
            </button>
            <button id="audio-btn" class="control-button" data-translate-title="toggleSoundTitle" disabled>
                <svg id="unmute-icon" viewBox="0 0 24 24" style="display:none;"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"></path></svg>
                <svg id="mute-icon" viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"></path></svg>
            </button>
            <button id="menu-btn" class="control-button" data-translate-title="menuTitle">
                <svg viewBox="0 0 24 24"><path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"></path></svg>
            </button>
        </div>
    </div>

    <div class="main-container">
        <div class="puzzle-container" id="puzzle-container"></div>
        <div class="current-track-info" id="current-track-info">
            <div id="track-text"></div>
            <div id="track-links">
                <a id="apple-music-link" href="#" target="_blank" class="track-link-btn" style="display: none;" title="Listen on Apple Music">
                    <svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-8z"></path></svg>
                </a>
                <a id="spotify-link" href="#" target="_blank" class="track-link-btn" style="display: none;" title="Listen on Spotify">
                    <svg viewBox="0 0 24 24"><path d="M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10 10-4.486 10-10S17.514 2 12 2zm4.183 14.123c-.246.332-.703.43-1.035.183-2.76-1.683-6.22-1.95-10.387-1.02a.662.662 0 0 1-.728-.642c-.01-.36.26-.67.62-.73 4.58-1.02 8.35-.71 11.4 1.18.33.2.43.66.18 1.03zm.88-2.32c-.3.402-.84.522-1.24.222-3.09-1.89-7.73-2.43-11.45-1.32a.803.803 0 0 1-.92-.782c-.01-.44.32-.82.75-.88 4.18-1.21 9.24-.62 12.72 1.54.4.24.52.78.22 1.22zm.08-2.58c-3.53-2.08-9.43-2.28-13.3-1.25a.965.965 0 0 1-1.1-.943c-.02-.52.4-.98.92-1.04 4.3-.92 10.79-.72 14.8 1.58.48.28.64.88.35 1.36-.28.48-.88.64-1.36.35z"></path></svg>
                </a>
            </div>
        </div>

        <div class="new-game-controls mobile-controls">
            <input type="text" id="artist-search-mobile" data-translate-placeholder="artistSearchPlaceholder">
            <div class="action-buttons">
                <button id="on-this-day-btn-mobile" data-translate-key="onThisDayButton" style="display: none;"></button>
                <button id="new-game-btn-mobile" data-translate-key="newGame"></button>
                <button id="restart-game-btn-mobile" data-translate-key="restartGame" style="display: none;"></button>
            </div>
        </div>
    </div>
    
    <div id="menu-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title" data-translate-key="highScoresTitle"></h2>
                <button class="close-btn" id="close-menu-btn">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
                </button>
            </div>
            <div class="modal-tabs">
                <button class="tab-btn active" data-tab="records">üèÜ</button>
                <button class="tab-btn" data-tab="language">üè≥Ô∏è</button>
                <button class="tab-btn" data-tab="options">‚öôÔ∏è</button>
                <button class="tab-btn" data-tab="info">‚ÑπÔ∏è</button>
            </div>
            <div class="modal-panels">
                <div id="records-panel" class="modal-panel active">
                    <p id="total-playtime"></p>
                    <ol id="high-scores-list"></ol>
                </div>
                <div id="language-panel" class="modal-panel">
                    <div class="language-options">
                        <button class="lang-btn" data-lang="en"><span>üá∫üá∏</span> <span data-translate-key="langEnglish"></span></button>
                        <button class="lang-btn" data-lang="es"><span>üá™üá∏</span> <span data-translate-key="langSpanish"></span></button>
                        <button class="lang-btn" data-lang="pt"><span>üáßüá∑</span> <span data-translate-key="langPortuguese"></span></button>
                        <button class="lang-btn" data-lang="fr"><span>üá´üá∑</span> <span data-translate-key="langFrench"></span></button>
                    </div>
                </div>
                <div id="options-panel" class="modal-panel">
                    <div class="options-sub-tabs">
                         <button class="options-sub-tab-btn active" data-sub-tab="player">ü¶∏‚Äç‚ôÇÔ∏è</button>
                         <button class="options-sub-tab-btn" data-sub-tab="genres">üéµ</button>
                         <button class="options-sub-tab-btn" data-sub-tab="on-this-day">üóìÔ∏è</button>
                         <button class="options-sub-tab-btn" data-sub-tab="reset">üß©</button>
                    </div>
                    <div class="options-sub-panels">
                        <div id="player-sub-panel" class="options-sub-panel active">
                            <h3 data-translate-key="editPlayerNameTitle"></h3>
                            <div class="form-group">
                                <input type="text" id="edit-player-name-input">
                                <button id="save-edited-player-name-btn" data-translate-key="saveNameButton"></button>
                            </div>
                        </div>
                        <div id="genres-sub-panel" class="options-sub-panel">
                            <h3 data-translate-key="favoriteGenresTitle"></h3>
                            <div id="genre-selector" class="genre-selector"></div>
                        </div>
                        <div id="on-this-day-sub-panel" class="options-sub-panel">
                            <h3 data-translate-key="onThisDayTitle"></h3>
                            <div class="setting-switch">
                                <span data-translate-key="onThisDayEnable"></span>
                                <label class="switch">
                                    <input type="checkbox" id="on-this-day-toggle">
                                    <span class="slider round"></span>
                                </label>
                            </div>
                        </div>
                        <div id="reset-sub-panel" class="options-sub-panel">
                             <div class="danger-zone">
                                <h3 data-translate-key="resetGameTitle"></h3>
                                <button id="reset-game-btn" data-translate-key="resetGameButton"></button>
                                <p id="reset-game-warning" data-translate-key="resetGameWarning"></p>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="info-panel" class="modal-panel">
                    <p data-translate-key="aboutGameText"></p>
                </div>
            </div>
        </div>
    </div>
    
    <footer id="footer">
        <div id="footer-title"></div>
        <div id="credits"><span data-translate-key="gameBy"></span> Ale Fern√°ndez PY-2025 - v2.07</div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.0/color-thief.umd.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const SIZE = 3;
            const elements = {
                puzzleContainer: document.getElementById('puzzle-container'),
                timer: document.getElementById('timer'),
                moves: document.getElementById('moves'),
                pauseBtn: document.getElementById('pause-btn'),
                audioBtn: document.getElementById('audio-btn'),
                menuBtn: document.getElementById('menu-btn'),
                trackInfo: document.getElementById('current-track-info'),
                trackText: document.getElementById('track-text'),
                appleMusicLink: document.getElementById('apple-music-link'),
                spotifyLink: document.getElementById('spotify-link'),
                audioPlayer: document.getElementById('audio-player'),
                pauseIcon: document.getElementById('pause-icon'),
                playIcon: document.getElementById('play-icon'),
                muteIcon: document.getElementById('mute-icon'),
                unmuteIcon: document.getElementById('unmute-icon'),
                menuModal: document.getElementById('menu-modal'),
                closeMenuBtn: document.getElementById('close-menu-btn'),
                modalTitle: document.getElementById('modal-title'),
                highScoresList: document.getElementById('high-scores-list'),
                idleCollage: document.getElementById('idle-background-collage'),
                gameTitle: document.getElementById('footer-title'),
                playerNamePrompt: document.getElementById('player-name-prompt'),
                playerNameForm: document.getElementById('player-name-form'),
                playerNameInput: document.getElementById('player-name-input'),
                playerNameDisplay: document.getElementById('player-name-display'),
                editPlayerNameInput: document.getElementById('edit-player-name-input'),
                saveEditedPlayerNameBtn: document.getElementById('save-edited-player-name-btn'),
                resetGameBtn: document.getElementById('reset-game-btn'),
                optionsPanel: document.getElementById('options-panel'),
                footer: document.getElementById('footer'),
                credits: document.getElementById('credits'),

                // Responsive Controls
                artistSearchDesktop: document.getElementById('artist-search-desktop'),
                newGameBtnDesktop: document.getElementById('new-game-btn-desktop'),
                restartGameBtnDesktop: document.getElementById('restart-game-btn-desktop'),
                onThisDayBtnDesktop: document.getElementById('on-this-day-btn-desktop'),
                artistSearchMobile: document.getElementById('artist-search-mobile'),
                newGameBtnMobile: document.getElementById('new-game-btn-mobile'),
                restartGameBtnMobile: document.getElementById('restart-game-btn-mobile'),
                onThisDayBtnMobile: document.getElementById('on-this-day-btn-mobile'),
            };

            let state = {
                pieces: [],
                moves: 0,
                time: 0,
                timerInterval: null,
                isPaused: true,
                isMuted: true,
                currentAlbum: null,
                gameInProgress: false,
                isIdle: false, // For controlling the idle animation
            };

            const PROXIES = [
                'https://cors.eu.org/',
                'https://cors-anywhere.poldisoft.com/',
                'https://thingproxy.freeboard.io/fetch/'
            ];
            
            const colorThief = new ColorThief();

            // --- I18n & Translation ---
            const ALL_GENRES = ['rock', 'pop', 'jazz', 'classical', 'electronic', 'hiphop', 'reggae', 'metal', 'soul', 'funk', 'latin', 'country', 'blues', 'alternative', 'reggaeton', 'cumbia', 'numetal', 'kpop', 'jpop', 'folk', 'indie'];
            const translations = {
                es: {
                    pageTitle: "Puzzletunes",
                    pauseResumeTitle: "Pausar/Reanudar",
                    toggleSoundTitle: "Activar/Desactivar Sonido",
                    menuTitle: "Men√∫",
                    highScoresTitle: "Mejores Tiempos",
                    languageTitle: "Idioma",
                    optionsTitle: "Opciones",
                    aboutTitle: "Acerca de",
                    artistSearchPlaceholder: "Buscar por artista (opcional)",
                    newGame: "Nuevo Juego",
                    gameBy: "Juego por:",
                    winMessage: "¬°Ganaste!",
                    winTime: "Tiempo: {time}",
                    winMoves: "Movimientos: {moves}",
                    paused: "Pausado",
                    startMessage: "Haz clic en 'Nuevo Juego' para empezar",
                    loadingNewGame: "Cargando partida nueva...",
                    randomArtist: "-artista aleatorio-",
                    searchingForArtist: "-buscando a: {searchTerm}-",
                    didYouMean: "Quisiste decir:",
                    imageError: "Error al cargar la imagen. Por favor, intenta de nuevo.",
                    noMusicFoundFor: "No se encontr√≥ m√∫sica para \"{searchTerm}\"",
                    noRandomMusic: "No se encontr√≥ m√∫sica aleatoria. Por favor, intenta de nuevo.",
                    loadSavedImageError: "Error al cargar la imagen guardada.",
                    newGameConfirm: "¬øSeguro que quieres empezar un nuevo juego? Tu progreso se perder√°.",
                    deleteRecordTitle: "Eliminar r√©cord",
                    movesSuffix: "mov.",
                    langEnglish: "Ingl√©s",
                    langSpanish: "Espa√±ol",
                    langPortuguese: "Portugu√™s",
                    langFrench: "Franc√©s",
                    aboutGameText: "¬øSab√≠as que un estudio publicado en Frontiers in Psychology (Montag & Hegelich, 2021) demostr√≥ que el uso excesivo de redes como Instagram y TikTok activa descargas r√°pidas de dopamina, lo que reduce la capacidad de concentraci√≥n y nos vuelve m√°s impacientes? La buena noticia es que pod√©s entrenar tu mente de una forma simple y entretenida: con Puzzletunes, un puzzle digital de 3√ó3 que exige mantener la atenci√≥n y ofrece la recompensa solo al completarlo. Jugar unos minutos al d√≠a se convierte en tu ‚Äúgimnasio mental‚Äù para fortalecer el foco, la paciencia y el autocontrol mientras te diviertes rearmando portadas musicales.",
                    totalPlaytimeText: "Llevas un total de <strong>{time}</strong> en partidas ganadas.",
                    hours_plural: "horas", hour_singular: "hora",
                    minutes_plural: "minutos", minute_singular: "minuto",
                    seconds_plural: "segundos", second_singular: "segundo",
                    andConnector: "y",
                    startButton: "Empezar",
                    newTopRecord: "¬°Has logrado un nuevo r√©cord personal en la posici√≥n {rank}!",
                    shareResultTitle: "Compartir Resultado",
                    shareMessage: "¬°{playerName} te desaf√≠a! a resolver el puzzle de {artist} - {album} en menos de {time} y {moves} movimientos en Puzzletunes.",
                    shareImageGenerating: "Generando imagen...",
                    favoriteGenresTitle: "G√©neros favoritos",
                    genreAll: "Todos",
                    rock: "Rock", pop: "Pop", jazz: "Jazz", classical: "Cl√°sica", electronic: "Electr√≥nica", hiphop: "Hip-Hop", reggae: "Reggae", metal: "Metal", soul: "Soul", funk: "Funk", latin: "Latina", country: "Country", blues: "Blues", alternative: "Alternativa", reggaeton: "Reggaeton", cumbia: "Cumbia", numetal: "Nu Metal", kpop: "K-Pop", jpop: "J-Pop", folk: "Folk", indie: "Indie",
                    idleCallToAction: "Toca 'Nuevo Juego' para iniciar una partida...",
                    playerNamePromptTitle: "Elige tu nombre de jugador",
                    playerNamePlaceholder: "Tu nombre aqu√≠...",
                    saveNameButton: "Guardar",
                    playerNameLabel: "Jugador:",
                    editPlayerNameTitle: "Cambiar nombre de jugador",
                    resetGameTitle: "Resetear Puzzletunes",
                    resetGameButton: "Resetear Juego",
                    resetGameWarning: "Esto eliminar√° todos tus r√©cords, tiempo total y nombre de jugador. Esta acci√≥n no se puede deshacer.",
                    resetConfirm: "¬øEst√°s seguro de que quieres resetear el juego?",
                    emptyNameError: "El nombre no puede estar vac√≠o.",
                    restartGame: "Reiniciar",
                    restartConfirm: "¬øSeguro que quieres reiniciar este puzzle?",
                    onThisDayTitle: "Un d√≠a como hoy",
                    onThisDayButton: "Un d√≠a como hoy...",
                    onThisDayEnable: "Activar funci√≥n 'Un d√≠a como hoy'",
                    noOnThisDayMusic: "No se encontr√≥ m√∫sica lanzada en un d√≠a como hoy. ¬°Intenta ma√±ana!",
                    randomButton: "Aleatorio",
                    randomModeButton: "Modo Aleatorio",
                    artistModeButton: "Modo Artista",
                    idleCallToActionWithOnThisDay: "Toca 'Un d√≠a como hoy' o 'Aleatorio' para iniciar una partida...",
                    idleCallToActionWithoutOnThisDay: "Toca 'Modo Aleatorio' para iniciar una partida..."
                },
                en: {
                    pageTitle: "Puzzletunes",
                    pauseResumeTitle: "Pause/Resume",
                    toggleSoundTitle: "Toggle Sound",
                    menuTitle: "Menu",
                    highScoresTitle: "High Scores",
                    languageTitle: "Language",
                    optionsTitle: "Options",
                    aboutTitle: "About",
                    artistSearchPlaceholder: "Search by artist (optional)",
                    newGame: "New Game",
                    gameBy: "Game by:",
                    winMessage: "You Win!",
                    winTime: "Time: {time}",
                    winMoves: "Moves: {moves}",
                    paused: "Paused",
                    startMessage: "Click 'New Game' to start",
                    loadingNewGame: "Loading new game...",
                    randomArtist: "-random artist-",
                    searchingForArtist: "-searching for: {searchTerm}-",
                    didYouMean: "Did you mean:",
                    imageError: "Error loading image. Please try again.",
                    noMusicFoundFor: "No music found for \"{searchTerm}\"",
                    noRandomMusic: "No random music found. Please try again.",
                    loadSavedImageError: "Error loading saved image.",
                    newGameConfirm: "Are you sure you want to start a new game? Your progress will be lost.",
                    deleteRecordTitle: "Delete record",
                    movesSuffix: "moves",
                    langEnglish: "English",
                    langSpanish: "Spanish",
                    langPortuguese: "Portuguese",
                    langFrench: "French",
                    aboutGameText: "Did you know that a study published in Frontiers in Psychology (Montag & Hegelich, 2021) showed that excessive use of networks like Instagram and TikTok triggers rapid dopamine releases, reducing concentration and making us more impatient? The good news is you can train your mind in a simple and entertaining way: with Puzzletunes, a 3x3 digital puzzle that demands sustained attention and offers the reward only upon completion. Playing a few minutes a day becomes your 'mental gym' to strengthen focus, patience, and self-control while having fun reassembling music covers.",
                    totalPlaytimeText: "You have a total of <strong>{time}</strong> in won games.",
                    hours_plural: "hours", hour_singular: "hour",
                    minutes_plural: "minutes", minute_singular: "minute",
                    seconds_plural: "seconds", second_singular: "second",
                    andConnector: "and",
                    startButton: "Start",
                    newTopRecord: "You've achieved a new personal best at rank {rank}!",
                    shareResultTitle: "Share Result",
                    shareMessage: "{playerName} challenges you! to solve the {artist} - {album} puzzle in less than {time} and {moves} moves on Puzzletunes.",
                    shareImageGenerating: "Generating image...",
                    favoriteGenresTitle: "Favorite Genres",
                    genreAll: "All",
                    rock: "Rock", pop: "Pop", jazz: "Jazz", classical: "Classical", electronic: "Electronic", hiphop: "Hip-Hop", reggae: "Reggae", metal: "Metal", soul: "Soul", funk: "Funk", latin: "Latin", country: "Country", blues: "Blues", alternative: "Alternative", reggaeton: "Reggaeton", cumbia: "Cumbia", numetal: "Nu Metal", kpop: "K-Pop", jpop: "J-Pop", folk: "Folk", indie: "Indie",
                    idleCallToAction: "Tap 'New Game' to start a match...",
                    playerNamePromptTitle: "Choose your player name",
                    playerNamePlaceholder: "Your name here...",
                    saveNameButton: "Save",
                    playerNameLabel: "Player:",
                    editPlayerNameTitle: "Change player name",
                    resetGameTitle: "Reset Puzzletunes",
                    resetGameButton: "Reset Game",
                    resetGameWarning: "This will delete all your records, total playtime, and player name. This action cannot be undone.",
                    resetConfirm: "Are you sure you want to reset the game?",
                    emptyNameError: "Name cannot be empty.",
                    restartGame: "Restart",
                    restartConfirm: "Are you sure you want to restart this puzzle?",
                    onThisDayTitle: "On This Day",
                    onThisDayButton: "On This Day...",
                    onThisDayEnable: "Enable 'On This Day' feature",
                    noOnThisDayMusic: "No music found released on this day. Try again tomorrow!",
                    randomButton: "Random",
                    randomModeButton: "Random Mode",
                    artistModeButton: "Artist Mode",
                    idleCallToActionWithOnThisDay: "Tap 'On This Day' or 'Random' to start a match...",
                    idleCallToActionWithoutOnThisDay: "Tap 'Random Mode' to start a match..."
                },
                pt: {
                    pageTitle: "Puzzletunes",
                    pauseResumeTitle: "Pausar/Retomar",
                    toggleSoundTitle: "Ativar/Desativar Som",
                    menuTitle: "Menu",
                    highScoresTitle: "Melhores Tempos",
                    languageTitle: "Idioma",
                    optionsTitle: "Op√ß√µes",
                    aboutTitle: "Sobre",
                    artistSearchPlaceholder: "Pesquisar por artista (opcional)",
                    newGame: "Novo Jogo",
                    gameBy: "Jogo por:",
                    winMessage: "Voc√™ Venceu!",
                    winTime: "Tempo: {time}",
                    winMoves: "Movimentos: {moves}",
                    paused: "Pausado",
                    startMessage: "Clique em 'Novo Jogo' para come√ßar",
                    loadingNewGame: "Carregando novo jogo...",
                    randomArtist: "-artista aleat√≥rio-",
                    searchingForArtist: "-procurando por: {searchTerm}-",
                    didYouMean: "Voc√™ quis dizer:",
                    imageError: "Erro ao carregar a imagem. Por favor, tente novamente.",
                    noMusicFoundFor: "Nenhuma m√∫sica encontrada para \"{searchTerm}\"",
                    noRandomMusic: "Nenhuma m√∫sica aleat√≥ria encontrada. Por favor, tente novamente.",
                    loadSavedImageError: "Erro ao carregar a imagem salva.",
                    newGameConfirm: "Tem certeza que deseja iniciar um novo jogo? Seu progresso ser√° perdido.",
                    deleteRecordTitle: "Excluir recorde",
                    movesSuffix: "mov.",
                    langEnglish: "Ingl√™s",
                    langSpanish: "Espanhol",
                    langPortuguese: "Portugu√™s",
                    langFrench: "Franc√™s",
                    aboutGameText: "Voc√™ sabia que um estudo publicado na Frontiers in Psychology (Montag & Hegelich, 2021) demonstrou que o uso excessivo de redes como Instagram e TikTok ativa libera√ß√µes r√°pidas de dopamina, o que reduz a capacidade de concentra√ß√£o e nos torna mais impacientes? A boa not√≠cia √© que voc√™ pode treinar sua mente de uma forma simples e divertida: com o Puzzletunes, um quebra-cabe√ßa digital 3x3 que exige aten√ß√£o cont√≠nua e oferece a recompensa apenas ao ser completado. Jogar alguns minutos por dia se torna sua 'academia mental' para fortalecer o foco, a paci√™ncia e o autocontrole enquanto voc√™ se diverte remontando capas de √°lbuns.",
                    totalPlaytimeText: "Voc√™ tem um total de <strong>{time}</strong> em jogos ganhos.",
                    hours_plural: "horas", hour_singular: "hora",
                    minutes_plural: "minutos", minute_singular: "minuto",
                    seconds_plural: "segundos", second_singular: "segundo",
                    andConnector: "e",
                    startButton: "Come√ßar",
                    newTopRecord: "Voc√™ alcan√ßou um novo recorde pessoal na posi√ß√£o {rank}!",
                    shareResultTitle: "Compartilhar Resultado",
                    shareMessage: "{playerName} te desafia! a resolver o quebra-cabe√ßa de {artist} - {album} em menos de {time} e {moves} movimentos no Puzzletunes.",
                    shareImageGenerating: "Gerando imagem...",
                    favoriteGenresTitle: "G√™neros favoritos",
                    genreAll: "Todos",
                    rock: "Rock", pop: "Pop", jazz: "Jazz", classical: "Cl√°ssica", electronic: "Eletr√¥nica", hiphop: "Hip-Hop", reggae: "Reggae", metal: "Metal", soul: "Soul", funk: "Funk", latin: "Latina", country: "Country", blues: "Blues", alternative: "Alternativa", reggaeton: "Reggaeton", cumbia: "Cumbia", numetal: "Nu Metal", kpop: "K-Pop", jpop: "J-Pop", folk: "Folk", indie: "Indie",
                    idleCallToAction: "Toque em 'Novo Jogo' para iniciar uma partida...",
                    playerNamePromptTitle: "Escolha seu nome de jogador",
                    playerNamePlaceholder: "Seu nome aqui...",
                    saveNameButton: "Salvar",
                    playerNameLabel: "Jogador:",
                    editPlayerNameTitle: "Mudar nome de jogador",
                    resetGameTitle: "Resetar Puzzletunes",
                    resetGameButton: "Resetar Jogo",
                    resetGameWarning: "Isso excluir√° todos os seus recordes, tempo total e nome de jogador. Esta a√ß√£o n√£o pode ser desfeita.",
                    resetConfirm: "Voc√™ tem certeza que quer resetar o jogo?",
                    emptyNameError: "O nome n√£o pode ficar em branco.",
                    restartGame: "Reiniciar",
                    restartConfirm: "Tem certeza de que quer reiniciar este puzzle?",
                    onThisDayTitle: "Neste dia",
                    onThisDayButton: "Neste dia...",
                    onThisDayEnable: "Ativar recurso 'Neste dia'",
                    noOnThisDayMusic: "Nenhuma m√∫sica encontrada lan√ßada neste dia. Tente amanh√£!",
                    randomButton: "Aleat√≥rio",
                    randomModeButton: "Modo Aleat√≥rio",
                    artistModeButton: "Modo Artista",
                    idleCallToActionWithOnThisDay: "Toque em 'Neste dia' ou 'Aleat√≥rio' para iniciar uma partida...",
                    idleCallToActionWithoutOnThisDay: "Toque em 'Modo Aleat√≥rio' para iniciar uma partida..."
                },
                fr: {
                    pageTitle: "Puzzletunes",
                    pauseResumeTitle: "Pause/Reprendre",
                    toggleSoundTitle: "Activer/D√©sactiver le son",
                    menuTitle: "Menu",
                    highScoresTitle: "Meilleurs Scores",
                    languageTitle: "Langue",
                    optionsTitle: "Options",
                    aboutTitle: "√Ä propos",
                    artistSearchPlaceholder: "Rechercher par artiste (optionnel)",
                    newGame: "Nouveau Jeu",
                    gameBy: "Jeu par :",
                    winMessage: "Vous avez gagn√© !",
                    winTime: "Temps : {time}",
                    winMoves: "Mouvements : {moves}",
                    paused: "En pause",
                    startMessage: "Cliquez sur 'Nouveau Jeu' pour commencer",
                    loadingNewGame: "Chargement d'une nouvelle partie...",
                    randomArtist: "-artiste al√©atoire-",
                    searchingForArtist: "-recherche de : {searchTerm}-",
                    didYouMean: "Vouliez-vous dire :",
                    imageError: "Erreur de chargement de l'image. Veuillez r√©essayer.",
                    noMusicFoundFor: "Aucune musique trouv√©e pour \"{searchTerm}\"",
                    noRandomMusic: "Aucune musique al√©atoire trouv√©e. Veuillez r√©essayer.",
                    loadSavedImageError: "Erreur de chargement de l'image sauvegard√©e.",
                    newGameConfirm: "√ätes-vous s√ªr de vouloir commencer une nouvelle partie ? Votre progression sera perdue.",
                    deleteRecordTitle: "Supprimer le record",
                    movesSuffix: "mouv.",
                    langEnglish: "Anglais",
                    langSpanish: "Espagnol",
                    langPortuguese: "Portugais",
                    langFrench: "Fran√ßais",
                    aboutGameText: "Saviez-vous qu'une √©tude publi√©e dans Frontiers in Psychology (Montag & Hegelich, 2021) a d√©montr√© que l'utilisation excessive de r√©seaux comme Instagram et TikTok d√©clenche des lib√©rations rapides de dopamine, ce qui r√©duit la capacit√© de concentration et nous rend plus impatients ? La bonne nouvelle est que vous pouvez entra√Æner votre esprit de mani√®re simple et divertissante : avec Puzzletunes, un puzzle num√©rique 3x3 qui exige une attention soutenue et n'offre la r√©compense qu'une fois termin√©. Jouer quelques minutes par jour devient votre 'salle de sport mentale' pour renforcer la concentration, la patience et la ma√Ætrise de soi tout en vous amusant √† reconstituer des pochettes d'albums.",
                    totalPlaytimeText: "Vous avez un total de <strong>{time}</strong> de parties gagn√©es.",
                    hours_plural: "heures", hour_singular: "heure",
                    minutes_plural: "minutes", minute_singular: "minute",
                    seconds_plural: "secondes", second_singular: "seconde",
                    andConnector: "et",
                    startButton: "Commencer",
                    newTopRecord: "Vous avez r√©alis√© un nouveau record personnel √† la position {rank} !",
                    shareResultTitle: "Partager le R√©sultat",
                    shareMessage: "{playerName} vous d√©fie ! de r√©soudre le puzzle de {artist} - {album} en moins de {time} et {moves} mouvements sur Puzzletunes.",
                    shareImageGenerating: "G√©n√©ration de l'image...",
                    favoriteGenresTitle: "Genres favoris",
                    genreAll: "Tous",
                    rock: "Rock", pop: "Pop", jazz: "Jazz", classical: "Classique", electronic: "√âlectronique", hiphop: "Hip-Hop", reggae: "Reggae", metal: "M√©tal", soul: "Soul", funk: "Funk", latin: "Latine", country: "Country", blues: "Blues", alternative: "Alternative", reggaeton: "Reggaeton", cumbia: "Cumbia", numetal: "Nu Metal", kpop: "K-Pop", jpop: "J-Pop", folk: "Folk", indie: "Indie",
                    idleCallToAction: "Appuyez sur 'Nouveau Jeu' pour commencer une partie...",
                    playerNamePromptTitle: "Choisissez votre nom de joueur",
                    playerNamePlaceholder: "Votre nom ici...",
                    saveNameButton: "Enregistrer",
                    playerNameLabel: "Joueur :",
                    editPlayerNameTitle: "Changer le nom du joueur",
                    resetGameTitle: "R√©initialiser Puzzletunes",
                    resetGameButton: "R√©initialiser le jeu",
                    resetGameWarning: "Ceci supprimera tous vos records, votre temps de jeu total et votre nom de joueur. Cette action est irr√©versible.",
                    resetConfirm: "√ätes-vous s√ªr de vouloir r√©initialiser le jeu ?",
                    emptyNameError: "Le nom ne peut pas √™tre vide.",
                    restartGame: "Red√©marrer",
                    restartConfirm: "√ätes-vous s√ªr de vouloir red√©marrer ce puzzle ?",
                    onThisDayTitle: "Ce jour-l√†",
                    onThisDayButton: "Ce jour-l√†...",
                    onThisDayEnable: "Activer la fonction 'Ce jour-l√†'",
                    noOnThisDayMusic: "Aucune musique trouv√©e sortie ce jour-l√†. R√©essayez demain !",
                    randomButton: "Al√©atoire",
                    randomModeButton: "Mode Al√©atoire",
                    artistModeButton: "Mode Artiste",
                    idleCallToActionWithOnThisDay: "Appuyez sur 'Ce jour-l√†' ou 'Al√©atoire' pour commencer une partie...",
                    idleCallToActionWithoutOnThisDay: "Appuyez sur 'Mode Al√©atoire' pour commencer une partie..."
                }
            };

            let currentStrings = { ...translations.es };

            function getPlayerName() {
                return localStorage.getItem('puzzletunesPlayerName');
            }
            
            function savePlayerName(name) {
                const trimmedName = name.trim();
                if (trimmedName) {
                    localStorage.setItem('puzzletunesPlayerName', trimmedName);
                    return true;
                }
                return false;
            }

            function updatePlayerNameDisplay() {
                const name = getPlayerName();
                if (name) {
                    elements.playerNameDisplay.textContent = `${getTranslatedString('playerNameLabel')} ${name}`;
                    elements.editPlayerNameInput.value = name;
                } else {
                     elements.playerNameDisplay.textContent = '';
                }
            }

            function getTranslatedString(key, replacements = {}) {
                let str = currentStrings[key] || translations.es[key] || key;
                for (const placeholder in replacements) {
                    str = str.replace(`{${placeholder}}`, replacements[placeholder]);
                }
                return str;
            }

            function applyTranslations() {
                const lang = localStorage.getItem('puzzletunesLanguage') || 'es';
                currentStrings = translations[lang];

                document.documentElement.lang = lang;
                document.title = currentStrings.pageTitle;
                
                document.querySelectorAll('[data-translate-key]').forEach(el => {
                    const key = el.dataset.translateKey;
                    if (currentStrings[key]) { 
                        el.innerHTML = currentStrings[key];
                    }
                });
                document.querySelectorAll('[data-translate-placeholder]').forEach(el => {
                    const key = el.dataset.translatePlaceholder;
                    if (currentStrings[key]) el.placeholder = currentStrings[key];
                });
                document.querySelectorAll('[data-translate-title]').forEach(el => {
                    const key = el.dataset.translateTitle;
                    if (currentStrings[key]) el.title = currentStrings[key];
                });

                updateButtonAndTextLogic();
                
                elements.playerNameInput.placeholder = getTranslatedString('playerNamePlaceholder');
                elements.editPlayerNameInput.placeholder = getTranslatedString('playerNamePlaceholder');
                updatePlayerNameDisplay();
            }

            function updateButtonAndTextLogic() {
                const isEnabled = getOnThisDaySetting();
                const artistSearchInput = isMobileDevice() ? elements.artistSearchMobile : elements.artistSearchDesktop;
                const searchTerm = artistSearchInput.value.trim();

                const newGameBtnDesktop = elements.newGameBtnDesktop;
                const newGameBtnMobile = elements.newGameBtnMobile;
                const onThisDayBtnDesktop = elements.onThisDayBtnDesktop;
                const onThisDayBtnMobile = elements.onThisDayBtnMobile;

                let newGameKey;
                if (searchTerm) {
                    newGameKey = 'artistModeButton';
                } else if (isEnabled) {
                    newGameKey = 'randomButton';
                } else {
                    newGameKey = 'randomModeButton';
                }
                
                newGameBtnDesktop.innerHTML = getTranslatedString(newGameKey);
                newGameBtnMobile.innerHTML = getTranslatedString(newGameKey);
                
                const cta = document.getElementById('idle-cta');
                if (cta) {
                    const ctaKey = isEnabled ? 'idleCallToActionWithOnThisDay' : 'idleCallToActionWithoutOnThisDay';
                    cta.textContent = getTranslatedString(ctaKey);
                }

                if (state.isIdle) {
                    newGameBtnDesktop.classList.add('pulsating-neon');
                    newGameBtnMobile.classList.add('pulsating-neon');
                    if (isEnabled) {
                        onThisDayBtnDesktop.classList.add('pulsating-neon-secondary');
                        onThisDayBtnMobile.classList.add('pulsating-neon-secondary');
                    }
                }
            }
            
            function setLanguage(lang) {
                if (!translations[lang]) lang = 'en';
                localStorage.setItem('puzzletunesLanguage', lang);
                applyTranslations();
                updateActiveLanguageButton(lang);
                if (elements.menuModal.classList.contains('visible')) {
                    renderHighScores();
                    renderGenreSelector();
                    renderOnThisDayOption();
                }
            }
            
            function updateActiveLanguageButton(lang) {
                document.querySelectorAll('.lang-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.lang === lang);
                });
            }

            function initializeLocalization() {
                const savedLang = localStorage.getItem('puzzletunesLanguage');
                if (savedLang) {
                    setLanguage(savedLang);
                    return;
                }
                
                const browserLang = (navigator.language || navigator.userLanguage || 'en').slice(0, 2);
                const supportedLangs = ['es', 'en', 'pt', 'fr'];
                const initialLang = supportedLangs.includes(browserLang) ? browserLang : 'en';
                setLanguage(initialLang);
            }
            
            function getSavedGenres() {
                try {
                    const saved = localStorage.getItem('puzzletunesGenres');
                    if (!saved) return ['all'];
                    const parsed = JSON.parse(saved);
                    return Array.isArray(parsed) && parsed.length > 0 ? parsed : ['all'];
                } catch(e) {
                    return ['all'];
                }
            }

            function saveGenres(genres) {
                localStorage.setItem('puzzletunesGenres', JSON.stringify(genres));
            }

            function renderGenreSelector() {
                const selector = document.getElementById('genre-selector');
                if (!selector) return;
                
                const savedGenres = getSavedGenres();
                
                const genresToRender = ['all', ...ALL_GENRES];

                selector.innerHTML = genresToRender.map(genre => {
                    const key = (genre === 'all') ? 'genreAll' : genre;
                    const label = getTranslatedString(key);
                    return `
                        <label class="genre-tag">
                            <input type="checkbox" name="genre" value="${genre}" ${savedGenres.includes(genre) ? 'checked' : ''}>
                            <span>${label}</span>
                        </label>
                    `;
                }).join('');

                const checkboxes = selector.querySelectorAll('input[name="genre"]');
                checkboxes.forEach(checkbox => {
                    checkbox.addEventListener('change', (event) => {
                        handleGenreSelection(checkboxes, event.target);
                    });
                });
            }

            function handleGenreSelection(checkboxes, target) {
                const allCheckbox = document.querySelector('input[value="all"]');
                const selectedGenres = Array.from(checkboxes)
                    .filter(cb => cb.checked && cb.value !== 'all')
                    .map(cb => cb.value);

                if (target.value === 'all' && target.checked) {
                    checkboxes.forEach(cb => { if (cb.value !== 'all') cb.checked = false; });
                    saveGenres(['all']);
                } else {
                    allCheckbox.checked = selectedGenres.length === 0;
                    if (selectedGenres.length > 0) {
                        saveGenres(selectedGenres);
                    } else {
                        saveGenres(['all']);
                    }
                }
            }

            // --- "On This Day" Feature ---
            function getOnThisDaySetting() {
                const setting = localStorage.getItem('puzzletunesOnThisDay');
                return setting === null ? true : setting === 'true'; // Enabled by default
            }

            function saveOnThisDaySetting(isEnabled) {
                localStorage.setItem('puzzletunesOnThisDay', isEnabled);
                updateOnThisDayButtonVisibility();
                updateButtonAndTextLogic();
            }
            
            function renderOnThisDayOption() {
                const toggle = document.getElementById('on-this-day-toggle');
                if (!toggle) return;
                toggle.checked = getOnThisDaySetting();
                toggle.onchange = (e) => saveOnThisDaySetting(e.target.checked);
            }

            function updateOnThisDayButtonVisibility() {
                const isEnabled = getOnThisDaySetting();
                elements.onThisDayBtnDesktop.style.display = isEnabled ? 'inline-block' : 'none';
                elements.onThisDayBtnMobile.style.display = isEnabled ? 'inline-block' : 'none';
            }
            
            function getAlbumHistory() {
                try {
                    const history = localStorage.getItem('puzzletunesAlbumHistory');
                    return history ? JSON.parse(history) : [];
                } catch (e) {
                    return [];
                }
            }

            function addAlbumToHistory(albumId) {
                let history = getAlbumHistory();
                history = [albumId, ...history.filter(id => id !== albumId)];
                if (history.length > 10) {
                    history = history.slice(0, 10);
                }
                localStorage.setItem('puzzletunesAlbumHistory', JSON.stringify(history));
            }
            
            async function fetchWithProxyFallback(url) {
                let lastError = null;
                for (const proxy of PROXIES) {
                    try {
                        const response = await fetch(`${proxy}${url}`);
                        if (response.ok) return response;
                        lastError = new Error(`Proxy ${proxy} returned status ${response.status}`);
                    } catch (error) {
                        lastError = error;
                        console.warn(`Proxy ${proxy} failed:`, error);
                    }
                }
                throw lastError || new Error('All CORS proxies failed to fetch.');
            }
            
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
                const secs = (seconds % 60).toString().padStart(2, '0');
                return `${mins}:${secs}`;
            }

            function updateBackground(imageUrl) {
                document.body.style.setProperty('--bg-image', `url('${imageUrl}')`);
                document.body.style.setProperty('--bg-opacity', '1');
            }

            function clearBackground() {
                document.body.style.setProperty('--bg-opacity', '0');
                setTimeout(() => {
                    document.body.style.setProperty('--bg-image', 'none');
                }, 700);
            }

            function updateUI() {
                elements.timer.textContent = formatTime(state.time);
                elements.moves.textContent = state.moves;
                elements.pauseIcon.style.display = state.isPaused ? 'none' : 'block';
                elements.playIcon.style.display = state.isPaused ? 'block' : 'none';
                elements.muteIcon.style.display = state.isMuted ? 'block' : 'none';
                elements.unmuteIcon.style.display = state.isMuted ? 'none' : 'block';
                elements.pauseBtn.disabled = !state.gameInProgress;
            }
            
            function saveGameState() {
                if (!state.currentAlbum || !state.gameInProgress) return;
                const gameState = {
                    pieces: state.pieces.map(p => ({ originalIndex: p.originalIndex, currentIndex: p.currentIndex })),
                    moves: state.moves,
                    time: state.time,
                    isPaused: state.isPaused,
                    isMuted: state.isMuted,
                    album: state.currentAlbum,
                    gameInProgress: state.gameInProgress,
                };
                localStorage.setItem('puzzletunesGameState', JSON.stringify(gameState));
            }

            function loadGameState() {
                try {
                    const saved = localStorage.getItem('puzzletunesGameState');
                    if (saved) {
                        const savedState = JSON.parse(saved);
                        if (!savedState.album || !Array.isArray(savedState.pieces)) {
                            throw new Error("Invalid saved state structure.");
                        }
                        state.moves = savedState.moves;
                        state.time = savedState.time;
                        state.isMuted = savedState.isMuted;
                        state.currentAlbum = savedState.album;
                        state.gameInProgress = savedState.gameInProgress;
                        state.isPaused = true;
                        
                        const pieceMap = new Map(savedState.pieces.map(p => [p.currentIndex, p.originalIndex]));
                        state.pieces = Array.from({ length: SIZE * SIZE }, (_, i) => {
                            const originalIndex = pieceMap.get(i);
                            return {
                               el: null,
                               originalIndex: originalIndex,
                               currentIndex: i,
                               isEmpty: originalIndex === SIZE * SIZE - 1
                            };
                        });
                        return true;
                    }
                } catch(e) {
                    console.error("Failed to load game state, clearing.", e);
                    clearGameState();
                }
                return false;
            }
            
            function clearGameState() {
                localStorage.removeItem('puzzletunesGameState');
            }

            function renderBoard(imageUrl, boardState, isIdle = false) {
                const container = elements.puzzleContainer;
                
                // Optimized clear
                const piecesToRemove = container.querySelectorAll('.puzzle-piece');
                piecesToRemove.forEach(p => p.remove());

                if (!imageUrl || !boardState) return;

                const url = imageUrl.replace('100x100', '600x600');
                const fragment = document.createDocumentFragment();

                for (let i = 0; i < SIZE * SIZE; i++) {
                    const pieceEl = document.createElement('div');
                    pieceEl.classList.add('puzzle-piece');
                    
                    const originalIndex = boardState[i];
                    if (originalIndex === SIZE * SIZE - 1) {
                        pieceEl.classList.add('empty');
                    } else {
                        const row = Math.floor(originalIndex / SIZE);
                        const col = originalIndex % SIZE;
                        pieceEl.style.backgroundImage = `url(${url})`;
                        pieceEl.style.backgroundPosition = `${(col * 100) / (SIZE - 1)}% ${(row * 100) / (SIZE - 1)}%`;
                    }
                    
                    pieceEl.dataset.index = i;
                    pieceEl.dataset.originalIndex = originalIndex;
                    fragment.appendChild(pieceEl);
                }
                container.appendChild(fragment);
                
                if (!isIdle) {
                    container.querySelectorAll('.puzzle-piece').forEach(el => {
                        el.addEventListener('click', () => onPieceClick(parseInt(el.dataset.index, 10)));
                    });
                }
            }

            function onPieceClick(clickedIndex) {
                if (state.isPaused) return;

                const emptyPiece = state.pieces.find(p => p.isEmpty);
                const clickedPiece = state.pieces.find(p => p.currentIndex === clickedIndex);
                if (!clickedPiece || clickedPiece.isEmpty) return;

                const emptyIndex = emptyPiece.currentIndex;
                const { row: emptyRow, col: emptyCol } = getRowCol(emptyIndex);
                const { row: clickedRow, col: clickedCol } = getRowCol(clickedIndex);

                const isAdjacent = (Math.abs(emptyRow - clickedRow) === 1 && emptyCol === clickedCol) ||
                                   (Math.abs(emptyCol - clickedCol) === 1 && emptyRow === clickedRow);

                if (isAdjacent) {
                    if (state.moves === 0) {
                        state.isMuted = false;
                        elements.audioPlayer.muted = false;
                        if (elements.audioPlayer.paused) {
                            elements.audioPlayer.play().catch(e => {
                                console.error("Audio play failed on first move:", e);
                                state.isMuted = true;
                                elements.audioPlayer.muted = true;
                            });
                        }
                    }
                    
                    swapPieces(clickedPiece, emptyPiece);
                    state.moves++;
                    
                    updateUI();
                    if (checkWin()) {
                        handleWin();
                    }
                    saveGameState();
                }
            }

            function swapPieces(piece1, piece2) {
                const tempIndex = piece1.currentIndex;
                piece1.currentIndex = piece2.currentIndex;
                piece2.currentIndex = tempIndex;

                const piece1El = elements.puzzleContainer.querySelector(`[data-index="${piece2.currentIndex}"]`);
                const piece2El = elements.puzzleContainer.querySelector(`[data-index="${tempIndex}"]`);

                if (piece1El && piece2El) {
                    const tempGridArea = piece1El.style.gridArea;
                    piece1El.style.gridArea = piece2El.style.gridArea;
                }
                
                // For live games, re-render is simpler and safer
                const imageUrl = state.currentAlbum.artworkUrl;
                const boardState = Array(SIZE*SIZE).fill(0);
                state.pieces.forEach(p => {
                    boardState[p.currentIndex] = p.originalIndex;
                });
                renderBoard(imageUrl, boardState);
            }

            function getRowCol(index) {
                return { row: Math.floor(index / SIZE), col: index % SIZE };
            }

            function getValidMoves(emptyIndex) {
                const moves = [];
                const { row, col } = getRowCol(emptyIndex);
                if (row > 0) moves.push(emptyIndex - SIZE);
                if (row < SIZE - 1) moves.push(emptyIndex + SIZE);
                if (col > 0) moves.push(emptyIndex - 1);
                if (col < SIZE - 1) moves.push(emptyIndex + 1);
                return moves;
            }

            function checkWin() {
                return state.pieces.every(p => p.currentIndex === p.originalIndex);
            }
            
            function triggerWinCelebration() {
                const rootStyles = getComputedStyle(document.documentElement);
                const paletteColors = [
                    rootStyles.getPropertyValue('--gradient-color-1').trim(),
                    rootStyles.getPropertyValue('--gradient-color-2').trim(),
                    rootStyles.getPropertyValue('--gradient-color-3').trim(),
                    rootStyles.getPropertyValue('--gradient-color-4').trim(),
                    rootStyles.getPropertyValue('--gradient-color-5').trim()
                ].filter(Boolean);

                const colors = paletteColors.length > 0 ? paletteColors : ['#1DB954', '#FFFFFF', '#1ED760'];

                const defaults = {
                    origin: { x: 0.5, y: 0.5 },
                    shapes: ['‚ô™', '‚ô´', '‚ô¨'],
                    colors: colors,
                    disableForReducedMotion: true,
                    gravity: 0.5,
                    scalar: 2.5,
                };

                const fire = (particleCount, options) => confetti({ ...defaults, ...options, particleCount: Math.floor(particleCount) });
                
                fire(200, { spread: 180, startVelocity: 55, decay: 0.9 });
                fire(150, { spread: 120, startVelocity: 45, decay: 0.91, scalar: 2 });
                fire(250, { spread: 360, startVelocity: 30, decay: 0.92, scalar: 1.5 });
            }
            
            async function generateShareImage() {
                if (!state.currentAlbum) return null;

                return new Promise(resolve => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    img.crossOrigin = "Anonymous";

                    const imageUrl = `${PROXIES[0]}${state.currentAlbum.artworkUrl.replace('100x100', '600x600')}`;

                    img.onload = () => {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);

                        // Overlay for text readability
                        const overlayHeight = canvas.height * 0.4;
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height); // Darken entire image for better text contrast

                        const baseFontSize = Math.max(24, Math.floor(img.width * 0.05));
                        ctx.font = `bold ${baseFontSize}px ${getComputedStyle(document.body).fontFamily}`;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.textBaseline = 'top';
                        
                        const padding = Math.floor(img.width * 0.05);
                        let currentY = padding;
                        
                        // Puzzletunes Title
                        ctx.font = `bold ${baseFontSize * 1.1}px ${getComputedStyle(document.body).fontFamily}`;
                        ctx.fillText("Puzzletunes", padding, currentY);
                        currentY += baseFontSize * 1.5;

                        // Player Name
                        const playerName = getPlayerName() || 'Anonymous';
                        const playerText = `${getTranslatedString('playerNameLabel')} ${playerName}`;
                        ctx.font = `500 ${baseFontSize * 0.9}px ${getComputedStyle(document.body).fontFamily}`;
                        ctx.fillText(playerText, padding, currentY);
                        currentY += baseFontSize * 1.2;
                        
                        // Time and Moves
                        const timeText = `${getTranslatedString('winTime', {time: ''})} ${formatTime(state.time)}`;
                         ctx.font = `500 ${baseFontSize * 0.8}px ${getComputedStyle(document.body).fontFamily}`;
                        ctx.fillText(timeText, padding, currentY);
                        currentY += baseFontSize;

                        const movesText = `${getTranslatedString('winMoves', {moves: ''})} ${state.moves}`;
                        ctx.fillText(movesText, padding, currentY);

                        canvas.toBlob(blob => {
                            if (blob) {
                                resolve(new File([blob], 'puzzletunes-challenge.png', { type: 'image/png' }));
                            } else {
                                resolve(null);
                            }
                        }, 'image/png');
                    };

                    img.onerror = () => resolve(null);
                    img.src = imageUrl;
                });
            }

            function isMobileDevice() {
                return /Mobi|Android/i.test(navigator.userAgent);
            }

            function handleWin() {
                stopTimer();
                elements.puzzleContainer.classList.remove('animated-gradient-border');
                
                // Responsive button handling
                elements.restartGameBtnDesktop.style.display = 'none';
                elements.restartGameBtnMobile.style.display = 'none';
                
                // Show final solved state
                const boardState = Array.from({length: SIZE*SIZE}, (_, i) => i);
                renderBoard(state.currentAlbum.artworkUrl, boardState);
                
                triggerWinCelebration();

                state.isPaused = true;
                state.gameInProgress = false;

                const newRank = saveScore();

                setTimeout(() => {
                    const overlay = document.createElement('div');
                    overlay.className = 'overlay';
                    
                    const messageContainer = document.createElement('div');
                    
                    const winTitle = document.createElement('h2');
                    winTitle.textContent = getTranslatedString('winMessage');
                    
                    const statsContainer = document.createElement('div');
                    statsContainer.className = 'win-stats';
                    const timeStat = document.createElement('p');
                    timeStat.textContent = getTranslatedString('winTime', { time: formatTime(state.time) });
                    const movesStat = document.createElement('p');
                    movesStat.textContent = getTranslatedString('winMoves', { moves: state.moves });
                    statsContainer.appendChild(timeStat);
                    statsContainer.appendChild(movesStat);

                    messageContainer.appendChild(winTitle);
                    messageContainer.appendChild(statsContainer);

                    overlay.appendChild(messageContainer);

                    const canShareFiles = isMobileDevice() && navigator.share && navigator.canShare && navigator.canShare({ files: [new File([], '')] });

                    if (canShareFiles) {
                        const shareBtn = document.createElement('button');
                        shareBtn.className = 'share-btn';
                        shareBtn.innerHTML = `
                            <svg viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z"></path></svg>
                            <span>${getTranslatedString('shareResultTitle')}</span>
                        `;
                        
                        shareBtn.onclick = async () => {
                            const originalText = shareBtn.querySelector('span').textContent;
                            shareBtn.disabled = true;
                            shareBtn.querySelector('span').textContent = getTranslatedString('shareImageGenerating');
                            
                            const imageFile = await generateShareImage();
                            
                            const baseUrl = window.location.origin + window.location.pathname;
                            const challengeUrl = `${baseUrl}?challenge=${state.currentAlbum.collectionId}`;

                            const shareData = {
                                title: 'Puzzletunes Challenge',
                                text: getTranslatedString('shareMessage', {
                                    playerName: getPlayerName() || 'A friend',
                                    artist: state.currentAlbum.artistName,
                                    album: state.currentAlbum.collectionName,
                                    time: formatTime(state.time),
                                    moves: state.moves
                                }),
                                url: challengeUrl,
                            };
                            
                            if (imageFile) {
                                shareData.files = [imageFile];
                            }
                            
                            try {
                                await navigator.share(shareData);
                            } catch(err) {
                                console.error("Share failed:", err);
                            } finally {
                                shareBtn.disabled = false;
                                shareBtn.querySelector('span').textContent = originalText;
                            }
                        };
                        messageContainer.appendChild(shareBtn);
                    }
                    elements.puzzleContainer.appendChild(overlay);

                }, 500);

                if (newRank !== -1) {
                    setTimeout(() => showTopRecordNotification(newRank), 1200);
                }

                clearGameState();
                elements.audioPlayer.pause();
                updateUI();
            }

            function showTopRecordNotification(rank) {
                const overlay = document.createElement('div');
                overlay.className = 'personal-best-overlay';
                
                const text = document.createElement('div');
                text.className = 'personal-best-text';
                text.innerHTML = getTranslatedString('newTopRecord', { rank });
                
                overlay.appendChild(text);
                document.body.appendChild(overlay);
                
                requestAnimationFrame(() => overlay.classList.add('visible'));

                let confettiInterval = triggerTopRecordCelebration();

                overlay.addEventListener('click', () => {
                    overlay.classList.remove('visible');
                    clearInterval(confettiInterval);
                    confetti.reset();
                    overlay.addEventListener('transitionend', () => overlay.remove());
                }, { once: true });
            }

            function triggerTopRecordCelebration() {
                const end = Date.now() + (3 * 1000);
                const colors = ['#FFD700', '#FFDF00', '#F0E68C'];

                const frame = () => {
                    if (Date.now() > end) {
                        return;
                    }

                    confetti({ particleCount: 2, angle: 60, spread: 55, origin: { x: 0 }, colors: colors, shapes: ['star'] });
                    confetti({ particleCount: 2, angle: 120, spread: 55, origin: { x: 1 }, colors: colors, shapes: ['star'] });
                };
                
                const intervalId = setInterval(frame, 200);
                frame();
                return intervalId;
            }


            function getHighScores() {
                try {
                    const storedScores = localStorage.getItem('puzzletunesHighScores');
                    if (!storedScores) return [];
                    const parsedScores = JSON.parse(storedScores);
                    if (Array.isArray(parsedScores)) {
                        return parsedScores.filter(s => s && typeof s.time === 'number' && s.album);
                    }
                } catch (e) {
                    console.error("Could not parse high scores, returning empty list.", e);
                }
                return [];
            }
            
            function saveScore() {
                if (!state.currentAlbum) return -1;

                let totalPlaytime = parseInt(localStorage.getItem('puzzletunesTotalPlaytime'), 10) || 0;
                totalPlaytime += state.time;
                localStorage.setItem('puzzletunesTotalPlaytime', totalPlaytime);

                const newScore = {
                    time: state.time,
                    moves: state.moves,
                    album: { ...state.currentAlbum },
                    id: Date.now()
                };

                let highScores = getHighScores();
                highScores.push(newScore);

                highScores.sort((a, b) => {
                    if (a.time !== b.time) return a.time - b.time;
                    return a.moves - b.moves;
                });
                
                if (highScores.length > 10) {
                    highScores = highScores.slice(0, 10);
                }

                localStorage.setItem('puzzletunesHighScores', JSON.stringify(highScores));
                
                const newRank = highScores.findIndex(score => score.id === newScore.id) + 1;
                return (newRank > 0 && newRank <= 3) ? newRank : -1;
            }


            function renderHighScores() {
                const highScores = getHighScores();
                const totalPlaytimeEl = document.getElementById('total-playtime');
                const totalSeconds = parseInt(localStorage.getItem('puzzletunesTotalPlaytime'), 10) || 0;
                
                if (totalSeconds > 0) {
                    const hours = Math.floor(totalSeconds / 3600);
                    const minutes = Math.floor((totalSeconds % 3600) / 60);
                    const seconds = totalSeconds % 60;
                    
                    const timeParts = [];
                    if (hours > 0) {
                        const hourKey = hours === 1 ? 'hour_singular' : 'hours_plural';
                        timeParts.push(`${hours} ${getTranslatedString(hourKey)}`);
                    }
                    if (minutes > 0) {
                        const minuteKey = minutes === 1 ? 'minute_singular' : 'minutes_plural';
                        timeParts.push(`${minutes} ${getTranslatedString(minuteKey)}`);
                    }
                    if (seconds > 0 || totalSeconds < 60) {
                        const secondKey = seconds === 1 ? 'second_singular' : 'seconds_plural';
                        timeParts.push(`${seconds} ${getTranslatedString(secondKey)}`);
                    }
                    
                    let formattedTime;
                    if (timeParts.length === 3) {
                         const connector = ` ${getTranslatedString('andConnector')} `;
                         formattedTime = `${timeParts[0]}, ${timeParts[1]}${connector}${timeParts[2]}`;
                    } else if (timeParts.length === 2) {
                         const connector = ` ${getTranslatedString('andConnector')} `;
                         formattedTime = timeParts.join(connector);
                    } else {
                         formattedTime = timeParts[0] || '';
                    }

                    totalPlaytimeEl.innerHTML = `‚è∞ ${getTranslatedString('totalPlaytimeText', { time: formattedTime })}`;
                } else {
                    totalPlaytimeEl.innerHTML = '';
                }

                elements.highScoresList.innerHTML = highScores.map((item, index) => {
                    const wrapperId = `marquee-wrapper-${item.id}`;
                    const year = item.album.releaseDate ? new Date(item.album.releaseDate).getFullYear() : '';
                    const artistText = year ? `${item.album.artistName} (${year})` : item.album.artistName;

                    const rankClass = index === 0 ? 'gold' : index === 1 ? 'silver' : index === 2 ? 'bronze' : '';
                    const rankContent = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : index + 1;


                    const html = `
                        <li class="score-item ${rankClass}">
                            <span class="score-rank">${rankContent}</span>
                            <img src="${item.album.artworkUrl}" class="score-thumbnail" alt="Artwork for ${item.album.collectionName}">
                            <div class="score-info">
                                <p class="score-artist">${artistText}</p>
                                <div class="marquee-wrapper" id="${wrapperId}">
                                    <p class="score-track marquee-content">${item.album.collectionName}</p>
                                </div>
                                <div class="score-stats">
                                    <span>${formatTime(item.time)}</span>
                                    <span>${item.moves} ${getTranslatedString('movesSuffix')}</span>
                                </div>
                            </div>
                            <button class="score-delete-btn" data-id="${item.id}" title="${getTranslatedString('deleteRecordTitle')}">
                                <svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></svg>
                            </button>
                        </li>`;
                    
                    setTimeout(() => {
                        const wrapper = document.getElementById(wrapperId);
                        const content = wrapper?.querySelector('.marquee-content');
                        if (wrapper && content && content.scrollWidth > wrapper.clientWidth) {
                            wrapper.classList.add('animate');
                        }
                    }, 0);
                    return html;
                }).join('');
            }
            
            function hideOverlay() {
                const existingOverlay = elements.puzzleContainer.querySelector('.overlay');
                if (existingOverlay) {
                    existingOverlay.remove();
                }
            }

            function showOverlay(htmlContent, suggestions = []) {
                hideOverlay();
                const overlay = document.createElement('div');
                overlay.className = 'overlay';
                overlay.innerHTML = `<div>${htmlContent}</div>`;
                
                if (suggestions.length > 0) {
                    const suggestionsContainer = document.createElement('div');
                    suggestionsContainer.className = 'suggestions-container';
                    suggestions.forEach(suggestion => {
                        const btn = document.createElement('button');
                        btn.className = 'suggestion-btn';
                        btn.textContent = suggestion;
                        btn.onclick = () => {
                            const artistSearchInput = isMobileDevice() ? elements.artistSearchMobile : elements.artistSearchDesktop;
                            artistSearchInput.value = suggestion;
                            prepareNewGame(true);
                        };
                        suggestionsContainer.appendChild(btn);
                    });
                    overlay.appendChild(suggestionsContainer);
                }
                elements.puzzleContainer.appendChild(overlay);
            }
            
            async function fetchRandomArtworks(count) {
                 try {
                    const genre = ALL_GENRES[Math.floor(Math.random() * ALL_GENRES.length)];
                    const url = `https://itunes.apple.com/search?term=${genre}&entity=album&limit=50`;
                    const response = await fetchWithProxyFallback(url);
                    const data = await response.json();
                    
                    const artworks = data.results.map(item => item.artworkUrl100.replace('100x100', '300x300'));
                    const uniqueArtworks = [...new Set(artworks)];
                    
                    for (let i = uniqueArtworks.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [uniqueArtworks[i], uniqueArtworks[j]] = [uniqueArtworks[j], uniqueArtworks[i]];
                    }
                    return uniqueArtworks.slice(0, count);
                } catch (error) {
                    console.error('Failed to fetch random artworks:', error);
                    return [];
                }
            }
            
            async function findAlbumWithMusic(searchTerm, isArtistSearch = false, onThisDay = false) {
                const userGenres = getSavedGenres();
                const genresToSearch = (userGenres.includes('all') || userGenres.length === 0) ? ALL_GENRES : userGenres;
                let MAX_ATTEMPTS = onThisDay ? 10 : 5;

                const searchAndProcess = async (url) => {
                    try {
                        const response = await fetchWithProxyFallback(url);
                        const data = await response.json();
                        const songsWithPreview = data.results.filter(song => song.previewUrl && song.artworkUrl100 && song.trackViewUrl && song.trackName && song.releaseDate);
                        if (songsWithPreview.length === 0) return { albums: [], suggestions: [] };

                        const suggestions = [...new Set(data.results.map(r => r.artistName))];
                        
                        const albums = songsWithPreview.reduce((acc, song) => {
                            if (!acc[song.collectionId]) {
                                acc[song.collectionId] = {
                                    artistName: song.artistName,
                                    collectionName: song.collectionName,
                                    artworkUrl: song.artworkUrl100,
                                    previewUrl: song.previewUrl,
                                    trackViewUrl: song.trackViewUrl,
                                    trackName: song.trackName,
                                    releaseDate: song.releaseDate,
                                    collectionId: song.collectionId,
                                };
                            }
                            return acc;
                        }, {});

                        let albumArray = Object.values(albums);
                        return { albums: albumArray, suggestions };
                    } catch (error) {
                        console.error('Error in searchAndProcess:', error);
                        return { albums: [], suggestions: [] };
                    }
                };
                
                let result = null;
                let finalSuggestions = [];
                let foundOnThisDay = false;

                if (onThisDay) {
                    const today = new Date();
                    const todayMonth = today.getMonth() + 1;
                    const todayDate = today.getDate();

                    for (let i = 0; i < MAX_ATTEMPTS; i++) {
                        const genre = genresToSearch[Math.floor(Math.random() * genresToSearch.length)];
                        const searchUrl = `https://itunes.apple.com/search?term=${encodeURIComponent(genre)}&entity=song&limit=200`;
                        const { albums } = await searchAndProcess(searchUrl);

                        if (albums && albums.length > 0) {
                            const matchingAlbums = albums.filter(album => {
                                const releaseDate = new Date(album.releaseDate);
                                return releaseDate.getMonth() + 1 === todayMonth && releaseDate.getDate() === todayDate;
                            });

                            if (matchingAlbums.length > 0) {
                                result = matchingAlbums;
                                foundOnThisDay = true;
                                break;
                            }
                        }
                    }
                } else if (isArtistSearch) {
                    const searchUrl = `https://itunes.apple.com/search?term=${encodeURIComponent(searchTerm)}&entity=song&limit=200&attribute=artistTerm`;
                    const { albums, suggestions } = await searchAndProcess(searchUrl);
                    result = albums;
                    finalSuggestions = suggestions;
                } else {
                     for (let i = 0; i < MAX_ATTEMPTS; i++) {
                        const genre = genresToSearch[Math.floor(Math.random() * genresToSearch.length)];
                        const searchUrl = `https://itunes.apple.com/search?term=${encodeURIComponent(genre)}&entity=song&limit=200`;
                        const { albums } = await searchAndProcess(searchUrl);
                        if (albums && albums.length > 0) {
                            result = albums;
                            break;
                        }
                        console.warn(`Random search attempt ${i + 1} for genre ${genre} failed. Retrying...`);
                    }
                }

                if (!result || result.length === 0) {
                    return { album: null, suggestions: finalSuggestions, notFound: onThisDay && !foundOnThisDay };
                }

                const history = getAlbumHistory();
                let uniqueAlbumArray = result.filter(album => !history.includes(album.collectionId));
                
                if (uniqueAlbumArray.length === 0) {
                     console.warn("All found albums are in recent history. Retrying search...");
                     return { album: null, suggestions: finalSuggestions, retry: true };
                }

                uniqueAlbumArray.sort((a, b) => new Date(b.releaseDate) - new Date(a.releaseDate));
                
                const selectionSize = Math.min(50, Math.ceil(uniqueAlbumArray.length * 0.6));
                const newestAlbums = uniqueAlbumArray.slice(0, selectionSize);
                
                return {
                    album: newestAlbums[Math.floor(Math.random() * newestAlbums.length)],
                    suggestions: finalSuggestions
                };
            }
            
             async function findAlbumById(id) {
                try {
                    const url = `https://itunes.apple.com/lookup?id=${id}&entity=song`;
                    const response = await fetchWithProxyFallback(url);
                    const data = await response.json();
                    if (data.resultCount > 0) {
                        const song = data.results.find(item => item.wrapperType === 'track');
                        if (song && song.previewUrl) {
                            return {
                                artistName: song.artistName,
                                collectionName: song.collectionName,
                                artworkUrl: song.artworkUrl100,
                                previewUrl: song.previewUrl,
                                trackViewUrl: song.trackViewUrl,
                                trackName: song.trackName,
                                releaseDate: song.releaseDate,
                                collectionId: song.collectionId,
                            };
                        }
                    }
                    return null;
                } catch (error) {
                    console.error('Error finding album by ID:', error);
                    return null;
                }
            }
            
            async function prepareNewGame(isFromSuggestion = false, challengeId = null, onThisDay = false) {
                const artistSearchInput = isMobileDevice() ? elements.artistSearchMobile : elements.artistSearchDesktop;
                let searchTerm = artistSearchInput.value.trim();
                let isArtistSearch = searchTerm.length > 0;
                let retryCount = 0;
                const MAX_RETRIES = 3;

                const attemptSearch = async () => {
                    const title = getTranslatedString('loadingNewGame');
                    let subtitle = isArtistSearch
                        ? getTranslatedString('searchingForArtist', { searchTerm })
                        : getTranslatedString('randomArtist');
                    if (challengeId) subtitle = ''; // No subtitle for challenges
                    if (onThisDay) subtitle = getTranslatedString('onThisDayButton');

                    const overlayHTML = `<h2>${title}</h2><p style="font-size: 1rem; color: var(--on-surface-secondary);">${subtitle}</p>`;
                    showOverlay(overlayHTML);
                    
                    if (challengeId) {
                        const album = await findAlbumById(challengeId);
                        return { finalAlbum: album };
                    }

                    const { album, suggestions, retry, notFound } = await findAlbumWithMusic(searchTerm, isArtistSearch, onThisDay);

                    if (album) {
                        return { finalAlbum: album };
                    }

                    if (retry && retryCount < MAX_RETRIES) {
                        retryCount++;
                        return attemptSearch(); // Recursive call
                    }

                    if (onThisDay && notFound) {
                        showOverlay(getTranslatedString('noOnThisDayMusic'));
                        return { error: true };
                    }

                    if (isArtistSearch && !isFromSuggestion) {
                        const filteredSuggestions = [...new Set(suggestions)]
                            .map(name => ({ name, distance: calculateLevenshteinDistance(searchTerm.toLowerCase(), name.toLowerCase()) }))
                            .filter(item => item.distance < 4 && item.name.toLowerCase() !== searchTerm.toLowerCase())
                            .sort((a, b) => a.distance - b.distance)
                            .map(item => item.name)
                            .slice(0, 3);

                        if (filteredSuggestions.length > 0) {
                            showOverlay(getTranslatedString('didYouMean'), filteredSuggestions);
                            return { error: true };
                        }
                    }

                    const message = isArtistSearch ? getTranslatedString('noMusicFoundFor', {searchTerm}) : getTranslatedString('noRandomMusic');
                    showOverlay(message);
                    return { error: true };
                };
                
                const { finalAlbum, error } = await attemptSearch();

                if (error || !finalAlbum) return;

                state.currentAlbum = finalAlbum;
                
                const img = new Image();
                img.crossOrigin = "Anonymous";
                // Load image through proxy for color thief
                const proxiedImageUrl = `${PROXIES[0]}${state.currentAlbum.artworkUrl.replace('100x100', '600x600')}`;
                img.src = proxiedImageUrl;
                
                img.onload = () => {
                    try {
                        const palette = colorThief.getPalette(img, 5);
                        palette.forEach((c, i) => document.documentElement.style.setProperty(`--gradient-color-${i + 1}`, `rgb(${c[0]}, ${c[1]}, ${c[2]})`));
                    } catch(e) { console.error("ColorThief failed:", e); }
                    
                    updateBackground(proxiedImageUrl);
                    hideOverlay();
                    playIntroAnimation();
                };
                img.onerror = () => showOverlay(getTranslatedString('imageError'));
            }

            function cleanupPreviousGameResources() {
                stopTimer();
                state.isIdle = false; // Stop idle animation
                elements.audioPlayer.pause();
                elements.audioPlayer.removeAttribute('src');
                elements.audioPlayer.load();
                clearBackground();
                elements.puzzleContainer.innerHTML = '';
                elements.trackText.innerHTML = '';
                hideTrackLinks();
                state.currentAlbum = null;
                state.gameInProgress = false;
                state.isPaused = true;
                state.time = 0;
                state.moves = 0;
                
                elements.idleCollage.classList.remove('visible');
                elements.puzzleContainer.classList.remove('animated-gradient-border', 'idle-mode');
                
                // Responsive button handling
                const newGameBtnDesktop = elements.newGameBtnDesktop;
                const newGameBtnMobile = elements.newGameBtnMobile;
                newGameBtnDesktop.classList.remove('pulsating-neon');
                newGameBtnMobile.classList.remove('pulsating-neon');
                elements.onThisDayBtnDesktop.classList.remove('pulsating-neon-secondary');
                elements.onThisDayBtnMobile.classList.remove('pulsating-neon-secondary');
                elements.restartGameBtnDesktop.style.display = 'none';
                elements.restartGameBtnMobile.style.display = 'none';
                
                const cta = document.getElementById('idle-cta');
                if (cta) cta.remove();
                
                updateUI();
            }

            function updateTrackLinks(album) {
                if (!album || !album.trackViewUrl || !album.trackName) {
                    hideTrackLinks();
                    return;
                }

                elements.appleMusicLink.href = album.trackViewUrl;
                elements.appleMusicLink.style.display = 'flex';

                const spotifyQuery = `${album.artistName} ${album.trackName}`;
                const spotifyUrl = `https://open.spotify.com/search/${encodeURIComponent(spotifyQuery)}`;
                elements.spotifyLink.href = spotifyUrl;
                elements.spotifyLink.style.display = 'flex';
            }

            function hideTrackLinks() {
                elements.appleMusicLink.style.display = 'none';
                elements.appleMusicLink.href = '#';
                elements.spotifyLink.style.display = 'none';
                elements.spotifyLink.href = '#';
            }
            
            function updateTrackText() {
                if (!state.currentAlbum) {
                    elements.trackText.innerHTML = '';
                    return;
                }
                const year = state.currentAlbum.releaseDate ? new Date(state.currentAlbum.releaseDate).getFullYear() : '';
                const artistText = year ? `${state.currentAlbum.artistName} (${year})` : state.currentAlbum.artistName;
                elements.trackText.innerHTML = `<h2>${state.currentAlbum.collectionName}</h2><p>${artistText}</p>`;
            }

            function playIntroAnimation() {
                elements.puzzleContainer.innerHTML = '';
                elements.puzzleContainer.classList.remove('animated-gradient-border');
                elements.puzzleContainer.classList.add('intro-animation-active');
                updateTrackText();
                updateTrackLinks(state.currentAlbum);
                
                const imageUrl = state.currentAlbum.artworkUrl.replace('100x100', '600x600');
                const pieces = [];

                for (let i = 0; i < SIZE * SIZE; i++) {
                    const pieceEl = document.createElement('div');
                    pieceEl.classList.add('puzzle-piece', 'puzzle-piece-intro');
                    const row = Math.floor(i / SIZE);
                    const col = i % SIZE;
                    pieceEl.style.backgroundImage = `url(${imageUrl})`;
                    pieceEl.style.backgroundPosition = `${(col * 100) / (SIZE - 1)}% ${(row * 100) / (SIZE - 1)}%`;
                    elements.puzzleContainer.appendChild(pieceEl);
                    pieces.push(pieceEl);
                }

                const shuffledIndices = [...Array(pieces.length).keys()].sort(() => Math.random() - 0.5);
                shuffledIndices.forEach((index, i) => {
                    setTimeout(() => {
                        pieces[index].classList.add('visible');
                    }, i * 100);
                });
                
                setTimeout(() => {
                    const startOverlay = document.createElement('div');
                    startOverlay.className = 'overlay';
                    startOverlay.style.backgroundColor = 'rgba(0,0,0,0.5)';
                    const startButton = document.createElement('button');
                    startButton.id = 'start-game-btn';
                    startButton.textContent = getTranslatedString('startButton');
                    startOverlay.appendChild(startButton);
                    elements.puzzleContainer.appendChild(startOverlay);

                    startButton.onclick = () => {
                        startOverlay.remove();
                        elements.puzzleContainer.classList.add('swirl-animation');
                        setTimeout(() => {
                            elements.puzzleContainer.classList.remove('swirl-animation', 'intro-animation-active');
                            elements.puzzleContainer.style.opacity = '0';
                            startNewGame();
                            requestAnimationFrame(() => {
                                elements.puzzleContainer.style.transition = 'opacity 0.4s ease';
                                elements.puzzleContainer.style.opacity = '1';
                                setTimeout(() => { elements.puzzleContainer.style.transition = ''; elements.puzzleContainer.style.opacity = ''; }, 400);
                            });
                        }, 800);
                    };
                }, (shuffledIndices.length * 100) + 800);
            }

            function startNewGame() {
                // clearGameState() is now called on button click, not here.
                state.time = 0;
                state.moves = 0;
                state.isPaused = false;
                state.isMuted = true;
                state.gameInProgress = true;
                
                addAlbumToHistory(state.currentAlbum.collectionId);

                let board = Array.from({ length: SIZE * SIZE }, (_, i) => i);
                let emptyPosition = SIZE * SIZE - 1;
                
                const shuffleMoves = 150; 
                for (let i = 0; i < shuffleMoves; i++) {
                    const validMoves = getValidMoves(emptyPosition);
                    const move = validMoves[Math.floor(Math.random() * validMoves.length)];
                    [board[emptyPosition], board[move]] = [board[move], board[emptyPosition]];
                    emptyPosition = move;
                }
                
                state.pieces = Array.from({ length: SIZE * SIZE }, (_, i) => ({
                    el: null,
                    originalIndex: i,
                    currentIndex: board.indexOf(i),
                    isEmpty: i === SIZE * SIZE - 1
                }));
                
                const imageUrl = state.currentAlbum.artworkUrl.replace('100x100', '600x600');
                const boardState = Array(SIZE*SIZE).fill(0);
                state.pieces.forEach(p => {
                    boardState[p.currentIndex] = p.originalIndex;
                });
                renderBoard(imageUrl, boardState);
                
                startTimer();
                elements.puzzleContainer.classList.add('animated-gradient-border');
                
                // Responsive button handling
                updateButtonAndTextLogic();

                elements.restartGameBtnDesktop.style.display = 'inline-block';
                elements.restartGameBtnMobile.style.display = 'inline-block';

                updateTrackText();
                updateTrackLinks(state.currentAlbum);
                elements.audioPlayer.src = state.currentAlbum.previewUrl;
                elements.audioBtn.disabled = true;
                elements.audioPlayer.muted = true;
                updateUI();
                saveGameState();
            }
            
            async function animateTitle() {
                const titleEl = elements.gameTitle;
                if (!titleEl || titleEl.dataset.animated === "true") return;
                
                if(elements.footer.contains(titleEl)){
                    titleEl.dataset.animated = "true";
                }

                const text = "Puzzletunes";
                titleEl.innerHTML = text.split('').map(letter => `<span>${letter === ' ' ? '&nbsp;' : letter}</span>`).join('');
                const spans = Array.from(titleEl.children);
                
                const finalPositions = spans.map(span => {
                    const rect = span.getBoundingClientRect();
                    return { x: rect.left, y: rect.top, width: rect.width, height: rect.height };
                });
                
                if (finalPositions.some(p => p.width === 0)) {
                    titleEl.textContent = text;
                    return;
                }

                titleEl.style.height = `${finalPositions[0].height}px`;

                const screenCenterX = window.innerWidth / 2;
                const screenCenterY = window.innerHeight / 2;
                
                spans.forEach((span, i) => {
                    span.style.position = 'fixed';
                    span.style.left = `${screenCenterX - finalPositions[i].width / 2}px`;
                    span.style.top = `${screenCenterY - finalPositions[i].height / 2}px`;
                    span.style.opacity = '0';
                    span.style.transform = 'scale(0.5)';
                    span.style.transition = `all 0.8s cubic-bezier(0.2, 0.8, 0.2, 1)`;
                });

                const shuffledIndices = [...Array(spans.length).keys()].sort(() => Math.random() - 0.5);
                
                await new Promise(resolve => requestAnimationFrame(() => setTimeout(resolve, 20)));

                spans.forEach((span, i) => {
                    const shuffledIndex = shuffledIndices[i];
                    const targetPos = finalPositions[shuffledIndex];
                    span.style.left = `${targetPos.x}px`;
                    span.style.top = `${targetPos.y}px`;
                    span.style.opacity = '1';
                    span.style.transform = 'scale(1)';
                    span.style.transitionDelay = `${i * 0.05}s`;
                });

                await new Promise(resolve => setTimeout(resolve, 800 + (text.length * 50)));

                spans.forEach((span, i) => {
                    const finalPos = finalPositions[i];
                    span.style.left = `${finalPos.x}px`;
                    span.style.transitionDelay = '0s';
                    span.style.transitionDuration = '0.6s';
                });

                await new Promise(resolve => setTimeout(resolve, 700));

                spans.forEach(span => {
                    span.style.position = 'relative';
                    span.style.left = '';
                    span.style.top = '';
                    span.style.transform = '';
                    span.style.transition = '';
                });
            }
            
            // --- GHOST SOLVER ANIMATION ---

            async function ghostSolverLoop(urls) {
                const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

                for (let i = 0; i < urls.length; i++) {
                    if (!state.isIdle) break;

                    let board = Array.from({ length: SIZE * SIZE }, (_, i) => i);
                    let shuffledBoard = [...board];
                    let emptyIndex = SIZE * SIZE - 1;
                    
                    // Simple shuffle, good enough for animation
                    for (let j = 0; j < 50; j++) {
                        const validMoves = getValidMoves(emptyIndex);
                        const move = validMoves[Math.floor(Math.random() * validMoves.length)];
                        [shuffledBoard[emptyIndex], shuffledBoard[move]] = [shuffledBoard[move], shuffledBoard[emptyIndex]];
                        emptyIndex = move;
                    }
                    
                    renderBoard(urls[i], shuffledBoard, true);

                    const solution = solvePuzzle(shuffledBoard);
                    if (!solution || !state.isIdle) continue;

                    for (const move of solution) {
                        if (!state.isIdle) break;
                        shuffledBoard = move;
                        renderBoard(urls[i], shuffledBoard, true);
                        await delay(150);
                    }
                    
                    if (state.isIdle) await delay(2000);
                }

                if (state.isIdle) {
                    ghostSolverLoop(urls); // Loop indefinitely
                }
            }

            function solvePuzzle(startBoard) {
                const goal = Array.from({ length: SIZE * SIZE }, (_, i) => i);
                const goalStr = goal.join(',');

                // Basic Breadth-First Search (BFS) is simpler and sufficient for 3x3
                const queue = [[startBoard, []]]; // [board, path]
                const visited = new Set([startBoard.join(',')]);

                while (queue.length > 0) {
                    const [currentBoard, path] = queue.shift();
                    
                    if (currentBoard.join(',') === goalStr) {
                        return path;
                    }

                    const emptyIndex = currentBoard.indexOf(SIZE * SIZE - 1);
                    const validMoves = getValidMoves(emptyIndex);

                    for (const move of validMoves) {
                        const newBoard = [...currentBoard];
                        [newBoard[emptyIndex], newBoard[move]] = [newBoard[move], newBoard[emptyIndex]];
                        const newBoardStr = newBoard.join(',');

                        if (!visited.has(newBoardStr)) {
                            visited.add(newBoardStr);
                            const newPath = [...path, newBoard];
                            queue.push([newBoard, newPath]);
                        }
                    }
                }
                return null; // Should not happen for solvable puzzles
            }
            
            function renderStaticTitle() {
                const titleEl = elements.gameTitle;
                if (titleEl) {
                     if(!elements.footer.contains(titleEl)) {
                        elements.footer.prepend(titleEl);
                     }
                     if(titleEl.innerHTML.trim() === '') {
                        titleEl.textContent = 'Puzzletunes';
                     }
                }
            }

            async function setupIdleAnimation() {
                state.isIdle = true;
                const allArtworks = await fetchRandomArtworks(10);
                if (!state.isIdle || !allArtworks || allArtworks.length < 10) {
                    // Fallback if fetch fails or user starts game during fetch
                    showOverlay(getTranslatedString('startMessage'));
                    renderStaticTitle();
                    return;
                }
                
                elements.puzzleContainer.classList.add('idle-mode');
                const callToAction = document.createElement('div');
                callToAction.className = 'idle-call-to-action';
                callToAction.id = 'idle-cta';
                elements.puzzleContainer.appendChild(callToAction);

                updateButtonAndTextLogic();
                
                const backgroundLayers = elements.idleCollage.children;
                allArtworks.forEach((url, i) => {
                    if (backgroundLayers[i]) {
                        backgroundLayers[i].style.backgroundImage = `url('${url.replace('300x300', '600x600')}')`;
                    }
                });
                elements.idleCollage.classList.add('visible');

                animateTitle();
                ghostSolverLoop(allArtworks);
            }
            
            async function initGame() {
                if (!getPlayerName()) {
                    elements.playerNamePrompt.style.display = 'flex';
                    return; 
                }
                
                updatePlayerNameDisplay();
                updateOnThisDayButtonVisibility();

                const urlParams = new URLSearchParams(window.location.search);
                const challengeId = urlParams.get('challenge');

                if (challengeId) {
                    // Clear the URL to avoid re-triggering the challenge on reload
                    window.history.replaceState({}, document.title, window.location.pathname);
                    cleanupPreviousGameResources();
                    renderStaticTitle();
                    await prepareNewGame(false, challengeId);
                    return;
                }
                
                if (loadGameState() && state.gameInProgress) {
                    const proxiedImageUrl = `${PROXIES[0]}${state.currentAlbum.artworkUrl.replace('100x100', '600x600')}`;
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.src = proxiedImageUrl;

                    img.onload = () => {
                        renderStaticTitle();
                        try {
                            const palette = colorThief.getPalette(img, 5);
                            palette.forEach((c, i) => document.documentElement.style.setProperty(`--gradient-color-${i + 1}`, `rgb(${c[0]}, ${c[1]}, ${c[2]})`));
                        } catch(e) { console.error("ColorThief failed on load:", e); }
                        updateBackground(proxiedImageUrl);
                        const boardState = Array(SIZE*SIZE).fill(0);
                        state.pieces.forEach(p => {
                           boardState[p.currentIndex] = p.originalIndex;
                        });
                        renderBoard(proxiedImageUrl, boardState);

                        startTimer();
                        elements.puzzleContainer.classList.add('animated-gradient-border');
                        
                        // Responsive button handling
                        updateButtonAndTextLogic();
                        elements.restartGameBtnDesktop.style.display = 'inline-block';
                        elements.restartGameBtnMobile.style.display = 'inline-block';

                        updateUI();
                        showOverlay(getTranslatedString('paused'));
                        updateTrackText();
                        updateTrackLinks(state.currentAlbum);
                        if (state.currentAlbum.previewUrl) {
                            elements.audioPlayer.src = state.currentAlbum.previewUrl;
                        }
                    };
                     img.onerror = () => {
                        renderStaticTitle();
                        showOverlay(getTranslatedString('loadSavedImageError'));
                     }
                } else {
                    elements.gameTitle.innerHTML = '';
                    setupIdleAnimation();
                }
            }
            
            function startTimer() {
                if (state.timerInterval) clearInterval(state.timerInterval);
                state.timerInterval = setInterval(() => {
                    if (!state.isPaused) {
                        state.time++;
                        elements.timer.textContent = formatTime(state.time);
                    }
                }, 1000);
            }

            function stopTimer() {
                clearInterval(state.timerInterval);
                state.timerInterval = null;
            }

            function switchTab(tabName) {
                const modal = elements.menuModal;
                modal.querySelectorAll('.tab-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.tab === tabName));
                modal.querySelectorAll('.modal-panel').forEach(panel => panel.classList.toggle('active', panel.id === `${tabName}-panel`));
                
                let titleKey;
                if(tabName === 'records') titleKey = 'highScoresTitle';
                else if (tabName === 'language') titleKey = 'languageTitle';
                else if (tabName === 'options') titleKey = 'optionsTitle';
                else if (tabName === 'info') titleKey = 'aboutTitle';
                elements.modalTitle.textContent = getTranslatedString(titleKey);
                elements.modalTitle.dataset.translateKey = titleKey;

                if (tabName === 'options') {
                    switchSubTab('player');
                }
            }

            function switchSubTab(subTabName) {
                const optionsPanel = elements.optionsPanel;
                optionsPanel.querySelectorAll('.options-sub-tab-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.subTab === subTabName));
                optionsPanel.querySelectorAll('.options-sub-panel').forEach(panel => panel.classList.toggle('active', panel.id === `${subTabName}-sub-panel`));
            }

            function resetGameFactory() {
                 if (confirm(getTranslatedString('resetConfirm'))) {
                    localStorage.removeItem('puzzletunesGameState');
                    localStorage.removeItem('puzzletunesHighScores');
                    localStorage.removeItem('puzzletunesTotalPlaytime');
                    localStorage.removeItem('puzzletunesPlayerName');
                    localStorage.removeItem('puzzletunesGenres');
                    localStorage.removeItem('puzzletunesLanguage');
                    localStorage.removeItem('puzzletunesAlbumHistory');
                    localStorage.removeItem('puzzletunesOnThisDay');
                    window.location.reload();
                }
            }

            function restartCurrentGame() {
                if (!state.gameInProgress || !state.currentAlbum) return;
                if (confirm(getTranslatedString('restartConfirm'))) {
                    stopTimer();
                    state.time = 0;
                    state.moves = 0;
                    state.isPaused = false;
                    
                    let board = Array.from({ length: SIZE * SIZE }, (_, i) => i);
                    let emptyPosition = SIZE * SIZE - 1;
                    
                    const shuffleMoves = 150; 
                    for (let i = 0; i < shuffleMoves; i++) {
                        const validMoves = getValidMoves(emptyPosition);
                        const move = validMoves[Math.floor(Math.random() * validMoves.length)];
                        [board[emptyPosition], board[move]] = [board[move], board[emptyPosition]];
                        emptyPosition = move;
                    }
                    
                    state.pieces = Array.from({ length: SIZE * SIZE }, (_, i) => ({
                        el: null,
                        originalIndex: i,
                        currentIndex: board.indexOf(i),
                        isEmpty: i === SIZE * SIZE - 1
                    }));
                    
                    const imageUrl = state.currentAlbum.artworkUrl.replace('100x100', '600x600');
                    const boardState = Array(SIZE*SIZE).fill(0);
                    state.pieces.forEach(p => {
                        boardState[p.currentIndex] = p.originalIndex;
                    });
                    renderBoard(imageUrl, boardState);
                    
                    startTimer();
                    hideOverlay();
                    updateUI();
                    saveGameState();
                }
            }
            
            function setupResponsiveControls() {
                const desktopSearch = elements.artistSearchDesktop;
                const mobileSearch = elements.artistSearchMobile;
                
                function handleNewGameClick(onThisDay = false) {
                    if (state.gameInProgress && !confirm(getTranslatedString('newGameConfirm'))) return;
                    
                    if (state.gameInProgress) {
                        clearGameState();
                    }
                    cleanupPreviousGameResources();
                    renderStaticTitle(); // Ensure title persists
                    prepareNewGame(false, null, onThisDay);
                }

                desktopSearch.addEventListener('dblclick', () => desktopSearch.value = '');
                mobileSearch.addEventListener('dblclick', () => mobileSearch.value = '');

                desktopSearch.addEventListener('input', updateButtonAndTextLogic);
                mobileSearch.addEventListener('input', updateButtonAndTextLogic);

                elements.newGameBtnDesktop.addEventListener('click', () => handleNewGameClick(false));
                elements.newGameBtnMobile.addEventListener('click', () => handleNewGameClick(false));
                elements.onThisDayBtnDesktop.addEventListener('click', () => handleNewGameClick(true));
                elements.onThisDayBtnMobile.addEventListener('click', () => handleNewGameClick(true));
                elements.restartGameBtnDesktop.addEventListener('click', restartCurrentGame);
                elements.restartGameBtnMobile.addEventListener('click', restartCurrentGame);

                // Sync search input values
                desktopSearch.addEventListener('input', () => mobileSearch.value = desktopSearch.value);
                mobileSearch.addEventListener('input', () => desktopSearch.value = mobileSearch.value);
            }
            

            elements.menuModal.addEventListener('click', (e) => {
                const tabBtn = e.target.closest('.tab-btn');
                if (tabBtn) switchTab(tabBtn.dataset.tab);

                const langBtn = e.target.closest('.lang-btn');
                if(langBtn) setLanguage(langBtn.dataset.lang);

                const subTabBtn = e.target.closest('.options-sub-tab-btn');
                if (subTabBtn) switchSubTab(subTabBtn.dataset.subTab);
            });
            
            elements.playerNameForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const name = elements.playerNameInput.value;
                if (savePlayerName(name)) {
                    elements.playerNamePrompt.style.display = 'none';
                    initGame();
                } else {
                    alert(getTranslatedString('emptyNameError'));
                }
            });
            
            elements.saveEditedPlayerNameBtn.addEventListener('click', () => {
                const name = elements.editPlayerNameInput.value;
                if (savePlayerName(name)) {
                    updatePlayerNameDisplay();
                    alert('OK!'); // Simple feedback
                } else {
                    alert(getTranslatedString('emptyNameError'));
                }
            });

            elements.resetGameBtn.addEventListener('click', resetGameFactory);

            elements.pauseBtn.addEventListener('click', () => {
                if (!state.gameInProgress) return;
                state.isPaused = !state.isPaused;
                if (state.isPaused) {
                    stopTimer();
                    elements.audioPlayer.pause();
                    showOverlay(getTranslatedString('paused'));
                    elements.puzzleContainer.classList.remove('animated-gradient-border');
                } else {
                    hideOverlay();
                    startTimer();
                    elements.puzzleContainer.classList.add('animated-gradient-border');
                    if (!state.isMuted && elements.audioPlayer.src) {
                        elements.audioPlayer.play().catch(e => console.error("Error on resume:", e));
                    }
                }
                updateUI();
                saveGameState();
            });

            elements.audioBtn.addEventListener('click', () => {
                state.isMuted = !state.isMuted;
                elements.audioPlayer.muted = state.isMuted;
                if (elements.audioPlayer.paused && !state.isMuted) {
                    elements.audioPlayer.play().catch(e => {
                        console.error("Error on unmute:", e);
                        state.isMuted = true;
                        elements.audioPlayer.muted = true;
                    });
                }
                updateUI();
                if (state.gameInProgress) saveGameState();
            });

            elements.audioPlayer.addEventListener('canplaythrough', () => elements.audioBtn.disabled = false);
            
            elements.menuBtn.addEventListener('click', () => {
                renderHighScores();
                renderGenreSelector();
                renderOnThisDayOption();
                updatePlayerNameDisplay(); // Ensure name is current in edit field
                switchTab('records');
                elements.menuModal.classList.add('visible');
            });
            elements.closeMenuBtn.addEventListener('click', () => elements.menuModal.classList.remove('visible'));

            elements.highScoresList.addEventListener('click', (e) => {
                const deleteBtn = e.target.closest('.score-delete-btn');
                if (deleteBtn) deleteScore(parseInt(deleteBtn.dataset.id, 10));
            });
            window.addEventListener('beforeunload', () => saveGameState());
            
             // Levenshtein distance function for suggestions
            function calculateLevenshteinDistance(a, b) {
                if (a.length === 0) return b.length;
                if (b.length === 0) return a.length;
                const matrix = [];
                for (let i = 0; i <= b.length; i++) {
                    matrix[i] = [i];
                }
                for (let j = 0; j <= a.length; j++) {
                    matrix[0][j] = j;
                }
                for (let i = 1; i <= b.length; i++) {
                    for (let j = 1; j <= a.length; j++) {
                        if (b.charAt(i - 1) === a.charAt(j - 1)) {
                            matrix[i][j] = matrix[i - 1][j - 1];
                        } else {
                            matrix[i][j] = Math.min(
                                matrix[i - 1][j - 1] + 1,
                                matrix[i][j - 1] + 1,
                                matrix[i - 1][j] + 1
                            );
                        }
                    }
                }
                return matrix[b.length][a.length];
            }
            
            initializeLocalization();
            setupResponsiveControls();
            initGame();
        });
    </script>
</body>
</html>
